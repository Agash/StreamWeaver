This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: package-lock.json, tmp/, dist/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cspell.json
.editorconfig
.gitattributes
.github/dependabot.yml
.github/workflows/master.yml
.gitignore
.htmlhintrc
.jscpd.json
.mega-linter.yml
.secretlintrc.json
.stylelintrc.json
.yamllint.yml
app.manifest
App.xaml
App.xaml.cs
Assets/Badges/youtube_moderator.svg
Assets/Badges/youtube_owner.svg
Assets/Badges/youtube_verified.svg
Assets/Icons/twitch.svg
Assets/Icons/youtube.svg
Core/Messaging/ConnectionsUpdateMessage.cs
Core/Messaging/NewEventMessage.cs
Core/Models/Events/BadgeInfo.cs
Core/Models/Events/BaseEvent.cs
Core/Models/Events/BotMessageEvent.cs
Core/Models/Events/ChatMessageEvent.cs
Core/Models/Events/CommandInvocationEvent.cs
Core/Models/Events/DonationEvent.cs
Core/Models/Events/FollowEvent.cs
Core/Models/Events/HostEvent.cs
Core/Models/Events/MembershipEvent.cs
Core/Models/Events/Messages/EmoteSegment.cs
Core/Models/Events/Messages/MessageSegment.cs
Core/Models/Events/Messages/PollOption.cs
Core/Models/Events/Messages/TextSegment.cs
Core/Models/Events/ModerationActionEvent.cs
Core/Models/Events/RaidEvent.cs
Core/Models/Events/SubscriptionEvent.cs
Core/Models/Events/SystemMessageEvent.cs
Core/Models/Events/UserStatus.cs
Core/Models/Events/WhisperEvent.cs
Core/Models/Events/YouTubePollUpdateEvent.cs
Core/Models/LogEntry.cs
Core/Models/PlatformData/UserInfo.cs
Core/Models/ServiceModels/TwitchBadgeInfo.cs
Core/Models/ServiceModels/TwitchEmoteInfo.cs
Core/Models/Settings/ApiCredentials.cs
Core/Models/Settings/AppSettings.cs
Core/Models/Settings/ChatOverlaySettings.cs
Core/Models/Settings/ConnectionSettings.cs
Core/Models/Settings/ConnectionStatus.cs
Core/Models/Settings/ModuleSettings.cs
Core/Models/Settings/OverlaySettings.cs
Core/Models/Settings/TtsSettings.cs
Core/Models/Settings/TwitchAccount.cs
Core/Models/Settings/YouTubeAccount.cs
Core/Plugins/IChatCommandPlugin.cs
Core/Plugins/IConfigurablePlugin.cs
Core/Plugins/IEventProcessorPlugin.cs
Core/Plugins/IPlugin.cs
Core/Plugins/IPluginHost.cs
Core/Plugins/IPluginUIPageProvider.cs
Core/Plugins/PluginHost.cs
Core/Plugins/PluginManifest.cs
Core/Plugins/PluginService.cs
Core/Plugins/WebPluginManifest.cs
Core/Services/Authentication/IAuthService.cs
Core/Services/Authentication/ITokenStorageService.cs
Core/Services/Authentication/TokenStorageService.cs
Core/Services/Authentication/TwitchAuthService.cs
Core/Services/Authentication/YouTubeAuthService.cs
Core/Services/EmoteBadgeService.cs
Core/Services/IEmoteBadgeService.cs
Core/Services/Logging/ObservableLogger.cs
Core/Services/Logging/ObservableLoggerProvider.cs
Core/Services/LogViewerService.cs
Core/Services/Platforms/IStreamlabsClient.cs
Core/Services/Platforms/ITwitchClient.cs
Core/Services/Platforms/IYouTubeClient.cs
Core/Services/Platforms/StreamlabsService.cs
Core/Services/Platforms/TwitchApiService.cs
Core/Services/Platforms/TwitchChatService.cs
Core/Services/Platforms/YouTubeService.cs
Core/Services/Settings/ISettingsService.cs
Core/Services/Settings/SettingsService.cs
Core/Services/Tts/CompositeTtsService.cs
Core/Services/Tts/IEngineSpecificTtsService.cs
Core/Services/Tts/ITtsService.cs
Core/Services/Tts/KokoroTtsService.cs
Core/Services/Tts/TtsFormattingService.cs
Core/Services/Tts/WindowsTtsService.cs
Core/Services/UnifiedEventService.cs
Core/Services/Web/WebServerService.cs
Core/Services/Web/WebSocketManager.cs
MainWindow.xaml
MainWindow.xaml.cs
Modules/Goals/GoalService.cs
Modules/Goals/GoalSettings.cs
Modules/Subathon/SubathonService.cs
Modules/Subathon/SubathonSettings.cs
Package.appxmanifest
Properties/launchSettings.json
README.md
StreamWeaver.csproj
StreamWeaver.sln
Themes/Generic.xaml
UI/Converters/AutoHostTextConverter.cs
UI/Converters/BadgeIdentifierToTwitchUrlConverter.cs
UI/Converters/BadgeIdentifierToUrlConverter.cs
UI/Converters/BadgeInfoToImageSourceConverter.cs
UI/Converters/BoolInverterConverter.cs
UI/Converters/BoolToFontStyleConverter.cs
UI/Converters/BoolToOpacityConverter.cs
UI/Converters/BoolToStringConverter.cs
UI/Converters/BoolToVisibilityConverter.cs
UI/Converters/ConnectionStatusToBrushConverter.cs
UI/Converters/ConnectionStatusToSymbolConverter.cs
UI/Converters/DateTimeFormatConverter.cs
UI/Converters/DonationToBrushConverter.cs
UI/Converters/EqualityToVisibilityConverter.cs
UI/Converters/HostEventTextConverter.cs
UI/Converters/IntToVisibilityConverter.cs
UI/Converters/LogLevelToBrushConverter.cs
UI/Converters/LogLevelToSymbolConverter.cs
UI/Converters/MembershipDetailsConverter.cs
UI/Converters/MembershipMilestoneConverter.cs
UI/Converters/MembershipTypeToBrushConverter.cs
UI/Converters/NullToBoolConverter.cs
UI/Converters/NullToVisibilityConverter.cs
UI/Converters/PlatformToBrushConverter.cs
UI/Converters/PlatformToIconConverter.cs
UI/Converters/PlatformToIsEnabledConverter.cs
UI/Converters/PlatformToMarginConverter.cs
UI/Converters/PlatformToVisibilityConverter.cs
UI/Converters/SegmentsToBlocksConverter.cs
UI/Converters/StringToBrushConverter.cs
UI/Converters/StringToVisibilityConverter.cs
UI/Converters/SubEventDurationConverter.cs
UI/Converters/SubEventMessageConverter.cs
UI/Converters/SubEventRecipientConverter.cs
UI/Converters/SubEventTotalGiftsConverter.cs
UI/Converters/SubEventVerbConverter.cs
UI/Converters/SystemMessageLevelToBrushConverter.cs
UI/Converters/SystemMessageLevelToSymbolConverter.cs
UI/Dialogs/ConnectAccountDialog.xaml
UI/Dialogs/ConnectAccountDialog.xaml.cs
UI/Dialogs/CreatePollDialog.xaml
UI/Dialogs/CreatePollDialog.xaml.cs
UI/Helpers/RichTextBlockEventHelper.cs
UI/Helpers/RichTextBlocksHelper.cs
UI/Selectors/EventTemplateSelector.cs
UI/Selectors/MessageSegmentTemplateSelector.cs
UI/Selectors/SettingsSectionTemplateSelector.cs
UI/ViewModels/ConnectAccountViewModel.cs
UI/ViewModels/CreatePollDialogViewModel.cs
UI/ViewModels/LogsViewModel.cs
UI/ViewModels/MainChatViewModel.cs
UI/ViewModels/MainWindowViewModel.cs
UI/ViewModels/SettingsViewModel.cs
UI/Views/LogsView.xaml
UI/Views/LogsView.xaml.cs
UI/Views/MainChatView.xaml
UI/Views/MainChatView.xaml.cs
UI/Views/SettingsPages/AccountsSettingsPage.xaml
UI/Views/SettingsPages/AccountsSettingsPage.xaml.cs
UI/Views/SettingsPages/CredentialsSettingsPage.xaml
UI/Views/SettingsPages/CredentialsSettingsPage.xaml.cs
UI/Views/SettingsPages/ModulesSettingsPage.xaml
UI/Views/SettingsPages/ModulesSettingsPage.xaml.cs
UI/Views/SettingsPages/OverlaysSettingsPage.xaml
UI/Views/SettingsPages/OverlaysSettingsPage.xaml.cs
UI/Views/SettingsPages/PluginsSettingsPage.xaml
UI/Views/SettingsPages/PluginsSettingsPage.xaml.cs
UI/Views/SettingsPages/TtsSettingsPage.xaml
UI/Views/SettingsPages/TtsSettingsPage.xaml.cs
UI/Views/SettingsView.xaml
UI/Views/SettingsView.xaml.cs
Web/Overlay/.gitignore
Web/Overlay/.hintrc
Web/Overlay/eslint.config.js
Web/Overlay/index.html
Web/Overlay/package.json
Web/Overlay/public/vite.svg
Web/Overlay/README.md
Web/Overlay/src/App.css
Web/Overlay/src/App.tsx
Web/Overlay/src/assets/icons/twitch.svg
Web/Overlay/src/assets/icons/youtube_moderator.svg
Web/Overlay/src/assets/icons/youtube_owner.svg
Web/Overlay/src/assets/icons/youtube_verified.svg
Web/Overlay/src/assets/icons/youtube.svg
Web/Overlay/src/components/ChatContainer.tsx
Web/Overlay/src/components/events/badgeHelper.ts
Web/Overlay/src/components/events/DefaultChatMessage.tsx
Web/Overlay/src/components/events/DefaultDonationMessage.tsx
Web/Overlay/src/components/events/DefaultFollowMessage.tsx
Web/Overlay/src/components/events/DefaultMembershipMessage.tsx
Web/Overlay/src/components/events/DefaultRaidMessage.tsx
Web/Overlay/src/components/events/DefaultSubscriptionMessage.tsx
Web/Overlay/src/components/events/DefaultSystemMessage.tsx
Web/Overlay/src/components/events/renderHelper.tsx
Web/Overlay/src/index.css
Web/Overlay/src/main.tsx
Web/Overlay/src/store.ts
Web/Overlay/src/types.ts
Web/Overlay/src/utils/connectWebSocket.ts
Web/Overlay/src/vite-env.d.ts
Web/Overlay/src/webSocketService.ts
Web/Overlay/tsconfig.app.json
Web/Overlay/tsconfig.json
Web/Overlay/tsconfig.node.json
Web/Overlay/vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Assets/Icons/twitch.svg">
<?xml version="1.0" encoding="utf-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg fill="#000000" width="800px" height="800px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg">
<title>twitch</title>
<path d="M26.711 14.929l-4.284 4.284h-4.285l-3.749 3.749v-3.749h-4.82v-16.067h17.138zM8.502 1.004l-5.356 5.356v19.279h6.427v5.356l5.356-5.356h4.284l9.641-9.64v-14.996zM21.356 6.895h2.142v6.427h-2.142zM15.464 6.895h2.143v6.427h-2.144z"></path>
</svg>
</file>

<file path="Assets/Icons/youtube.svg">
<?xml version="1.0" encoding="utf-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg fill="#000000" width="800px" height="800px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg">
<title>youtube</title>
<path d="M12.932 20.459v-8.917l7.839 4.459zM30.368 8.735c-0.354-1.301-1.354-2.307-2.625-2.663l-0.027-0.006c-3.193-0.406-6.886-0.638-10.634-0.638-0.381 0-0.761 0.002-1.14 0.007l0.058-0.001c-0.322-0.004-0.701-0.007-1.082-0.007-3.748 0-7.443 0.232-11.070 0.681l0.434-0.044c-1.297 0.363-2.297 1.368-2.644 2.643l-0.006 0.026c-0.4 2.109-0.628 4.536-0.628 7.016 0 0.088 0 0.176 0.001 0.263l-0-0.014c-0 0.074-0.001 0.162-0.001 0.25 0 2.48 0.229 4.906 0.666 7.259l-0.038-0.244c0.354 1.301 1.354 2.307 2.625 2.663l0.027 0.006c3.193 0.406 6.886 0.638 10.634 0.638 0.38 0 0.76-0.002 1.14-0.007l-0.058 0.001c0.322 0.004 0.702 0.007 1.082 0.007 3.749 0 7.443-0.232 11.070-0.681l-0.434 0.044c1.298-0.362 2.298-1.368 2.646-2.643l0.006-0.026c0.399-2.109 0.627-4.536 0.627-7.015 0-0.088-0-0.176-0.001-0.263l0 0.013c0-0.074 0.001-0.162 0.001-0.25 0-2.48-0.229-4.906-0.666-7.259l0.038 0.244z"></path>
</svg>
</file>

<file path="Core/Plugins/IConfigurablePlugin.cs">
namespace StreamWeaver.Core.Plugins;
public interface IConfigurablePlugin
{
    static abstract Type OptionsType { get; }
    static abstract string DefaultConfigurationSectionName { get; }
}
</file>

<file path="Core/Plugins/IPluginUIPageProvider.cs">
using System;
namespace StreamWeaver.Core.Plugins;
public interface IPluginUIPageProvider
{
    string SettingsPageDisplayName { get; }
    Type SettingsPageType { get; }
    string? SettingsIconGlyph { get; }
    string? SettingsPageTooltip { get; }
}
</file>

<file path="Core/Plugins/WebPluginManifest.cs">
using System.Text.Json.Serialization;
namespace StreamWeaver.Core.Plugins;
public class WebPluginManifest
{
    [JsonPropertyName("id")]
    public string? Id { get; set; }
    [JsonPropertyName("name")]
    public string? Name { get; set; }
    [JsonPropertyName("version")]
    public string? Version { get; set; }
    [JsonPropertyName("author")]
    public string? Author { get; set; }
    [JsonPropertyName("description")]
    public string? Description { get; set; }
    [JsonPropertyName("entryScript")]
    public string? EntryScript { get; set; }
    [JsonPropertyName("entryStyle")]
    public string? EntryStyle { get; set; }
    [JsonPropertyName("providesComponents")]
    public List<string>? ProvidesComponents { get; set; } = [];
    [JsonPropertyName("registersWebComponents")]
    public List<WebComponentRegistration>? RegistersWebComponents { get; set; } = [];
    [JsonIgnore]
    public string? BasePath { get; set; }
    [JsonIgnore]
    public string? DirectoryPath { get; set; }
}
public class WebComponentRegistration
{
    [JsonPropertyName("tagName")]
    public string? TagName { get; set; }
    [JsonPropertyName("scriptPath")]
    public string? ScriptPath { get; set; }
}
</file>

<file path="Web/Overlay/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="Web/Overlay/.hintrc">
{
  "extends": [
    "development"
  ],
  "hints": {
    "no-inline-styles": "off"
  }
}
</file>

<file path="Web/Overlay/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)
</file>

<file path="Web/Overlay/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>StreamWeaver Overlay</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="Web/Overlay/package.json">
{
  "name": "streamweaver-overlay",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.4",
    "framer-motion": "^12.9.2",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "rxjs": "^7.8.2",
    "tailwindcss": "^4.1.4",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/js": "^9.22.0",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.22.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.26.1",
    "vite": "^6.3.1",
    "vite-plugin-svgr": "^4.3.0"
  }
}
</file>

<file path="Web/Overlay/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="Web/Overlay/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```
</file>

<file path="Web/Overlay/src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}
</file>

<file path="Web/Overlay/src/App.tsx">
import { useEffect, useRef, useCallback } from 'react';
import { useStore } from './store';
import { webSocketService } from './webSocketService';
import ChatContainer from './components/ChatContainer';
import { DisplayedItem, WebSocketMessage, InitPayload, OverlaySettings, BaseEvent } from './types';
if (!window.StreamWeaverOverlay) {
     window.StreamWeaverOverlay = {
         plugins: {
             registry: {
                 componentOverrides: {},
             },
             registerComponentOverride: (key, component) => {
                 console.log(`[Plugin Registry] Registered override for component: ${key}`);
                 window.StreamWeaverOverlay.plugins.registry.componentOverrides[key] = component;
             },
         },
     };
}
function App() {
    const settings = useStore((state) => state.settings);
    const displayedItems = useStore((state) => state.displayedItems);
    const plugins = useStore((state) => state.plugins);
    const isConnected = useStore((state) => state.isConnected);
    const connectionStatus = useStore((state) => state.connectionStatus);
    const initialize = useStore((state) => state.initialize);
    const setSettings = useStore((state) => state.setSettings);
    const addEvent = useStore((state) => state.addEvent);
    const removeItemByKey = useStore((state) => state.removeItemByKey);
    const setConnectionStatus = useStore((state) => state.setConnectionStatus);
    const setPlugins = useStore((state) => state.setPlugins);
    const resetDisplayedItems = useStore((state) => state.resetDisplayedItems);
    const timeoutRefs = useRef<Map<string, number>>(new Map());
    const loadedPluginAssets = useRef(new Set<string>());
    const clearAndRemoveTimeout = useCallback((eventKey: string) => {
        const timeoutId = timeoutRefs.current.get(eventKey);
        if (timeoutId !== undefined) {
            window.clearTimeout(timeoutId);
            timeoutRefs.current.delete(eventKey);
            console.log(`[Timeout] Cleared and removed timeout reference for ${eventKey}`);
        }
    }, []);
    const clearAllTimeouts = useCallback(() => {
        console.log(`[Timeout] Clearing all ${timeoutRefs.current.size} active removal timeouts...`);
        timeoutRefs.current.forEach((timeoutId, key) => {
            window.clearTimeout(timeoutId);
            console.log(`[Timeout] Cleared timeout for ${key} (clearAll)`);
        });
        timeoutRefs.current.clear();
    }, []);
    const scheduleRemoval = useCallback((item: DisplayedItem, delayMs: number) => {
        clearAndRemoveTimeout(item.key);
        if (delayMs <= 0) {
            console.warn(`[Timeout] Attempted to schedule removal for ${item.key} with invalid delay: ${delayMs}ms. Skipping.`);
            return;
        }
        console.log(`[Timeout] Scheduling removal for ${item.key} in ${delayMs}ms`);
        const removalTimeoutId = window.setTimeout(() => {
            console.log(`[Timeout Fired] Requesting removal of item ${item.key} via timeout`);
            removeItemByKey(item.key);
        }, delayMs);
        timeoutRefs.current.set(item.key, removalTimeoutId);
    }, [clearAndRemoveTimeout, removeItemByKey]);
    useEffect(() => {
        console.log('[App Mount] Setting up WebSocket subscriptions.');
        const statusSub = webSocketService.connectionStatus$.subscribe(status => {
            console.log(`[App] Received connection status: ${status}`);
            setConnectionStatus(status);
            if (status === 'connecting' || status === 'disconnected') {
            }
        });
        const messageSub = webSocketService.message$.subscribe((message: WebSocketMessage) => {
            console.log('[App] Received message from service:', message.type);
            switch (message.type) {
                case 'init':
                    clearAllTimeouts();
                    initialize(message.payload as InitPayload);
                    break;
                case 'settings':
                    clearAllTimeouts();
                    setSettings(message.payload as OverlaySettings);
                    break;
                case 'event':
                    addEvent(message.payload as BaseEvent);
                    break;
                default:
                    console.warn('[App] Received unknown message type from service:', message.type);
            }
        });
        webSocketService.connect();
        return () => {
            console.log("[App Unmount] Cleaning up WebSocket subscriptions and connection.");
            statusSub.unsubscribe();
            messageSub.unsubscribe();
            webSocketService.close();
            clearAllTimeouts();
        };
    }, [initialize, setSettings, addEvent, setConnectionStatus, clearAllTimeouts, resetDisplayedItems]);
    useEffect(() => {
        if (!settings) {
            console.log('[Timeout Effect] No settings, skipping timeout logic.');
            return;
        }
        const { fadeMessages, fadeDelaySeconds } = settings.chat;
        const fadeDelayMs = Math.max(fadeDelaySeconds, 0.1) * 1000;
        console.log(`[Timeout Effect] Running. Fade: ${fadeMessages}, Delay: ${fadeDelayMs}ms, Items: ${displayedItems.length}`);
        if (!fadeMessages) {
            console.log('[Timeout Effect] Fading disabled, clearing all timeouts.');
            clearAllTimeouts();
            return;
        }
        const currentItemKeys = new Set(displayedItems.map(item => item.key));
        timeoutRefs.current.forEach((_, key) => {
            if (!currentItemKeys.has(key)) {
                console.log(`[Timeout Effect] Clearing timeout for removed item: ${key}`);
                clearAndRemoveTimeout(key);
            }
        });
        displayedItems.forEach(item => {
            if (!timeoutRefs.current.has(item.key)) {
                console.log(`[Timeout Effect] Scheduling timeout for new/existing item: ${item.key}`);
                scheduleRemoval(item, fadeDelayMs);
            }
        });
    }, [settings, displayedItems, scheduleRemoval, clearAllTimeouts, clearAndRemoveTimeout]);
    useEffect(() => {
        if (!plugins || plugins.length === 0) return;
        console.log("[Plugin Loader] Processing discovered plugins...", plugins.map(p => p.id));
        plugins.forEach((plugin) => {
            if (plugin.entryScript) {
                const scriptUrl = `${plugin.basePath}${plugin.entryScript}`;
                if (!loadedPluginAssets.current.has(scriptUrl)) {
                    console.log(`[Plugin Loader] Loading plugin script: ${scriptUrl}`);
                    const script = document.createElement('script');
                    script.src = scriptUrl;
                    script.type = 'module';
                    script.async = true;
                    script.onerror = () => console.error(`Failed to load plugin script: ${scriptUrl}`);
                    script.onload = () => console.log(`Successfully loaded plugin script: ${scriptUrl}`);
                    document.body.appendChild(script);
                    loadedPluginAssets.current.add(scriptUrl);
                }
            }
            if (plugin.entryStyle) {
                const styleUrl = `${plugin.basePath}${plugin.entryStyle}`;
                 if (!loadedPluginAssets.current.has(styleUrl)) {
                    console.log(`[Plugin Loader] Loading plugin style: ${styleUrl}`);
                    const link = document.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = styleUrl;
                    link.onerror = () => console.error(`Failed to load plugin style: ${styleUrl}`);
                    link.onload = () => console.log(`Successfully loaded plugin style: ${styleUrl}`);
                    document.head.appendChild(link);
                    loadedPluginAssets.current.add(styleUrl);
                }
            }
             plugin.registersWebComponents?.forEach(wc => {
                if (wc.scriptPath) {
                    const wcScriptUrl = `${plugin.basePath}${wc.scriptPath}`;
                     if (!loadedPluginAssets.current.has(wcScriptUrl)) {
                         console.log(`[Plugin Loader] Loading web component script: ${wcScriptUrl} (for <${wc.tagName}>)`);
                        const script = document.createElement('script');
                        script.src = wcScriptUrl;
                        script.type = 'module';
                        script.async = true;
                        script.onerror = () => console.error(`Failed to load web component script: ${wcScriptUrl}`);
                        script.onload = () => console.log(`Successfully loaded web component script: ${wcScriptUrl}`);
                        document.body.appendChild(script);
                        loadedPluginAssets.current.add(wcScriptUrl);
                    }
                }
            });
        });
    }, [plugins]);
    return (
        <div className="App w-full h-full border border-purple-500">
            {}
            {connectionStatus === 'connecting' && !settings && (
                <div className="connection-status fixed top-2 left-2 p-2 bg-yellow-600 text-white rounded text-xs z-50">
                    Connecting...
                </div>
            )}
             {connectionStatus === 'connecting' && settings && (
                <div className="connection-status fixed top-2 left-2 p-2 bg-yellow-600 text-white rounded text-xs z-50">
                    Reconnecting...
                </div>
            )}
            {connectionStatus === 'error' && (
                <div className="connection-status fixed top-2 left-2 p-2 bg-red-700 text-white rounded text-xs z-50">
                    Connection Error!
                </div>
            )}
             {!isConnected && connectionStatus === 'disconnected' && settings && (
                 <div className="connection-status fixed top-2 left-2 p-2 bg-red-600 text-white rounded text-xs z-50">
                    Disconnected.
                 </div>
             )}
            {!settings && connectionStatus !== 'connecting' && connectionStatus !== 'error' && (
                <div className="connection-status fixed top-2 left-2 p-2 bg-gray-600 text-white rounded text-xs z-50">
                    Waiting for Init...
                </div>
            )}
            {}
            {}
            <ChatContainer />
        </div>
    );
}
export default App;
</file>

<file path="Web/Overlay/src/assets/icons/twitch.svg">
<?xml version="1.0" encoding="utf-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg fill="#000000" width="800px" height="800px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg">
<title>twitch</title>
<path d="M26.711 14.929l-4.284 4.284h-4.285l-3.749 3.749v-3.749h-4.82v-16.067h17.138zM8.502 1.004l-5.356 5.356v19.279h6.427v5.356l5.356-5.356h4.284l9.641-9.64v-14.996zM21.356 6.895h2.142v6.427h-2.142zM15.464 6.895h2.143v6.427h-2.144z"></path>
</svg>
</file>

<file path="Web/Overlay/src/assets/icons/youtube_moderator.svg">
<?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" focusable="false" aria-hidden="true" style="pointer-events: none; display: inherit; width: 100%; height: 100%;"><path d="M9.64589146,7.05569719 C9.83346524,6.562372 9.93617022,6.02722257 9.93617022,5.46808511 C9.93617022,3.00042984 7.93574038,1 5.46808511,1 C4.90894765,1 4.37379823,1.10270499 3.88047304,1.29027875 L6.95744681,4.36725249 L4.36725255,6.95744681 L1.29027875,3.88047305 C1.10270498,4.37379824 1,4.90894766 1,5.46808511 C1,7.93574038 3.00042984,9.93617022 5.46808511,9.93617022 C6.02722256,9.93617022 6.56237198,9.83346524 7.05569716,9.64589147 L12.4098057,15 L15,12.4098057 L9.64589146,7.05569719 Z"></path></svg>
</file>

<file path="Web/Overlay/src/assets/icons/youtube_owner.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Layer_2" data-name="Layer 2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 885.65 726.5">
  <g id="Objects">
    <g>
      <path d="M846.41,146.33c-21.67,0-39.24,17.57-39.24,39.24,0,16.45,10.13,30.52,24.47,36.36-31.29,61.45-130.68,162.52-214.9,145.1-59.57-12.32-116.55-81.9-169.05-262.6,26.61-2.46,47.46-24.84,47.46-52.1,0-28.9-23.42-52.33-52.33-52.33s-52.33,23.42-52.33,52.33c0,27.26,20.84,49.64,47.46,52.1-52.49,180.7-109.48,250.28-169.05,262.6-84.22,17.43-183.61-83.65-214.9-145.1,14.34-5.84,24.47-19.91,24.47-36.36,0-21.67-17.57-39.24-39.24-39.24S0,163.9,0,185.57s17.57,39.24,39.24,39.24c2.55,0,5.04-.25,7.46-.72,31.65,119.43,52.93,189.55,92.81,344.06h606.65c39.87-154.5,61.16-224.62,92.81-344.06,2.42.47,4.91.72,7.46.72,21.67,0,39.24-17.57,39.24-39.24s-17.57-39.24-39.24-39.24Z"/>
      <path d="M139.5,695.43c0,17.16,13.91,31.07,31.07,31.07h544.5c17.16,0,31.07-13.91,31.07-31.07v-85.41H139.5v85.41Z"/>
    </g>
  </g>
</svg>
</file>

<file path="Web/Overlay/src/assets/icons/youtube_verified.svg">
<?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" focusable="false" aria-hidden="true" style="pointer-events: none; display: inherit; width: 100%; height: 100%;"><path transform="scale(0.66)" d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"></path></svg>
</file>

<file path="Web/Overlay/src/assets/icons/youtube.svg">
<?xml version="1.0" encoding="utf-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg fill="#000000" width="800px" height="800px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg">
<title>youtube</title>
<path d="M12.932 20.459v-8.917l7.839 4.459zM30.368 8.735c-0.354-1.301-1.354-2.307-2.625-2.663l-0.027-0.006c-3.193-0.406-6.886-0.638-10.634-0.638-0.381 0-0.761 0.002-1.14 0.007l0.058-0.001c-0.322-0.004-0.701-0.007-1.082-0.007-3.748 0-7.443 0.232-11.070 0.681l0.434-0.044c-1.297 0.363-2.297 1.368-2.644 2.643l-0.006 0.026c-0.4 2.109-0.628 4.536-0.628 7.016 0 0.088 0 0.176 0.001 0.263l-0-0.014c-0 0.074-0.001 0.162-0.001 0.25 0 2.48 0.229 4.906 0.666 7.259l-0.038-0.244c0.354 1.301 1.354 2.307 2.625 2.663l0.027 0.006c3.193 0.406 6.886 0.638 10.634 0.638 0.38 0 0.76-0.002 1.14-0.007l-0.058 0.001c0.322 0.004 0.702 0.007 1.082 0.007 3.749 0 7.443-0.232 11.070-0.681l-0.434 0.044c1.298-0.362 2.298-1.368 2.646-2.643l0.006-0.026c0.399-2.109 0.627-4.536 0.627-7.015 0-0.088-0-0.176-0.001-0.263l0 0.013c0-0.074 0.001-0.162 0.001-0.25 0-2.48-0.229-4.906-0.666-7.259l0.038 0.244z"></path>
</svg>
</file>

<file path="Web/Overlay/src/components/ChatContainer.tsx">
import React from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { useStore } from '../store';
import { ChatMessageEvent, DonationEvent, MembershipEvent, SubscriptionEvent, FollowEvent, RaidEvent, SystemMessageEvent } from '../types';
import DefaultChatMessage from './events/DefaultChatMessage';
import DefaultDonationMessage from './events/DefaultDonationMessage';
import DefaultMembershipMessage from './events/DefaultMembershipMessage';
import DefaultFollowMessage from './events/DefaultFollowMessage';
import DefaultRaidMessage from './events/DefaultRaidMessage';
import DefaultSubscriptionMessage from './events/DefaultSubscriptionMessage';
import DefaultSystemMessage from './events/DefaultSystemMessage';
const ChatContainer: React.FC = () => {
    const displayedItems = useStore((state) => state.displayedItems);
    const settings = useStore((state) => state.settings);
    if (!settings) return null;
    const messageVariants = {
        initial: { opacity: 0, y: 20, scale: 0.95 },
        animate: { opacity: 1, y: 0, scale: 1, transition: { duration: 0.3, ease: "easeOut" } },
        exit: { opacity: 0, x: -30, scale: 0.9, transition: { duration: 0.2, ease: "easeIn" } }
    };
    return (
        <div
            id="chat-container"
            className="flex flex-col-reverse h-full overflow-hidden p-2 min-h-0"
            style={{
                 fontFamily: settings.chat.font,
                 fontSize: `${settings.chat.fontSize}px`,
            }}
        >
            {}
            {}
            <div> {}
                <AnimatePresence initial={false}>
                    {displayedItems.map((item) => {
                        const eventData = item.event;
                        const key = item.key;
                        const eventTypeKey = eventData.$type;
                        const OverrideComponent = window.StreamWeaverOverlay?.plugins?.registry?.componentOverrides?.[eventTypeKey];
                        return (
                            <motion.div
                                key={key}
                                layout
                                variants={messageVariants}
                                initial="initial"
                                animate="animate"
                                exit="exit"
                                className="chat-item-wrapper w-full flex-shrink-0 mb-1"
                            >
                                {}
                                {OverrideComponent ? (
                                    <OverrideComponent event={eventData} settings={settings} />
                                ) : (() => {
                                    switch (eventTypeKey) {
                                        case 'ChatMessageEvent': return <DefaultChatMessage event={eventData as ChatMessageEvent} settings={settings} />;
                                        case 'DonationEvent': return <DefaultDonationMessage event={eventData as DonationEvent} settings={settings} />;
                                        case 'MembershipEvent': return <DefaultMembershipMessage event={eventData as MembershipEvent} settings={settings} />;
                                        case 'SubscriptionEvent': return <DefaultSubscriptionMessage event={eventData as SubscriptionEvent} settings={settings} />;
                                        case 'FollowEvent': return <DefaultFollowMessage event={eventData as FollowEvent} settings={settings} />;
                                        case 'RaidEvent': return <DefaultRaidMessage event={eventData as RaidEvent} settings={settings} />;
                                        case 'SystemMessageEvent': return <DefaultSystemMessage event={eventData as SystemMessageEvent} settings={settings} />;
                                        default:
                                            console.warn(`[ChatContainer] No component for event type: ${eventTypeKey}, ID: ${key}`);
                                            return <div className="p-1 mb-1 bg-red-900 text-white rounded text-xs">Unhandled: {eventTypeKey}</div>;
                                    }
                                })()}
                            </motion.div>
                        );
                    })}
                </AnimatePresence>
            </div>
            {}
            <div className="flex-grow border border-b-emerald-500"> {}</div>
        </div>
    );
};
export default ChatContainer;
</file>

<file path="Web/Overlay/src/components/events/badgeHelper.ts">
import React from 'react';
import { BadgeInfo } from '../../types';
import YtOwnerIcon from '/src/assets/icons/youtube_owner.svg?react';
import YtModIcon from '/src/assets/icons/youtube_moderator.svg?react';
import YtVerifiedIcon from '/src/assets/icons/youtube_verified.svg?react';
export const standardBadgeIdentifiers = new Set([
    'youtube/owner/1',
    'youtube/moderator/1',
    'youtube/verified/1',
    'twitch/broadcaster/1',
    'twitch/moderator/1',
    'twitch/vip/1',
    'twitch/partner/1',
]);
export const isStandardBadge = (badge: BadgeInfo): boolean => {
    return standardBadgeIdentifiers.has(badge.identifier);
};
export const isCustomBadge = (badge: BadgeInfo): boolean => {
    return !standardBadgeIdentifiers.has(badge.identifier);
};
export const standardBadgeColorOverrides: Record<string, string> = {
    'youtube/owner/1': '#FFD700',
    'youtube/verified/1': '#AAAAAA',
    'twitch/broadcaster/1': '#E91916',
    'twitch/vip/1': '#E005B9',
    'twitch/partner/1': '#9146FF',
};
export const standardBadgeComponentMap: Record<string, { Component: React.FC<React.SVGProps<SVGSVGElement>>; alt: string }> = {
    'youtube/owner/1': { Component: YtOwnerIcon, alt: 'Owner' },
    'youtube/moderator/1': { Component: YtModIcon, alt: 'Moderator' },
    'youtube/verified/1': { Component: YtVerifiedIcon, alt: 'Verified' },
};
</file>

<file path="Web/Overlay/src/components/events/DefaultChatMessage.tsx">
import React from 'react';
import { ChatMessageEvent, OverlaySettings } from '../../types';
import { renderSegments } from './renderHelper';
import { isStandardBadge, isCustomBadge, standardBadgeComponentMap, standardBadgeColorOverrides } from './badgeHelper';
import TwitchIcon from '/src/assets/icons/twitch.svg?react';
import YouTubeIcon from '/src/assets/icons/youtube.svg?react';
interface DefaultChatMessageProps {
    event: ChatMessageEvent;
    settings: OverlaySettings | null;
}
const DefaultChatMessage: React.FC<DefaultChatMessageProps> = ({ event, settings }) => {
    if (!settings) return null;
    const nameStyle: React.CSSProperties = {};
    let nameColor = settings.chat.textColor;
    if (settings.chat.usePlatformColors && event.usernameColor) {
        nameColor = event.usernameColor;
    }
    nameStyle.color = nameColor;
    const containerStyle: React.CSSProperties = {
        backgroundColor: settings.chat.backgroundColor,
        color: settings.chat.textColor,
        fontFamily: settings.chat.font,
        fontSize: `${settings.chat.fontSize}px`,
    };
    const highlightStyle: React.CSSProperties = event.isHighlight
        ? { backgroundColor: settings.chat.highlightColor + '26' }
        : {};
    const highlightBorderStyle: React.CSSProperties = event.isHighlight
        ? { borderColor: settings.chat.highlightColor }
        : {};
    const PlatformIconComponent = event.platform === 'Twitch' ? TwitchIcon :
                                 event.platform === 'YouTube' ? YouTubeIcon : undefined;
    const platformColor = event.platform === 'Twitch' ? '#9146FF' :
                         event.platform === 'YouTube' ? '#FF0000' :
                         settings.chat.textColor;
    const standardBadges = event.badges?.filter(isStandardBadge) ?? [];
    const customBadges = event.badges?.filter(isCustomBadge) ?? [];
    return (
        <div
            className="mb-1 p-1.5 rounded flex items-start relative"
            style={containerStyle}
        >
            {}
            {event.isHighlight && (
                <>
                    <div className="absolute inset-0 rounded pointer-events-none" style={highlightStyle}></div>
                    <div className="absolute inset-0 border-2 rounded pointer-events-none" style={highlightBorderStyle}></div>
                </>
            )}
            {}
            {settings.chat.timestampFormat && (
                <span className="text-xs opacity-80 mr-1.5 shrink-0 pt-px">
                    {new Date(event.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </span>
            )}
            {}
            {settings.chat.showPlatformIcons && PlatformIconComponent && (
                 <PlatformIconComponent
                    title={`${event.platform} Platform`}
                    className="h-[1em] w-auto mr-1.5 shrink-0 inline-block align-middle"
                    fill={platformColor}
                />
            )}
            {}
            <span className="username font-semibold mr-1 shrink-0" style={nameStyle}>
                {event.username}
            </span>
            {}
            {settings.chat.showBadges && (standardBadges.length > 0 || customBadges.length > 0) && (
                <span className="badges ml-0.5 inline-flex items-center space-x-1 shrink-0">
                    {}
                    {standardBadges.map((badge) => {
                        const badgeMeta = standardBadgeComponentMap[badge.identifier];
                        const colorOverride = standardBadgeColorOverrides[badge.identifier];
                        const isModeratorBadge = badge.identifier.includes('/moderator/');
                        const badgeColor = colorOverride ?? (isModeratorBadge ? nameColor : settings.chat.textColor);
                        return badgeMeta ? (
                            <badgeMeta.Component
                                key={badge.identifier}
                                aria-label={badgeMeta.alt}
                                className="h-[1em] w-auto inline-block align-middle"
                                fill={badgeColor}
                            />
                        ) : null;
                    })}
                    {}
                    {customBadges.map((badge) => (
                        <img
                            key={badge.identifier}
                            src={badge.imageUrl ?? ''}
                            alt={badge.identifier.split('/').pop() ?? 'badge'}
                            className="h-[1em] w-auto inline-block align-middle"
                            title={badge.identifier}
                        />
                    ))}
                </span>
            )}
            {}
            {!event.isActionMessage && <span className="separator mr-1 shrink-0">:</span>}
            {}
            <span
                className={`message-content break-words ${event.isActionMessage ? 'italic' : ''}`}
                style={event.isActionMessage ? nameStyle : {}}
            >
                {renderSegments(event.parsedMessage, settings)}
            </span>
        </div>
    );
};
export default DefaultChatMessage;
</file>

<file path="Web/Overlay/src/components/events/DefaultDonationMessage.tsx">
import React from 'react';
import { DonationEvent, OverlaySettings, DonationType } from '../../types';
import { renderSegments } from './renderHelper';
import { isStandardBadge, isCustomBadge, standardBadgeComponentMap, standardBadgeColorOverrides } from './badgeHelper';
interface DefaultDonationMessageProps {
    event: DonationEvent;
    settings: OverlaySettings | null;
}
const DefaultDonationMessage: React.FC<DefaultDonationMessageProps> = ({ event, settings }) => {
    if (!settings) return null;
    const headerStyle: React.CSSProperties = {};
    const bodyStyle: React.CSSProperties = {};
    const nameStyle: React.CSSProperties = {};
    const amountStyle: React.CSSProperties = {};
    const messageStyle: React.CSSProperties = {};
    let eventClass = 'event-donation';
    let accentColor = settings.chat.donationColor;
    let headerTextColor = settings.chat.textColor;
    if (event.type === DonationType.SuperChat || event.type === DonationType.SuperSticker) {
        eventClass += ' donation-superchat';
        if (event.headerBackgroundColor) headerStyle.backgroundColor = event.headerBackgroundColor;
        if (event.headerTextColor) {
            headerTextColor = event.headerTextColor;
            nameStyle.color = headerTextColor;
            amountStyle.color = headerTextColor;
        }
        if (event.bodyBackgroundColor) bodyStyle.backgroundColor = event.bodyBackgroundColor;
        if (event.bodyTextColor) messageStyle.color = event.bodyTextColor;
        accentColor = event.headerBackgroundColor ?? event.bodyBackgroundColor ?? accentColor;
    } else if (event.type === DonationType.Bits) {
        eventClass += ' donation-bits';
        accentColor = '#9146FF';
    } else {
        eventClass += ' donation-streamlabs';
    }
    if (!nameStyle.color) nameStyle.color = headerTextColor;
    if (!amountStyle.color) amountStyle.color = headerTextColor;
    if (!messageStyle.color) messageStyle.color = settings.chat.textColor;
    if (!headerStyle.backgroundColor) headerStyle.backgroundColor = accentColor + 'CC';
    if (!bodyStyle.backgroundColor) bodyStyle.backgroundColor = accentColor + '40';
    const standardBadges = event.badges?.filter(isStandardBadge) ?? [];
    const customBadges = event.badges?.filter(isCustomBadge) ?? [];
    return (
        <div
            className={`${eventClass} platform-${event.platform.toLowerCase()} mb-1 rounded overflow-hidden shadow-sm`}
            style={{ fontSize: `${settings.chat.fontSize}px`, fontFamily: settings.chat.font }}
        >
            {}
            <div
                className="donation-header p-1.5 flex items-center space-x-1.5"
                style={headerStyle}
            >
                {}
                <span className="username font-semibold grow shrink min-w-0 truncate" style={nameStyle}>
                    {event.username}
                </span>
                {}
                {settings.chat.showBadges && (standardBadges.length > 0 || customBadges.length > 0) && (
                    <span className="badges ml-0.5 inline-flex items-center space-x-1 shrink-0">
                        {}
                        {standardBadges.map((badge) => {
                            const badgeMeta = standardBadgeComponentMap[badge.identifier];
                            const colorOverride = standardBadgeColorOverrides[badge.identifier];
                            const isModeratorBadge = badge.identifier.includes('/moderator/');
                            const badgeColor = colorOverride ?? (isModeratorBadge ? headerTextColor : headerTextColor);
                            return badgeMeta ? (
                                <badgeMeta.Component
                                    key={badge.identifier}
                                    aria-label={badgeMeta.alt}
                                    className="h-[1em] w-auto inline-block align-middle"
                                    fill={badgeColor}
                                />
                            ) : null;
                        })}
                        {}
                        {customBadges.map((badge) => (
                            <img
                                key={badge.identifier}
                                src={badge.imageUrl ?? ''}
                                alt={badge.identifier.split('/').pop() ?? 'badge'}
                                className="h-[1em] w-auto inline-block align-middle"
                                title={badge.identifier}
                            />
                        ))}
                    </span>
                )}
                {}
                <span className="donation-amount font-bold shrink-0" style={amountStyle}>
                    {event.formattedAmount ?? `${event.amount} ${event.currency}`}
                </span>
            </div>
            {}
            {(event.parsedMessage?.length > 0 || event.stickerImageUrl) && (
                <div className="donation-body p-1.5" style={bodyStyle}>
                    {event.stickerImageUrl && (
                        <img src={event.stickerImageUrl} alt={event.stickerAltText ?? 'Super Sticker'} className="max-h-[80px] w-auto inline-block my-1"/>
                    )}
                    {event.parsedMessage?.length > 0 && (
                        <span className="message-content block break-words" style={messageStyle}>
                            {renderSegments(event.parsedMessage, settings)}
                        </span>
                    )}
                </div>
            )}
        </div>
    );
};
export default DefaultDonationMessage;
</file>

<file path="Web/Overlay/src/components/events/DefaultFollowMessage.tsx">
import React from 'react';
import { FollowEvent, OverlaySettings } from '../../types';
interface DefaultFollowMessageProps {
    event: FollowEvent;
    settings: OverlaySettings | null;
}
const DefaultFollowMessage: React.FC<DefaultFollowMessageProps> = ({ event, settings }) => {
    if (!settings) return null;
    const accentColor = '#00BCD4';
    const containerStyle: React.CSSProperties = {
        backgroundColor: accentColor + '1A',
        color: settings.chat.textColor,
        borderColor: accentColor,
        fontFamily: settings.chat.font,
        fontSize: `${settings.chat.fontSize}px`,
    };
    return (
        <div
            className={`event-message event-follow platform-${event.platform.toLowerCase()} mb-1 p-1.5 rounded flex items-center border-l-2`}
            style={containerStyle}
        >
            {}
            {settings.chat.timestampFormat && (
                <span className="timestamp text-xs opacity-80 mr-1.5 shrink-0 pt-px">
                    {new Date(event.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </span>
            )}
            {}
            {settings.chat.showPlatformIcons && (
                <span className={`platform-icon platform-icon-${event.platform.toLowerCase()} mr-1.5 text-sm shrink-0 font-semibold`}>
                    {event.platform === 'Twitch' ? 'T' : '?'} {}
                </span>
            )}
            <span className="username font-semibold mr-1">{event.username}</span>
            <span className="message-content">just followed!</span>
        </div>
    );
};
export default DefaultFollowMessage;
</file>

<file path="Web/Overlay/src/components/events/DefaultMembershipMessage.tsx">
import React from 'react';
import { MembershipEvent, OverlaySettings, MembershipEventType } from '../../types';
import { renderSegments } from './renderHelper';
import { isStandardBadge, isCustomBadge, standardBadgeComponentMap, standardBadgeColorOverrides } from './badgeHelper';
import YouTubeIcon from '/src/assets/icons/youtube.svg?react';
interface DefaultMembershipMessageProps {
    event: MembershipEvent;
    settings: OverlaySettings | null;
}
const DefaultMembershipMessage: React.FC<DefaultMembershipMessageProps> = ({ event, settings }) => {
    if (!settings) return null;
    const eventClass = 'event-membership';
    let headerText = event.headerText ?? '';
    const accentColor = event.platform === 'YouTube' ? '#0F9D58' : settings.chat.subColor;
    if (!headerText) {
        switch (event.membershipType) {
            case MembershipEventType.New: headerText = `Welcome member!`; break;
            case MembershipEventType.Milestone: headerText = `${event.milestoneMonths}-Month Milestone!`; break;
            case MembershipEventType.GiftPurchase: headerText = `purchased ${event.giftCount ?? '?'} gift memberships!`; break;
            case MembershipEventType.GiftRedemption: headerText = `received a gift membership!`; break;
        }
    }
    const nameStyle: React.CSSProperties = {};
    let nameColor = settings.chat.textColor;
    if (settings.chat.usePlatformColors && event.usernameColor) {
         nameColor = event.usernameColor;
    }
    nameStyle.color = nameColor;
    const containerStyle: React.CSSProperties = {
        backgroundColor: accentColor + '1A',
        color: settings.chat.textColor,
        borderColor: accentColor,
        fontFamily: settings.chat.font,
        fontSize: `${settings.chat.fontSize}px`,
    };
    const standardBadges = event.badges?.filter(isStandardBadge) ?? [];
    const customBadges = event.badges?.filter(isCustomBadge) ?? [];
    return (
        <div
            className={`${eventClass} platform-${event.platform.toLowerCase()} mb-1 p-1.5 rounded flex items-start relative border-l-2`}
            style={containerStyle}
        >
            {}
            {settings.chat.timestampFormat && (
                <span className="timestamp text-xs opacity-80 mr-1.5 shrink-0 pt-px">
                    {new Date(event.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </span>
            )}
            {}
            {settings.chat.showPlatformIcons && (
                 <YouTubeIcon title="YouTube Platform" className="h-[1em] w-auto mr-1.5 shrink-0 inline-block align-middle" fill="#FF0000" />
            )}
            {}
            <div className="flex-grow">
                {}
                <div className="membership-header flex items-center flex-wrap mb-0.5">
                    {}
                    <span className="username font-semibold mr-1 shrink-0" style={nameStyle}>
                        {event.membershipType === MembershipEventType.GiftPurchase ? event.gifterUsername : event.username}
                    </span>
                     {}
                     {settings.chat.showBadges && (standardBadges.length > 0 || customBadges.length > 0) && (
                        <span className="badges ml-0.5 inline-flex items-center space-x-1 shrink-0">
                            {}
                            {standardBadges.map((badge) => {
                                const badgeMeta = standardBadgeComponentMap[badge.identifier];
                                const colorOverride = standardBadgeColorOverrides[badge.identifier];
                                const isModeratorBadge = badge.identifier.includes('/moderator/');
                                const badgeColor = colorOverride ?? (isModeratorBadge ? nameColor : settings.chat.textColor);
                                return badgeMeta ? (
                                    <badgeMeta.Component key={badge.identifier} aria-label={badgeMeta.alt} className="h-[1em] w-auto inline-block align-middle" fill={badgeColor}/>
                                ) : null;
                            })}
                            {}
                            {customBadges.map((badge) => (
                                <img key={badge.identifier} src={badge.imageUrl ?? ''} alt={badge.identifier.split('/').pop() ?? 'badge'} className="h-[1em] w-auto inline-block align-middle" title={badge.identifier}/>
                            ))}
                        </span>
                    )}
                    {}
                    <span className="membership-info mr-1">{headerText}</span>
                    {}
                    {event.membershipType !== MembershipEventType.GiftPurchase && event.levelName && (
                        <span className="membership-level text-xs opacity-90">({event.levelName})</span>
                    )}
                </div>
                {}
                {event.membershipType === MembershipEventType.Milestone && event.parsedMessage?.length > 0 && (
                    <div className="membership-body mt-1 pl-2 border-l-2 border-gray-500/50">
                        <span className="message-content break-words">
                            {renderSegments(event.parsedMessage, settings)}
                        </span>
                    </div>
                )}
            </div>
        </div>
    );
};
export default DefaultMembershipMessage;
</file>

<file path="Web/Overlay/src/components/events/DefaultRaidMessage.tsx">
import React from 'react';
import { RaidEvent, OverlaySettings } from '../../types';
interface DefaultRaidMessageProps {
    event: RaidEvent;
    settings: OverlaySettings | null;
}
const DefaultRaidMessage: React.FC<DefaultRaidMessageProps> = ({ event, settings }) => {
    if (!settings) return null;
    const accentColor = '#FFC107';
     const containerStyle: React.CSSProperties = {
        backgroundColor: accentColor + '1A',
        color: settings.chat.textColor,
        borderColor: accentColor,
        fontFamily: settings.chat.font,
        fontSize: `${settings.chat.fontSize}px`,
    };
    return (
        <div
            className={`event-message event-raid platform-${event.platform.toLowerCase()} mb-1 p-1.5 rounded flex items-center border-l-2`}
            style={containerStyle}
        >
             {}
            {settings.chat.timestampFormat && (
                <span className="timestamp text-xs opacity-80 mr-1.5 shrink-0 pt-px">
                    {new Date(event.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </span>
            )}
            {}
            {settings.chat.showPlatformIcons && (
                <span className={`platform-icon platform-icon-${event.platform.toLowerCase()} mr-1.5 text-sm shrink-0 font-semibold`}>
                    {event.platform === 'Twitch' ? 'T' : '?'} {}
                </span>
            )}
            <span className="username font-semibold mr-1">{event.raiderUsername}</span>
            <span className="message-content">is raiding with <span className="font-semibold">{event.viewerCount}</span> viewers!</span>
        </div>
    );
};
export default DefaultRaidMessage;
</file>

<file path="Web/Overlay/src/components/events/DefaultSubscriptionMessage.tsx">
import React from 'react';
import { SubscriptionEvent, OverlaySettings } from '../../types';
import { renderSegments } from './renderHelper';
import { isStandardBadge, isCustomBadge, standardBadgeComponentMap, standardBadgeColorOverrides } from './badgeHelper';
import TwitchIcon from '/src/assets/icons/twitch.svg?react';
interface DefaultSubscriptionMessageProps {
    event: SubscriptionEvent;
    settings: OverlaySettings | null;
}
const DefaultSubscriptionMessage: React.FC<DefaultSubscriptionMessageProps> = ({ event, settings }) => {
    if (!settings) return null;
    let messageIntro = '';
    let messageDetails = '';
    const userMessage = event.message ?? '';
    if (event.isGift) {
        messageIntro = ` gifted a ${event.tier} sub`;
        if (event.recipientUsername) {
            messageIntro += ` to ${event.recipientUsername}`;
        }
        if (event.months > 1) {
            messageIntro += ` (${event.months} months)`;
        }
        messageIntro += '!';
        if (event.totalGiftCount > 0 && event.totalGiftCount !== event.giftCount) {
             messageDetails = ` (Total Gifts: ${event.totalGiftCount})`;
        }
    } else {
        messageIntro = ` subscribed with ${event.tier}`;
        if (event.cumulativeMonths > 1) {
            messageIntro += ` for ${event.cumulativeMonths} months!`;
        } else {
            messageIntro += '!';
        }
    }
    const nameStyle: React.CSSProperties = {};
    let nameColor = settings.chat.textColor; // Default color
    if (settings.chat.usePlatformColors && event.usernameColor) {
        nameColor = event.usernameColor;
    }
    nameStyle.color = nameColor;
    const accentColor = settings.chat.subColor;
    const containerStyle: React.CSSProperties = {
        backgroundColor: accentColor + '1A',
        color: settings.chat.textColor,
        borderColor: accentColor,
        fontFamily: settings.chat.font,
        fontSize: `${settings.chat.fontSize}px`,
    };
    const standardBadges = event.badges?.filter(isStandardBadge) ?? [];
    const customBadges = event.badges?.filter(isCustomBadge) ?? [];
    return (
        <div
            className={`event-message event-subscription platform-${event.platform.toLowerCase()} mb-1 p-1.5 rounded flex items-start relative border-l-2`}
            style={containerStyle}
        >
            {}
            {settings.chat.timestampFormat && (
                <span className="timestamp text-xs opacity-80 mr-1.5 shrink-0 pt-px">
                    {new Date(event.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </span>
            )}
            {}
            {settings.chat.showPlatformIcons && (
                 <TwitchIcon title="Twitch Platform" className="h-[1em] w-auto mr-1.5 shrink-0 inline-block align-middle" fill="#9146FF" />
            )}
            {}
            <div className="flex-grow">
                 {}
                 <div className="subscription-header flex items-center flex-wrap mb-0.5">
                    {}
                    <span className="username font-semibold mr-1 shrink-0" style={nameStyle}>
                        {event.username}
                    </span>
                     {}
                     {settings.chat.showBadges && (standardBadges.length > 0 || customBadges.length > 0) && (
                        <span className="badges ml-0.5 inline-flex items-center space-x-1 shrink-0">
                            {}
                            {standardBadges.map((badge) => {
                                const badgeMeta = standardBadgeComponentMap[badge.identifier];
                                const colorOverride = standardBadgeColorOverrides[badge.identifier];
                                const isModeratorBadge = badge.identifier.includes('/moderator/');
                                const badgeColor = colorOverride ?? (isModeratorBadge ? nameColor : settings.chat.textColor);
                                return badgeMeta ? (
                                    <badgeMeta.Component key={badge.identifier} aria-label={badgeMeta.alt} className="h-[1em] w-auto inline-block align-middle" fill={badgeColor}/>
                                ) : null;
                            })}
                            {}
                            {customBadges.map((badge) => (
                                <img key={badge.identifier} src={badge.imageUrl ?? ''} alt={badge.identifier.split('/').pop() ?? 'badge'} className="h-[1em] w-auto inline-block align-middle" title={badge.identifier}/>
                            ))}
                        </span>
                    )}
                    {}
                    <span className="subscription-info mr-1">{messageIntro}</span>
                    {}
                    {messageDetails && <span className="subscription-details text-xs opacity-90">{messageDetails}</span>}
                </div>
                {}
                {userMessage && !event.isGift && (
                    <div className="subscription-body mt-1 pl-2 border-l-2 border-gray-500/50">
                        <span className="message-content italic break-words">
                             {renderSegments([{ text: `"${userMessage}"` }], settings)}
                        </span>
                    </div>
                )}
            </div>
        </div>
    );
};
export default DefaultSubscriptionMessage;
</file>

<file path="Web/Overlay/src/components/events/DefaultSystemMessage.tsx">
import React from 'react';
import { SystemMessageEvent, OverlaySettings, SystemMessageLevel } from '../../types';
interface DefaultSystemMessageProps {
    event: SystemMessageEvent;
    settings: OverlaySettings | null;
}
const DefaultSystemMessage: React.FC<DefaultSystemMessageProps> = ({ event, settings }) => {
    if (!settings) return null;
    let levelClass = 'border-blue-500 bg-blue-500/10';
    let iconGlyph = 'ℹ️';
    switch (event.level) {
        case SystemMessageLevel.Warning:
            levelClass = 'border-yellow-500 bg-yellow-500/10';
            iconGlyph = '⚠️';
            break;
        case SystemMessageLevel.Error:
            levelClass = 'border-red-600 bg-red-600/10';
            iconGlyph = '❌';
            break;
    }
     const containerStyle: React.CSSProperties = {
        color: settings.chat.textColor,
        fontFamily: settings.chat.font,
        fontSize: `${settings.chat.fontSize}px`,
    };
    return (
        <div
            className={`event-message event-system ${levelClass} mb-1 p-1.5 rounded flex items-center border-l-2 italic text-sm`}
            style={containerStyle}
        >
             {}
            {settings.chat.timestampFormat && (
                <span className="timestamp text-xs opacity-80 mr-1.5 shrink-0 pt-px">
                    {new Date(event.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </span>
            )}
            {}
            <span className="mr-1.5">{iconGlyph}</span>
            {}
            <span className="message-content">{event.message}</span>
        </div>
    );
};
export default DefaultSystemMessage;
</file>

<file path="Web/Overlay/src/components/events/renderHelper.tsx">
import React from 'react';
import { MessageSegment, TextSegment, EmoteSegment, OverlaySettings } from '../../types';
export const renderSegments = (segments: MessageSegment[], settings: OverlaySettings | null): React.ReactNode => {
    if (!segments || segments.length === 0 || !settings) {
        return null;
    }
    const fontSize = Number(settings.chat.fontSize) || 14;
    const emoteHeight = fontSize * 1.5;
    return segments.map((segment, index) => {
        if ('text' in segment) {
            const textSegment = segment as TextSegment;
            return <React.Fragment key={index}>{textSegment.text.replace(/ {2,}/g, ' ')}</React.Fragment>;
        }
        else if ('imageUrl' in segment && settings.chat.showEmotes) {
            const emoteSegment = segment as EmoteSegment;
            return (
                <img
                    key={index}
                    src={emoteSegment.imageUrl}
                    alt={emoteSegment.name}
                    className="inline-block align-middle mx-px"
                    title={emoteSegment.name}
                    style={{ height: `${emoteHeight}px` }}
                />
            );
        }
        return null;
    });
};
</file>

<file path="Web/Overlay/src/index.css">
@import "tailwindcss";
html,
body,
#root {
  height: 100%;
  margin: 0;
  padding: 0;
}
body {
  background-color: transparent;
  overflow: hidden;
}
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  color-scheme: light dark;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
.chat-item {
  will-change: transform, opacity;
}
</file>

<file path="Web/Overlay/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'
createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="Web/Overlay/src/store.ts">
import { create } from 'zustand';
import {
    OverlaySettings,
    WebPluginManifest,
    BaseEvent,
    DisplayedItem,
    ConnectionStatus,
    InitPayload,
} from './types';
interface AppState {
    settings: OverlaySettings | null;
    plugins: WebPluginManifest[];
    displayedItems: DisplayedItem[];
    isConnected: boolean;
    connectionStatus: ConnectionStatus;
}
interface AppActions {
    setSettings: (settings: OverlaySettings) => void;
    setPlugins: (plugins: WebPluginManifest[]) => void;
    addEvent: (event: BaseEvent) => void;
    removeItemByKey: (key: string) => void;
    setConnectionStatus: (status: ConnectionStatus) => void;
    initialize: (payload: InitPayload) => void;
    resetDisplayedItems: () => void;
}
export const useStore = create<AppState & AppActions>((set, get) => ({
    settings: null,
    plugins: [],
    displayedItems: [],
    isConnected: false,
    connectionStatus: 'disconnected',
    setSettings: (newSettings) => {
        console.log('[Store] Updating settings:', Object.keys(newSettings || {}));
        set({ settings: newSettings });
        const currentItems = get().displayedItems;
        const maxMessages = newSettings?.chat?.maxMessages ?? 10;
        if (currentItems.length > maxMessages) {
            console.log(`[Store] Applying new maxMessages (${maxMessages}) due to settings update.`);
            set({ displayedItems: currentItems.slice(-maxMessages) });
        }
    },
    setPlugins: (plugins) => {
        console.log('[Store] Updating plugins:', plugins.map(p => p.id));
        set({ plugins });
    },
    addEvent: (event) => {
        const settings = get().settings;
        if (!settings) {
            console.warn(`[Store] Received event ${event.id} before settings initialized. Ignoring.`);
            return;
        }
        const { maxMessages } = settings.chat;
        const newItem: DisplayedItem = { event, key: event.id };
        console.log(`[Store] Adding event ${newItem.key}. Max: ${maxMessages}`);
        set((state) => {
            const itemsWithNew = [...state.displayedItems, newItem];
            const requiresSlice = itemsWithNew.length > maxMessages;
            const finalNextItems = requiresSlice
                ? itemsWithNew.slice(-maxMessages)
                : itemsWithNew;
            if (requiresSlice) {
                 const finalKeys = new Set(finalNextItems.map(item => item.key));
                 const removedItems = state.displayedItems.filter(item => !finalKeys.has(item.key));
                 if (removedItems.length > 0) {
                    console.log(`[Store] Sliced off ${removedItems.length} old items due to limit:`, removedItems.map(i => i.key).join(', '));
                 }
                 if (!finalKeys.has(newItem.key)) {
                     console.log(`[Store] New item ${newItem.key} was immediately sliced off.`);
                 }
            }
             console.log(`[Store] Updated displayedItems. Count: ${finalNextItems.length}`);
            return { displayedItems: finalNextItems };
        });
    },
    removeItemByKey: (key) => {
        console.log(`[Store] Removing item by key (likely timeout): ${key}`);
        set((state) => ({
            displayedItems: state.displayedItems.filter((item) => item.key !== key),
        }));
    },
    setConnectionStatus: (status) => {
        console.log(`[Store] Updating connection status: ${status}`);
        set({ connectionStatus: status, isConnected: status === 'connected' });
         if (status === 'connecting' || status === 'disconnected' || status === 'error') {
         }
    },
    initialize: (payload) => {
        console.log('[Store] Initializing state from payload.');
        set({
            settings: payload.settings,
            plugins: payload.plugins,
            displayedItems: [],
            isConnected: get().connectionStatus === 'connected',
        });
    },
    resetDisplayedItems: () => {
        console.log('[Store] Resetting displayed items.');
        set({ displayedItems: [] });
    },
}));
</file>

<file path="Web/Overlay/src/types.ts">
export interface ChatOverlaySettings {
    maxMessages: number;
    font: string;
    fontSize: number;
    textColor: string;
    backgroundColor: string;
    showBadges: boolean;
    showPlatformIcons: boolean;
    showEmotes: boolean;
    fadeMessages: boolean;
    fadeDelaySeconds: number;
    usePlatformColors: boolean;
    timestampFormat: string;
    highlightColor: string;
    subColor: string;
    donationColor: string;
}
export interface OverlaySettings {
    webServerPort: number;
    chat: ChatOverlaySettings;
}
export interface WebComponentRegistration {
    tagName: string;
    scriptPath: string;
}
export interface WebPluginManifest {
    id: string;
    name: string;
    version: string;
    author: string;
    description?: string;
    entryScript: string;
    entryStyle?: string;
    providesComponents?: string[];
    registersWebComponents?: WebComponentRegistration[];
    basePath: string;
}
export interface BaseEvent {
    $type: string;
    id: string;
    timestamp: string;
    platform: string;
    originatingAccountId?: string | null;
}
export interface BadgeInfo {
    identifier: string;
    imageUrl?: string | null;
}
export interface MessageSegment {
}
export interface TextSegment extends MessageSegment {
    text: string;
}
export interface EmoteSegment extends MessageSegment {
    name: string;
    imageUrl: string;
    id: string;
    platform: string;
}
export interface ChatMessageEvent extends BaseEvent {
    username: string;
    rawMessage?: string | null;
    parsedMessage: MessageSegment[];
    userId?: string | null;
    usernameColor?: string | null;
    badges: BadgeInfo[];
    profileImageUrl?: string | null;
    isOwner: boolean;
    isActionMessage: boolean;
    isHighlight: boolean;
    bitsDonated: number;
}
export enum DonationType {
    Streamlabs = 0,
    SuperChat = 1,
    Bits = 2,
    SuperSticker = 3,
    Other = 4,
}
export interface DonationEvent extends BaseEvent {
    username: string;
    userId?: string | null;
    usernameColor?: string | null;
    badges: BadgeInfo[];
    amount: number;
    currency: string;
    rawMessage: string;
    parsedMessage: MessageSegment[];
    profileImageUrl?: string | null;
    isOwner: boolean;
    type: DonationType;
    donationId?: string | null;
    bodyBackgroundColor?: string | null;
    headerBackgroundColor?: string | null;
    headerTextColor?: string | null;
    bodyTextColor?: string | null;
    authorNameTextColor?: string | null;
    stickerImageUrl?: string | null;
    stickerAltText?: string | null;
    formattedAmount?: string;
}
export enum MembershipEventType {
    Unknown = 0,
    New = 1,
    Milestone = 2,
    GiftPurchase = 3,
    GiftRedemption = 4,
}
export interface MembershipEvent extends BaseEvent {
    username: string;
    userId?: string | null;
    usernameColor?: string | null;
    badges: BadgeInfo[];
    profileImageUrl?: string | null;
    isOwner: boolean;
    membershipType: MembershipEventType;
    levelName?: string | null;
    milestoneMonths?: number | null;
    gifterUsername?: string | null;
    giftCount?: number | null;
    headerText?: string | null;
    parsedMessage: MessageSegment[];
}
export interface SubscriptionEvent extends BaseEvent {
    username: string;
    userId?: string | null;
    usernameColor?: string | null;
    badges: BadgeInfo[];
    profileImageUrl?: string | null;
    isOwner: boolean;
    isGift: boolean;
    recipientUsername?: string | null;
    recipientUserId?: string | null;
    months: number;
    cumulativeMonths: number;
    giftCount: number;
    totalGiftCount: number;
    tier: string;
    message?: string | null;
}
export interface FollowEvent extends BaseEvent {
    username: string;
    userId?: string | null;
}
export interface RaidEvent extends BaseEvent {
    raiderUsername: string;
    raiderUserId?: string | null;
    viewerCount: number;
}
export interface HostEvent extends BaseEvent {
    isHosting: boolean;
    hosterUsername?: string | null;
    hostedChannel?: string | null;
    viewerCount: number;
    isAutoHost: boolean;
}
export enum SystemMessageLevel {
    Info = 0,
    Warning = 1,
    Error = 2,
}
export interface SystemMessageEvent extends BaseEvent {
    message: string;
    level: SystemMessageLevel;
}
export interface PollOption {
    text: string;
    votePercentage?: string | null;
    voteCount?: number | null;
}
export interface YouTubePollUpdateEvent extends BaseEvent {
    pollId: string;
    question: string;
    options: PollOption[];
    isActive: boolean;
}
export interface BotMessageEvent extends BaseEvent {
    senderDisplayName: string;
    senderAccountId: string;
    message: string;
    target: string;
    parsedMessage: MessageSegment[];
}
export interface CommandInvocationEvent extends BaseEvent {
    originalCommandMessage: ChatMessageEvent;
    replyMessage?: string | null;
    botSenderDisplayName: string;
}
export interface InitPayload {
    settings: OverlaySettings;
    plugins: WebPluginManifest[];
}
export type WebSocketPayload =
    | InitPayload
    | OverlaySettings
    | ChatMessageEvent
    | DonationEvent
    | MembershipEvent
    | SubscriptionEvent
    | FollowEvent
    | RaidEvent
    | HostEvent
    | SystemMessageEvent
    | YouTubePollUpdateEvent
    | BotMessageEvent
    | CommandInvocationEvent;
export interface WebSocketMessage {
    type: 'init' | 'settings' | 'event';
    payload: WebSocketPayload;
}
export interface DisplayedItem {
    event: BaseEvent;
    key: string;
}
export type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error';
export type OverlayComponentProps = { event: BaseEvent; settings: OverlaySettings };
export type OverlayComponentType = React.ComponentType<OverlayComponentProps>;
declare global {
    interface Window {
        StreamWeaverOverlay: {
            plugins: {
                registry: {
                    componentOverrides: Record<string, OverlayComponentType>;
                };
                registerComponentOverride: (
                    componentKey: string,
                    component: OverlayComponentType
                ) => void;
            };
        };
    }
}
</file>

<file path="Web/Overlay/src/utils/connectWebSocket.ts">
import { WebSocketMessage } from '../types';
interface WebSocketCallbacks {
    onOpen?: (event: Event) => void;
    onMessage?: (data: WebSocketMessage) => void;
    onClose?: (event: CloseEvent) => void;
    onError?: (error: Event) => void;
}
interface WebSocketConnection {
    close: () => void;
}
const initialReconnectDelay = 1000;
const maxReconnectDelay = 30000;
export function connectWebSocket(
    url: string,
    callbacks: WebSocketCallbacks
): WebSocketConnection {
    let socket: WebSocket | null = null;
    let reconnectTimeoutId: ReturnType<typeof setTimeout> | null = null;
    let currentReconnectDelay = initialReconnectDelay;
    let explicitlyClosed = false;
    const connect = () => {
        if (explicitlyClosed) {
            console.log("WebSocket: Connection explicitly closed, not reconnecting.");
            return;
        }
        console.log(`WebSocket: Attempting to connect to ${url}...`);
        socket = new WebSocket(url);
        socket.onopen = (event) => {
            console.log("WebSocket: Connected!");
            explicitlyClosed = false;
            currentReconnectDelay = initialReconnectDelay;
            if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
            reconnectTimeoutId = null;
            callbacks.onOpen?.(event);
        };
        socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data) as WebSocketMessage;
                if (data && data.type && data.payload !== undefined) {
                     callbacks.onMessage?.(data);
                } else {
                    console.warn("WebSocket: Received invalid message format:", event.data);
                }
            } catch (e) {
                console.error("WebSocket: Failed to parse message:", e, event.data);
                callbacks.onError?.(new ErrorEvent("messageparseerror", { message: "Failed to parse message" }));
            }
        };
        socket.onclose = (event) => {
            console.log(`WebSocket: Closed. Code: ${event.code}, Reason: ${event.reason}, Clean: ${event.wasClean}`);
            socket = null;
            callbacks.onClose?.(event);
            if (!explicitlyClosed && event.code !== 1000) {
                console.log(`WebSocket: Attempting reconnect in ${currentReconnectDelay / 1000}s...`);
                if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
                reconnectTimeoutId = setTimeout(() => {
                    connect();
                    currentReconnectDelay = Math.min(currentReconnectDelay * 2, maxReconnectDelay);
                }, currentReconnectDelay);
            } else if (explicitlyClosed) {
                console.log("WebSocket: Connection closed explicitly.");
            }
        };
        socket.onerror = (error) => {
            console.error("WebSocket: Error:", error);
            callbacks.onError?.(error);
        };
    };
    const closeConnection = () => {
        console.log("WebSocket: Closing connection explicitly.");
        explicitlyClosed = true;
        if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
        reconnectTimeoutId = null;
        socket?.close(1000, "Client closed connection");
        socket = null;
    };
    connect();
    return { close: closeConnection };
}
</file>

<file path="Web/Overlay/src/vite-env.d.ts">

</file>

<file path="Web/Overlay/src/webSocketService.ts">
import { webSocket, WebSocketSubject, WebSocketSubjectConfig } from 'rxjs/webSocket';
import { retry, tap, catchError, map, shareReplay, Subject, BehaviorSubject, timer, EMPTY } from 'rxjs';
import { WebSocketMessage, ConnectionStatus } from './types';
const DEFAULT_WEBSOCKET_PORT = 5080;
const INITIAL_RECONNECT_DELAY = 1000;
const MAX_RECONNECT_DELAY = 30000;
const MAX_RETRY_ATTEMPTS = 100;
class WebSocketService {
    private socket$?: WebSocketSubject<string>;
    private connectionStatusSubject = new BehaviorSubject<ConnectionStatus>('disconnected');
    private messageSubject = new Subject<WebSocketMessage>();
    private wsUrl: string = '';
    private explicitClose = false;
    public connectionStatus$ = this.connectionStatusSubject.asObservable().pipe(
        shareReplay(1) // Share the last emitted status
    );
    public message$ = this.messageSubject.asObservable(); // External consumers subscribe here
    private getWebSocketUrl(): string {
        const queryParams = new URLSearchParams(window.location.search);
        const wsPort = queryParams.get('port') || DEFAULT_WEBSOCKET_PORT;
        return `ws://localhost:${wsPort}/ws`;
    }
    connect() {
        this.wsUrl = this.getWebSocketUrl();
        console.log(`[WebSocketService] Initiating connection to ${this.wsUrl}`);
        this.explicitClose = false;
        this.connectionStatusSubject.next('connecting');
        this.connectAndSubscribe();
    }
    private connectAndSubscribe() {
        if (this.explicitClose || !this.wsUrl) {
            console.log("[WebSocketService] Connection attempt aborted (explicit close or no URL).");
            this.connectionStatusSubject.next('disconnected');
            return;
        }
        const wsConfig: WebSocketSubjectConfig<string> = {
            url: this.wsUrl,
            openObserver: {
                next: () => {
                    console.log('[WebSocketService] Connection Opened.');
                    this.connectionStatusSubject.next('connected');
                }
            },
            closeObserver: {
                next: (closeEvent) => {
                    console.log(`[WebSocketService] Connection Closed (Code: ${closeEvent.code}, Reason: ${closeEvent.reason}, Explicit: ${this.explicitClose})`);
                    if (this.explicitClose || closeEvent.code === 1000) {
                        this.connectionStatusSubject.next('disconnected');
                    } else {
                        console.log("[WebSocketService] Non-explicit closure, retry logic will handle reconnect attempt.");
                    }
                }
            },
            deserializer: (e: MessageEvent): string => {
                if (typeof e.data === 'string') {
                    return e.data;
                }
                console.warn("[WebSocketService] Received non-string message data:", e.data);
                return "";
            },
            // If you were SENDING messages, you'd use a serializer here:
            // serializer: (value: any) => JSON.stringify(value),
        };
        this.socket$ = webSocket(wsConfig);
        this.socket$.pipe(
            // Filter out empty strings that might come from the deserializer error handling
            map(data => data.trim()), // Trim whitespace just in case
            map(data => data ? this.parseAndValidateMessage(data) : null), // Parse non-empty strings
            tap(message => {
                if (message) { // Only emit valid, non-null messages
                    this.messageSubject.next(message);
                }
            }),
            retry({
                count: MAX_RETRY_ATTEMPTS,
                delay: (error, retryCount) => {
                    const delayMs = Math.min(INITIAL_RECONNECT_DELAY * Math.pow(2, retryCount - 1), MAX_RECONNECT_DELAY);
                    console.warn(`[WebSocketService] Connection error/closed unexpectedly. Retry ${retryCount}/${MAX_RETRY_ATTEMPTS} in ${delayMs}ms...`, error);
                    this.connectionStatusSubject.next('connecting'); // Signal reconnect attempt
                    return timer(delayMs);
                },
                resetOnSuccess: true // Reset retry count on successful reconnect
            }),
            catchError(error => {
                // This block is reached if retries are exhausted or if retry condition is false
                console.error('[WebSocketService] Unrecoverable WebSocket error or retries exhausted:', error);
                this.connectionStatusSubject.next('error');
                this.socket$ = undefined; // Ensure socket is cleaned up
                return EMPTY; // Stop the stream cleanly
            })
        ).subscribe({
            // We only care about errors/completion here, messages handled by tap
            error: (err) => {
                // Should ideally be handled by catchError, but good for safety
                console.error("[WebSocketService] Final subscription error handler:", err);
                if (this.connectionStatusSubject.value !== 'error' && this.connectionStatusSubject.value !== 'disconnected') {
                    this.connectionStatusSubject.next('error');
                }
            },
            complete: () => {
                 // This is called when the observable completes (e.g., via EMPTY in catchError or explicit close)
                console.log("[WebSocketService] WebSocket observable stream completed.");
                 if (this.connectionStatusSubject.value !== 'disconnected' && this.connectionStatusSubject.value !== 'error') {
                     // If not already in a terminal state, mark as disconnected
                     this.connectionStatusSubject.next('disconnected');
                 }
                 this.socket$ = undefined;
            }
        });
    }
    // Parameter 'data' is now guaranteed to be a non-empty string by the pipeline
    private parseAndValidateMessage(data: string): WebSocketMessage | null {
        try {
            const parsed: unknown = JSON.parse(data); // Parse as unknown first
            // Perform runtime validation
            if (
                parsed &&
                typeof parsed === 'object' &&
                'type' in parsed && typeof parsed.type === 'string' &&
                'payload' in parsed && parsed.payload !== undefined // Keep payload check basic
            ) {
                // console.log("[WebSocketService] Parsed message:", parsed.type); // Debug log
                // Cast to WebSocketMessage after successful validation
                return parsed as WebSocketMessage;
            } else {
                console.warn("[WebSocketService] Received invalid message format after parse:", parsed);
                return null;
            }
        } catch (e) {
            console.error("[WebSocketService] Failed to parse JSON message:", e, data);
            return null;
        }
    }
    close() {
        if (this.socket$) {
            console.log('[WebSocketService] Closing connection explicitly.');
            this.explicitClose = true;
            this.socket$.complete();
            this.socket$ = undefined;
        } else {
             console.log('[WebSocketService] Close called but no active connection.');
             if (this.connectionStatusSubject.value !== 'disconnected') {
                 this.connectionStatusSubject.next('disconnected');
             }
        }
    }
}
export const webSocketService = new WebSocketService();
</file>

<file path="Web/Overlay/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="Web/Overlay/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="Web/Overlay/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="Web/Overlay/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'
import svgr from 'vite-plugin-svgr'
export default defineConfig({
  build: {
    outDir: 'dist',
    emptyOutDir: true,
  },
  plugins: [
    react(),
    tailwindcss(),
    svgr({
        svgrOptions: {
            icon: true,
        },
    }),
  ],
})
</file>

<file path=".cspell.json">
{
    "ignorePaths": [
        "**/node_modules/**",
        "**/vscode-extension/**",
        "**/.git/**",
        "**/.pnpm-lock.json",
        ".vscode",
        "megalinter",
        "package-lock.json",
        "report"
    ],
    "language": "en",
    "noConfigSearch": true,
    "words": ["megalinter", "oxsecurity"],
    "version": "0.2"
}
</file>

<file path=".editorconfig">
# editorconfig.org

# top-most EditorConfig file
root = true

# Default settings:
# A newline ending every file
# Use 4 spaces as indentation
[*]
insert_final_newline = true
indent_style = space
indent_size = 4
max_line_length = 150
trim_trailing_whitespace = true

# Generated code
[*{_AssemblyInfo.cs,.notsupported.cs,AsmOffsets.cs}]
generated_code = true
dotnet_style_coalesce_expression = true:suggestion
dotnet_style_null_propagation = true:suggestion
dotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion
dotnet_style_operator_placement_when_wrapping = beginning_of_line
tab_width = 4
end_of_line = crlf
dotnet_style_prefer_auto_properties = true:suggestion
dotnet_style_object_initializer = true:suggestion
dotnet_style_collection_initializer = true:suggestion
dotnet_style_prefer_simplified_boolean_expressions = true:suggestion
dotnet_style_prefer_conditional_expression_over_assignment = true:silent
dotnet_style_prefer_conditional_expression_over_return = true:silent
dotnet_style_explicit_tuple_names = true:suggestion
dotnet_style_prefer_inferred_tuple_names = true:suggestion
dotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion
dotnet_style_prefer_compound_assignment = true:suggestion
dotnet_style_prefer_simplified_interpolation = true:suggestion
dotnet_style_prefer_collection_expression = when_types_exactly_match:suggestion
dotnet_style_namespace_match_folder = true:suggestion
dotnet_style_readonly_field = true:suggestion
dotnet_style_predefined_type_for_locals_parameters_members = true:suggestion
dotnet_style_predefined_type_for_member_access = true:suggestion
dotnet_style_require_accessibility_modifiers = for_non_interface_members:silent
dotnet_style_allow_multiple_blank_lines_experimental = true:silent
dotnet_style_allow_statement_immediately_after_block_experimental = false:silent
dotnet_code_quality_unused_parameters = all:suggestion
dotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity:silent
dotnet_style_parentheses_in_other_binary_operators = always_for_clarity:silent
dotnet_style_parentheses_in_relational_binary_operators = always_for_clarity:silent
dotnet_style_parentheses_in_other_operators = never_if_unnecessary:silent
dotnet_style_qualification_for_field = false:suggestion
dotnet_style_qualification_for_property = false:suggestion
dotnet_style_qualification_for_method = false:suggestion
dotnet_style_qualification_for_event = false:suggestion

# C# files
[*.cs]
# New line preferences
csharp_new_line_before_open_brace = all
csharp_new_line_before_else = true
csharp_new_line_before_catch = true
csharp_new_line_before_finally = true
csharp_new_line_before_members_in_object_initializers = true
csharp_new_line_before_members_in_anonymous_types = true
csharp_new_line_between_query_expression_clauses = true

# Indentation preferences
csharp_indent_block_contents = true
csharp_indent_braces = false
csharp_indent_case_contents = true
csharp_indent_case_contents_when_block = false
csharp_indent_switch_labels = true
csharp_indent_labels = one_less_than_current

# Modifier preferences
csharp_preferred_modifier_order = public,private,protected,internal,file,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,required,volatile,async:suggestion

# avoid this. unless absolutely necessary
dotnet_style_qualification_for_field = false:suggestion
dotnet_style_qualification_for_property = false:suggestion
dotnet_style_qualification_for_method = false:suggestion
dotnet_style_qualification_for_event = false:suggestion

# Types: use keywords instead of BCL types, and permit var only when the type is clear
csharp_style_var_for_built_in_types = false:suggestion
csharp_style_var_when_type_is_apparent = false:none
csharp_style_var_elsewhere = false:suggestion
dotnet_style_predefined_type_for_locals_parameters_members = true:suggestion
dotnet_style_predefined_type_for_member_access = true:suggestion

# name all constant fields using PascalCase
dotnet_naming_rule.constant_fields_should_be_pascal_case.severity = suggestion
dotnet_naming_rule.constant_fields_should_be_pascal_case.symbols  = constant_fields
dotnet_naming_rule.constant_fields_should_be_pascal_case.style = pascal_case_style
dotnet_naming_symbols.constant_fields.applicable_kinds   = field
dotnet_naming_symbols.constant_fields.required_modifiers = const
dotnet_naming_style.pascal_case_style.capitalization = pascal_case

# static fields should have s_ prefix
dotnet_naming_rule.static_fields_should_have_prefix.severity = suggestion
dotnet_naming_rule.static_fields_should_have_prefix.symbols  = static_fields
dotnet_naming_rule.static_fields_should_have_prefix.style = static_prefix_style
dotnet_naming_symbols.static_fields.applicable_kinds   = field
dotnet_naming_symbols.static_fields.required_modifiers = static
dotnet_naming_symbols.static_fields.applicable_accessibilities = private, internal, private_protected
dotnet_naming_style.static_prefix_style.required_prefix = s_
dotnet_naming_style.static_prefix_style.capitalization = camel_case

# internal and private fields should be _camelCase
dotnet_naming_rule.camel_case_for_private_internal_fields.severity = suggestion
dotnet_naming_rule.camel_case_for_private_internal_fields.symbols  = private_internal_fields
dotnet_naming_rule.camel_case_for_private_internal_fields.style = camel_case_underscore_style
dotnet_naming_symbols.private_internal_fields.applicable_kinds = field
dotnet_naming_symbols.private_internal_fields.applicable_accessibilities = private, internal
dotnet_naming_style.camel_case_underscore_style.required_prefix = _
dotnet_naming_style.camel_case_underscore_style.capitalization = camel_case

# Code style defaults
csharp_using_directive_placement = outside_namespace:suggestion
dotnet_sort_system_directives_first = true
csharp_prefer_braces = when_multiline:silent
csharp_preserve_single_line_blocks = true:none
csharp_preserve_single_line_statements = false:none
csharp_prefer_static_local_function = true:suggestion
csharp_prefer_simple_using_statement = true:none
csharp_style_prefer_switch_expression = true:suggestion
dotnet_style_readonly_field = true:suggestion

# Expression-level preferences
dotnet_style_object_initializer = true:suggestion
dotnet_style_collection_initializer = true:suggestion
dotnet_style_prefer_collection_expression = when_types_exactly_match
dotnet_style_explicit_tuple_names = true:suggestion
dotnet_style_coalesce_expression = true:suggestion
dotnet_style_null_propagation = true:suggestion
dotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion
dotnet_style_prefer_inferred_tuple_names = true:suggestion
dotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion
dotnet_style_prefer_auto_properties = true:suggestion
dotnet_style_prefer_conditional_expression_over_assignment = true:silent
dotnet_style_prefer_conditional_expression_over_return = true:silent
csharp_prefer_simple_default_expression = true:suggestion

# Expression-bodied members
csharp_style_expression_bodied_methods = true:silent
csharp_style_expression_bodied_constructors = true:silent
csharp_style_expression_bodied_operators = true:silent
csharp_style_expression_bodied_properties = true:silent
csharp_style_expression_bodied_indexers = true:silent
csharp_style_expression_bodied_accessors = true:silent
csharp_style_expression_bodied_lambdas = true:silent
csharp_style_expression_bodied_local_functions = true:silent

# Pattern matching
csharp_style_pattern_matching_over_is_with_cast_check = true:suggestion
csharp_style_pattern_matching_over_as_with_null_check = true:suggestion
csharp_style_inlined_variable_declaration = true:suggestion

# Null checking preferences
csharp_style_throw_expression = true:suggestion
csharp_style_conditional_delegate_call = true:suggestion

# Other features
csharp_style_prefer_index_operator = false:none
csharp_style_prefer_range_operator = true:none
csharp_style_pattern_local_over_anonymous_function = false:none

# Space preferences
csharp_space_after_cast = false
csharp_space_after_colon_in_inheritance_clause = true
csharp_space_after_comma = true
csharp_space_after_dot = false
csharp_space_after_keywords_in_control_flow_statements = true
csharp_space_after_semicolon_in_for_statement = true
csharp_space_around_binary_operators = before_and_after
csharp_space_around_declaration_statements = do_not_ignore
csharp_space_before_colon_in_inheritance_clause = true
csharp_space_before_comma = false
csharp_space_before_dot = false
csharp_space_before_open_square_brackets = false
csharp_space_before_semicolon_in_for_statement = false
csharp_space_between_empty_square_brackets = false
csharp_space_between_method_call_empty_parameter_list_parentheses = false
csharp_space_between_method_call_name_and_opening_parenthesis = false
csharp_space_between_method_call_parameter_list_parentheses = false
csharp_space_between_method_declaration_empty_parameter_list_parentheses = false
csharp_space_between_method_declaration_name_and_open_parenthesis = false
csharp_space_between_method_declaration_parameter_list_parentheses = false
csharp_space_between_parentheses = false
csharp_space_between_square_brackets = false

# License header
csharp_style_namespace_declarations = file_scoped:silent
csharp_style_prefer_method_group_conversion = true:silent
csharp_style_prefer_top_level_statements = true:silent
csharp_style_prefer_primary_constructors = true:suggestion
csharp_prefer_system_threading_lock = true:suggestion
csharp_style_prefer_null_check_over_type_check = true:suggestion
csharp_style_prefer_local_over_anonymous_function = true:suggestion
csharp_style_implicit_object_creation_when_type_is_apparent = true:suggestion
csharp_style_prefer_tuple_swap = true:suggestion
csharp_style_prefer_unbound_generic_type_in_nameof = true:suggestion
csharp_style_prefer_utf8_string_literals = true:suggestion
csharp_style_deconstructed_variable_declaration = true:suggestion
csharp_style_unused_value_assignment_preference = discard_variable:suggestion
csharp_style_unused_value_expression_statement_preference = discard_variable:silent
csharp_prefer_static_anonymous_function = true:suggestion
csharp_style_prefer_readonly_struct = true:suggestion
csharp_style_prefer_readonly_struct_member = true:suggestion
csharp_style_allow_embedded_statements_on_same_line_experimental = true:silent
csharp_style_allow_blank_lines_between_consecutive_braces_experimental = false:silent
csharp_style_allow_blank_line_after_colon_in_constructor_initializer_experimental = false:silent
csharp_style_allow_blank_line_after_token_in_conditional_expression_experimental = false:silent
csharp_style_allow_blank_line_after_token_in_arrow_expression_clause_experimental = false:silent
csharp_style_prefer_pattern_matching = true:silent
csharp_style_prefer_not_pattern = true:suggestion
csharp_style_prefer_extended_property_pattern = true:suggestion

# C++ Files

# CA1848: Use the LoggerMessage delegates
dotnet_diagnostic.CA1848.severity = none

[*.{cpp,h,in}]
curly_bracket_next_line = true
indent_brace_style = Allman

# Xml project files
[*.{csproj,vbproj,vcxproj,vcxproj.filters,proj,nativeproj,locproj}]
indent_size = 2

[*.{csproj,vbproj,proj,nativeproj,locproj}]
charset = utf-8

# Xml build files
[*.builds]
indent_size = 2

# Xml files
[*.{xml,stylecop,resx,ruleset}]
indent_size = 2

# Xml config files
[*.{props,targets,config,nuspec}]
indent_size = 2

# YAML config files
[*.{yml,yaml}]
indent_size = 2

# Shell scripts
[*.sh]
end_of_line = lf
[*.{cmd,bat}]
end_of_line = crlf
</file>

<file path=".gitattributes">
###############################################################################
# Set default behavior to automatically normalize line endings.
###############################################################################
* text=auto

###############################################################################
# Set default behavior for command prompt diff.
#
# This is need for earlier builds of msysgit that does not have it on by
# default for csharp files.
# Note: This is only used by command line
###############################################################################
#*.cs     diff=csharp

###############################################################################
# Set the merge driver for project and solution files
#
# Merging from the command prompt will add diff markers to the files if there
# are conflicts (Merging from VS is not affected by the settings below, in VS
# the diff markers are never inserted). Diff markers may cause the following 
# file extensions to fail to load in VS. An alternative would be to treat
# these files as binary and thus will always conflict and require user
# intervention with every merge. To do so, just uncomment the entries below
###############################################################################
#*.sln       merge=binary
#*.csproj    merge=binary
#*.vbproj    merge=binary
#*.vcxproj   merge=binary
#*.vcproj    merge=binary
#*.dbproj    merge=binary
#*.fsproj    merge=binary
#*.lsproj    merge=binary
#*.wixproj   merge=binary
#*.modelproj merge=binary
#*.sqlproj   merge=binary
#*.wwaproj   merge=binary

###############################################################################
# behavior for image files
#
# image files are treated as binary by default.
###############################################################################
#*.jpg   binary
#*.png   binary
#*.gif   binary

###############################################################################
# diff behavior for common document formats
# 
# Convert binary document formats to text before diffing them. This feature
# is only available from the command line. Turn it on by uncommenting the 
# entries below.
###############################################################################
#*.doc   diff=astextplain
#*.DOC   diff=astextplain
#*.docx  diff=astextplain
#*.DOCX  diff=astextplain
#*.dot   diff=astextplain
#*.DOT   diff=astextplain
#*.pdf   diff=astextplain
#*.PDF   diff=astextplain
#*.rtf   diff=astextplain
#*.RTF   diff=astextplain
</file>

<file path=".htmlhintrc">
{
    "tagname-lowercase": true,
    "attr-lowercase": true,
    "attr-value-double-quotes": true,
    "attr-value-not-empty": false,
    "attr-no-duplication": true,
    "doctype-first": true,
    "tag-pair": true,
    "tag-self-close": false,
    "spec-char-escape": true,
    "id-unique": true,
    "src-not-empty": true,
    "title-require": true,
    "alt-require": true,
    "doctype-html5": true,
    "id-class-value": "dash",
    "style-disabled": false,
    "inline-style-disabled": false,
    "inline-script-disabled": false,
    "space-tab-mixed-disabled": "space",
    "id-class-ad-disabled": false,
    "href-abs-or-rel": false,
    "attr-unsafe-chars": true,
    "head-script-disabled": true
}
</file>

<file path=".jscpd.json">
{
    "threshold": 0,
    "reporters": ["html", "markdown"],
    "ignore": [
        "**/node_modules/**",
        "**/.git/**",
        "**/.rbenv/**",
        "**/.venv/**",
        "**/*cache*/**",
        "**/.github/**",
        "**/.idea/**",
        "**/report/**",
        "**/*.svg"
    ]
}
</file>

<file path=".mega-linter.yml">
APPLY_FIXES: all
DISABLE:
  - COPYPASTE
  - SPELL
SHOW_ELAPSED_TIME: true
FILEIO_REPORTER: false
</file>

<file path=".secretlintrc.json">
{
    "rules": [
        {
            "id": "@secretlint/secretlint-rule-preset-recommend"
        }
    ]
}
</file>

<file path=".stylelintrc.json">
{
    "extends": "stylelint-config-standard"
}
</file>

<file path=".yamllint.yml">
---
extends: default
rules:
  braces:
    max-spaces-inside: 1
  new-lines:
    level: warning
    type: unix
  line-length:
    max: 500
  comments:
    min-spaces-from-content: 1
</file>

<file path="app.manifest">
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="StreamWeaver"/>

  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- The ID below informs the system that this application is compatible with OS features first introduced in Windows 10. 
      It is necessary to support features in unpackaged applications, for example the custom titlebar implementation.
      For more info see https://docs.microsoft.com/windows/apps/windows-app-sdk/use-windows-app-sdk-run-time#declare-os-compatibility-in-your-application-manifest -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />
    </application>
  </compatibility>
  
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
</assembly>
</file>

<file path="App.xaml">
<?xml version="1.0" encoding="utf-8"?>
<Application
    x:Class="StreamWeaver.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:xamlNumerics="using:Windows.Globalization.NumberFormatting"
    xmlns:local="using:StreamWeaver">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <XamlControlsResources xmlns="using:Microsoft.UI.Xaml.Controls"/>
            </ResourceDictionary.MergedDictionaries>
            <xamlNumerics:DecimalFormatter x:Key="DecimalFormatter"
                                           IsDecimalPointAlwaysDisplayed="False"
                                           IsGrouped="False"
                                           FractionDigits="2"/>

            <xamlNumerics:DecimalFormatter x:Key="IntegerFormatter"
                                           IsDecimalPointAlwaysDisplayed="False"
                                           IsGrouped="False"
                                           FractionDigits="0"/>
        </ResourceDictionary>
    </Application.Resources>
</Application>
</file>

<file path="Assets/Badges/youtube_moderator.svg">
<?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" focusable="false" aria-hidden="true" style="pointer-events: none; display: inherit; width: 100%; height: 100%;"><path d="M9.64589146,7.05569719 C9.83346524,6.562372 9.93617022,6.02722257 9.93617022,5.46808511 C9.93617022,3.00042984 7.93574038,1 5.46808511,1 C4.90894765,1 4.37379823,1.10270499 3.88047304,1.29027875 L6.95744681,4.36725249 L4.36725255,6.95744681 L1.29027875,3.88047305 C1.10270498,4.37379824 1,4.90894766 1,5.46808511 C1,7.93574038 3.00042984,9.93617022 5.46808511,9.93617022 C6.02722256,9.93617022 6.56237198,9.83346524 7.05569716,9.64589147 L12.4098057,15 L15,12.4098057 L9.64589146,7.05569719 Z"></path></svg>
</file>

<file path="Assets/Badges/youtube_owner.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Layer_2" data-name="Layer 2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 885.65 726.5">
  <g id="Objects">
    <g>
      <path d="M846.41,146.33c-21.67,0-39.24,17.57-39.24,39.24,0,16.45,10.13,30.52,24.47,36.36-31.29,61.45-130.68,162.52-214.9,145.1-59.57-12.32-116.55-81.9-169.05-262.6,26.61-2.46,47.46-24.84,47.46-52.1,0-28.9-23.42-52.33-52.33-52.33s-52.33,23.42-52.33,52.33c0,27.26,20.84,49.64,47.46,52.1-52.49,180.7-109.48,250.28-169.05,262.6-84.22,17.43-183.61-83.65-214.9-145.1,14.34-5.84,24.47-19.91,24.47-36.36,0-21.67-17.57-39.24-39.24-39.24S0,163.9,0,185.57s17.57,39.24,39.24,39.24c2.55,0,5.04-.25,7.46-.72,31.65,119.43,52.93,189.55,92.81,344.06h606.65c39.87-154.5,61.16-224.62,92.81-344.06,2.42.47,4.91.72,7.46.72,21.67,0,39.24-17.57,39.24-39.24s-17.57-39.24-39.24-39.24Z"/>
      <path d="M139.5,695.43c0,17.16,13.91,31.07,31.07,31.07h544.5c17.16,0,31.07-13.91,31.07-31.07v-85.41H139.5v85.41Z"/>
    </g>
  </g>
</svg>
</file>

<file path="Assets/Badges/youtube_verified.svg">
<?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" focusable="false" aria-hidden="true" style="pointer-events: none; display: inherit; width: 100%; height: 100%;"><path transform="scale(0.66)" d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"></path></svg>
</file>

<file path="Core/Messaging/ConnectionsUpdateMessage.cs">
using CommunityToolkit.Mvvm.Messaging.Messages;
namespace StreamWeaver.Core.Messaging;
public class ConnectionsUpdatedMessage()
    : ValueChangedMessage<bool>(
        true
    )
{ }
</file>

<file path="Core/Messaging/NewEventMessage.cs">
using CommunityToolkit.Mvvm.Messaging.Messages;
using StreamWeaver.Core.Models.Events;
namespace StreamWeaver.Core.Messaging;
public class NewEventMessage(BaseEvent eventData) : ValueChangedMessage<BaseEvent>(eventData) { }
</file>

<file path="Core/Models/Events/BadgeInfo.cs">
namespace StreamWeaver.Core.Models.Events;
public record BadgeInfo(string Identifier, string? ImageUrl = null);
</file>

<file path="Core/Models/Events/BaseEvent.cs">
using StreamWeaver.Modules.Goals;
using StreamWeaver.Modules.Subathon;
using System.Text.Json.Serialization;
namespace StreamWeaver.Core.Models.Events;
[JsonDerivedType(typeof(ChatMessageEvent), typeDiscriminator: "ChatMessageEvent")]
[JsonDerivedType(typeof(CommandInvocationEvent), typeDiscriminator: "CommandInvocationEvent")]
[JsonDerivedType(typeof(DonationEvent), typeDiscriminator: "DonationEvent")]
[JsonDerivedType(typeof(FollowEvent), typeDiscriminator: "FollowEvent")]
[JsonDerivedType(typeof(HostEvent), typeDiscriminator: "HostEvent")]
[JsonDerivedType(typeof(MembershipEvent), typeDiscriminator: "MembershipEvent")]
[JsonDerivedType(typeof(ModerationActionEvent), typeDiscriminator: "ModerationActionEvent")]
[JsonDerivedType(typeof(RaidEvent), typeDiscriminator: "RaidEvent")]
[JsonDerivedType(typeof(SubscriptionEvent), typeDiscriminator: "SubscriptionEvent")]
[JsonDerivedType(typeof(SystemMessageEvent), typeDiscriminator: "SystemMessageEvent")]
[JsonDerivedType(typeof(UserStatusEvent), typeDiscriminator: "UserStatusEvent")]
[JsonDerivedType(typeof(WhisperEvent), typeDiscriminator: "WhisperEvent")]
[JsonDerivedType(typeof(YouTubePollUpdateEvent), typeDiscriminator: "YouTubePollUpdateEvent")]
[JsonDerivedType(typeof(GoalUpdateEvent), typeDiscriminator: "GoalUpdateEvent")]
[JsonDerivedType(typeof(SubTimerUpdateEvent), typeDiscriminator: "SubTimerUpdateEvent")]
public abstract class BaseEvent
{
    public string Id { get; init; } = Guid.NewGuid().ToString();
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
    public string Platform { get; init; } = "Unknown";
    public string? OriginatingAccountId { get; init; }
}
</file>

<file path="Core/Models/Events/BotMessageEvent.cs">
using StreamWeaver.Core.Models.Events.Messages;
namespace StreamWeaver.Core.Models.Events;
public class BotMessageEvent : BaseEvent
{
    public required string SenderDisplayName { get; init; }
    public required string SenderAccountId { get; init; }
    public required string Message { get; init; }
    public required string Target { get; init; }
    public List<MessageSegment> ParsedMessage { get; init; } = [];
    public BotMessageEvent()
    {
    }
}
</file>

<file path="Core/Models/Events/ChatMessageEvent.cs">
using StreamWeaver.Core.Models.Events.Messages;
namespace StreamWeaver.Core.Models.Events;
public class ChatMessageEvent : BaseEvent
{
    public string Username { get; init; } = string.Empty;
    public string? RawMessage { get; init; }
    public List<MessageSegment> ParsedMessage { get; init; } = [];
    public string? UserId { get; init; }
    public string? UsernameColor { get; set; }
    public List<BadgeInfo> Badges { get; init; } = [];
    public string? ProfileImageUrl { get; set; }
    public bool IsOwner { get; set; }
    public bool IsActionMessage { get; init; } = false;
    public bool IsHighlight { get; init; } = false;
    public int BitsDonated { get; init; } = 0;
    public string GetPlainText() => string.Join("", ParsedMessage.OfType<TextSegment>().Select(ts => ts.Text));
}
</file>

<file path="Core/Models/Events/CommandInvocationEvent.cs">
namespace StreamWeaver.Core.Models.Events;
public class CommandInvocationEvent : BaseEvent
{
    public required ChatMessageEvent OriginalCommandMessage { get; init; }
    public string? ReplyMessage { get; init; }
    public required string BotSenderDisplayName { get; init; }
    public CommandInvocationEvent()
    {
        Platform = OriginalCommandMessage?.Platform ?? "System";
        OriginatingAccountId = OriginalCommandMessage?.OriginatingAccountId;
    }
}
</file>

<file path="Core/Models/Events/DonationEvent.cs">
using StreamWeaver.Core.Models.Events.Messages;
namespace StreamWeaver.Core.Models.Events;
public enum DonationType
{
    Streamlabs,
    SuperChat,
    Bits,
    SuperSticker,
    Other,
}
public class DonationEvent : BaseEvent
{
    public string Username { get; init; } = string.Empty;
    public string? UserId { get; init; }
    public string? UsernameColor { get; set; }
    public List<BadgeInfo> Badges { get; init; } = [];
    public decimal Amount { get; init; } = 0;
    public string Currency { get; init; } = "USD";
    public string RawMessage { get; init; } = string.Empty;
    public List<MessageSegment> ParsedMessage { get; init; } = [];
    public string? ProfileImageUrl { get; set; }
    public bool IsOwner { get; set; }
    public DonationType Type { get; init; } = DonationType.Other;
    public string? DonationId { get; init; }
    public string? BodyBackgroundColor { get; set; }
    public string? HeaderBackgroundColor { get; set; }
    public string? HeaderTextColor { get; set; }
    public string? BodyTextColor { get; set; }
    public string? AuthorNameTextColor { get; set; }
    public string? StickerImageUrl { get; set; }
    public string? StickerAltText { get; set; }
    public string FormattedAmount
    {
        get
        {
            if (Type == DonationType.Bits)
            {
                return $"{Amount:N0} {(Amount == 1 ? "bit" : "bits")}";
            }
            else
            {
                try
                {
                    return $"{Amount:N2} {Currency}";
                }
                catch
                {
                    return $"{Amount:N2} {Currency}";
                }
            }
        }
    }
}
</file>

<file path="Core/Models/Events/FollowEvent.cs">
namespace StreamWeaver.Core.Models.Events;
public class FollowEvent : BaseEvent
{
    public string Username { get; init; } = string.Empty;
    public string? UserId { get; init; }
}
</file>

<file path="Core/Models/Events/HostEvent.cs">
namespace StreamWeaver.Core.Models.Events;
public class HostEvent : BaseEvent
{
    public bool IsHosting { get; init; }
    public string? HosterUsername { get; init; }
    public string? HostedChannel { get; init; }
    public int ViewerCount { get; init; } = 0;
    public bool IsAutoHost { get; init; } = false;
}
</file>

<file path="Core/Models/Events/MembershipEvent.cs">
using StreamWeaver.Core.Models.Events.Messages;
namespace StreamWeaver.Core.Models.Events;
public enum MembershipEventType
{
    Unknown,
    New,
    Milestone,
    GiftPurchase,
    GiftRedemption,
}
public class MembershipEvent : BaseEvent
{
    public string Username { get; init; } = string.Empty;
    public string? UserId { get; init; }
    public string? UsernameColor { get; set; }
    public List<BadgeInfo> Badges { get; init; } = [];
    public string? ProfileImageUrl { get; set; }
    public bool IsOwner { get; set; }
    public MembershipEventType MembershipType { get; init; } = MembershipEventType.Unknown;
    public string? LevelName { get; init; } = "Member";
    public int? MilestoneMonths { get; init; }
    public string? GifterUsername { get; init; }
    public int? GiftCount { get; init; }
    public string? HeaderText { get; init; }
    public List<MessageSegment> ParsedMessage { get; init; } = [];
}
</file>

<file path="Core/Models/Events/Messages/EmoteSegment.cs">
namespace StreamWeaver.Core.Models.Events.Messages;
public class EmoteSegment : MessageSegment
{
    public required string Name { get; init; }
    public required string ImageUrl { get; init; }
    public required string Id { get; init; }
    public required string Platform { get; init; }
    public override string ToString() => Name;
}
</file>

<file path="Core/Models/Events/Messages/MessageSegment.cs">
using System.Text.Json.Serialization;
namespace StreamWeaver.Core.Models.Events.Messages;
[JsonDerivedType(typeof(TextSegment), typeDiscriminator: "TextSegment")]
[JsonDerivedType(typeof(EmoteSegment), typeDiscriminator: "EmoteSegment")]
public abstract class MessageSegment { }
</file>

<file path="Core/Models/Events/Messages/PollOption.cs">
namespace StreamWeaver.Core.Models.Events.Messages;
public record PollOption(string Text, string? VotePercentage, ulong? VoteCount);
</file>

<file path="Core/Models/Events/Messages/TextSegment.cs">
namespace StreamWeaver.Core.Models.Events.Messages;
public class TextSegment : MessageSegment
{
    public required string Text { get; set; }
    public override string ToString() => Text;
}
</file>

<file path="Core/Models/Events/ModerationActionEvent.cs">
namespace StreamWeaver.Core.Models.Events;
public enum ModerationActionType
{
    Ban,
    Timeout,
    ClearMessage,
    ClearChat,
}
public class ModerationActionEvent : BaseEvent
{
    public string Channel { get; set; } = string.Empty;
    public ModerationActionType Action { get; set; }
    public string? TargetUsername { get; set; }
    public string? TargetUserId { get; set; }
    public int? DurationSeconds { get; set; }
    public string? TargetMessageId { get; set; }
    public string? ModeratorUsername { get; set; }
    public string? Reason { get; set; }
    public string? Message { get; set; }
}
</file>

<file path="Core/Models/Events/RaidEvent.cs">
namespace StreamWeaver.Core.Models.Events;
public class RaidEvent : BaseEvent
{
    public string RaiderUsername { get; init; } = string.Empty;
    public string? RaiderUserId { get; init; }
    public int ViewerCount { get; init; } = 0;
}
</file>

<file path="Core/Models/Events/SubscriptionEvent.cs">
namespace StreamWeaver.Core.Models.Events;
public class SubscriptionEvent : BaseEvent
{
    public string Username { get; init; } = string.Empty;
    public string? UserId { get; init; }
    public string? UsernameColor { get; set; }
    public List<BadgeInfo> Badges { get; init; } = [];
    public string? ProfileImageUrl { get; set; }
    public bool IsOwner { get; set; }
    public bool IsGift { get; init; } = false;
    public string? RecipientUsername { get; init; }
    public string? RecipientUserId { get; init; }
    public int Months { get; init; } = 1;
    public int CumulativeMonths { get; init; } = 0;
    public int GiftCount { get; init; } = 1;
    public int TotalGiftCount { get; init; } = 0;
    public string Tier { get; init; } = "Tier 1";
    public string? Message { get; init; }
}
</file>

<file path="Core/Models/Events/SystemMessageEvent.cs">
namespace StreamWeaver.Core.Models.Events;
public enum SystemMessageLevel
{
    Info,
    Warning,
    Error,
}
public class SystemMessageEvent : BaseEvent
{
    public string Message { get; set; } = string.Empty;
    public SystemMessageLevel Level { get; set; } = SystemMessageLevel.Info;
    public SystemMessageEvent() => Platform = "System";
}
</file>

<file path="Core/Models/Events/UserStatus.cs">
namespace StreamWeaver.Core.Models.Events;
public enum UserStatus
{
    Joined,
    Left,
}
public class UserStatusEvent : BaseEvent
{
    public string Username { get; set; } = string.Empty;
    public string Channel { get; set; } = string.Empty;
    public UserStatus Status { get; set; }
}
</file>

<file path="Core/Models/Events/WhisperEvent.cs">
using StreamWeaver.Core.Models.Events.Messages;
namespace StreamWeaver.Core.Models.Events;
public class WhisperEvent : BaseEvent
{
    public string Username { get; set; } = string.Empty;
    public string? UserId { get; set; }
    public string? UserColor { get; set; }
    public List<BadgeInfo> Badges { get; init; } = [];
    public string Message { get; set; } = string.Empty;
    public string? ProfileImageUrl { get; set; }
    public List<MessageSegment> ParsedMessage { get; init; } = [];
}
</file>

<file path="Core/Models/LogEntry.cs">
using Microsoft.Extensions.Logging;
namespace StreamWeaver.Core.Models;
public record LogEntry(DateTime Timestamp, LogLevel Level, string Category, string Message, Exception? Exception);
</file>

<file path="Core/Models/PlatformData/UserInfo.cs">
namespace StreamWeaver.Core.Models.PlatformData;
public class UserInfo
{
    public string Platform { get; set; } = string.Empty;
    public string UserId { get; set; } = string.Empty;
    public string LoginName { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
    public string? ProfileImageUrl { get; set; }
}
</file>

<file path="Core/Models/ServiceModels/TwitchBadgeInfo.cs">
namespace StreamWeaver.Core.Models.ServiceModels;
public record TwitchBadgeInfo(
    string ImageUrl1x,
    string ImageUrl2x,
    string ImageUrl4x,
    string Title,
    string? Description = null,
    string? ClickAction = null,
    string? ClickUrl = null
);
public partial class TwitchBadgeSet : Dictionary<string, TwitchBadgeInfo>
{
    public TwitchBadgeSet()
        : base(StringComparer.OrdinalIgnoreCase) { }
}
</file>

<file path="Core/Models/ServiceModels/TwitchEmoteInfo.cs">
namespace StreamWeaver.Core.Models.ServiceModels;
public record TwitchEmoteInfo(
    string Id,
    string Name,
    string ImageUrl1x,
    string ImageUrl2x,
    string ImageUrl4x,
    string Format,
    string Scale,
    string ThemeMode
)
{
    public string GetUrlForSize(string size = "1.0") =>
        size switch
        {
            "2.0" => ImageUrl2x,
            "3.0" => ImageUrl4x,
            _ => ImageUrl1x,
        };
}
</file>

<file path="Core/Models/Settings/ApiCredentials.cs">
using CommunityToolkit.Mvvm.ComponentModel;
namespace StreamWeaver.Core.Models.Settings;
public partial class ApiCredentials : ObservableObject
{
    [ObservableProperty]
    public partial string? TwitchApiClientId { get; set; }
    [ObservableProperty]
    public partial string? TwitchApiClientSecret { get; set; }
    [ObservableProperty]
    public partial string? YouTubeApiClientId { get; set; }
    [ObservableProperty]
    public partial string? YouTubeApiClientSecret { get; set; }
    public bool IsTwitchConfigured =>
        !string.IsNullOrWhiteSpace(TwitchApiClientId)
        && !string.IsNullOrWhiteSpace(TwitchApiClientSecret)
        && !TwitchApiClientId.StartsWith("YOUR_")
        && !TwitchApiClientSecret.StartsWith("YOUR_");
    public bool IsYouTubeConfigured =>
        !string.IsNullOrWhiteSpace(YouTubeApiClientId)
        && !string.IsNullOrWhiteSpace(YouTubeApiClientSecret)
        && !YouTubeApiClientId.StartsWith("YOUR_")
        && !YouTubeApiClientSecret.StartsWith("YOUR_");
    protected override void OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs e)
    {
        base.OnPropertyChanged(e);
        if (e.PropertyName is (nameof(TwitchApiClientId)) or (nameof(TwitchApiClientSecret)))
        {
            OnPropertyChanged(nameof(IsTwitchConfigured));
        }
        else if (e.PropertyName is (nameof(YouTubeApiClientId)) or (nameof(YouTubeApiClientSecret)))
        {
            OnPropertyChanged(nameof(IsYouTubeConfigured));
        }
    }
}
</file>

<file path="Core/Models/Settings/AppSettings.cs">
using CommunityToolkit.Mvvm.ComponentModel;
namespace StreamWeaver.Core.Models.Settings;
public partial class AppSettings : ObservableObject
{
    [ObservableProperty]
    public partial ApiCredentials Credentials { get; set; } = new();
    [ObservableProperty]
    public partial ConnectionSettings Connections { get; set; } = new();
    [ObservableProperty]
    public partial TtsSettings TextToSpeech { get; set; } = new();
    [ObservableProperty]
    public partial OverlaySettings Overlays { get; set; } = new();
    [ObservableProperty]
    public partial ModuleSettings Modules { get; set; } = new();
    public AppSettings()
    {
        Modules ??= new();
        Modules.Subathon ??= new();
        Modules.Goals ??= new();
        Overlays ??= new();
        Overlays.Chat ??= new();
    }
}
</file>

<file path="Core/Models/Settings/ChatOverlaySettings.cs">
using CommunityToolkit.Mvvm.ComponentModel;
namespace StreamWeaver.Core.Models.Settings;
public partial class ChatOverlaySettings : ObservableObject
{
    [ObservableProperty]
    public partial int MaxMessages { get; set; } = 20;
    [ObservableProperty]
    public partial string Font { get; set; } = "Segoe UI";
    [ObservableProperty]
    public partial int FontSize { get; set; } = 14;
    [ObservableProperty]
    public partial string TextColor { get; set; } = "#FFFFFF";
    [ObservableProperty]
    public partial string BackgroundColor { get; set; } = "rgba(0, 0, 0, 0.5)";
    [ObservableProperty]
    public partial bool ShowBadges { get; set; } = true;
    [ObservableProperty]
    public partial bool ShowPlatformIcons { get; set; } = true;
    [ObservableProperty]
    public partial bool ShowEmotes { get; set; } = true;
    [ObservableProperty]
    public partial bool FadeMessages { get; set; } = true;
    [ObservableProperty]
    public partial int FadeDelaySeconds { get; set; } = 30;
    [ObservableProperty]
    public partial bool UsePlatformColors { get; set; } = true;
    [ObservableProperty]
    public partial string TimestampFormat { get; set; } = "HH:mm";
    [ObservableProperty]
    public partial string HighlightColor { get; set; } = "#FFD700";
    [ObservableProperty]
    public partial string SubColor { get; set; } = "#8A2BE2";
    [ObservableProperty]
    public partial string DonationColor { get; set; } = "#1E90FF";
}
</file>

<file path="Core/Models/Settings/ConnectionSettings.cs">
using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
namespace StreamWeaver.Core.Models.Settings;
public partial class ConnectionSettings : ObservableObject
{
    [ObservableProperty]
    public partial ObservableCollection<TwitchAccount> TwitchAccounts { get; set; } = [];
    [ObservableProperty]
    public partial ObservableCollection<YouTubeAccount> YouTubeAccounts { get; set; } = [];
    [ObservableProperty]
    public partial string? StreamlabsTokenId { get; set; }
    [ObservableProperty]
    public partial bool EnableStreamlabs { get; set; } = false;
    [ObservableProperty]
    public partial string? DebugYouTubeLiveChatId { get; set; } = null;
}
</file>

<file path="Core/Models/Settings/ConnectionStatus.cs">
namespace StreamWeaver.Core.Models.Settings;
public enum ConnectionStatus
{
    Disconnected,
    Connecting,
    Connected,
    Limited,
    Error,
}
</file>

<file path="Core/Models/Settings/ModuleSettings.cs">
using CommunityToolkit.Mvvm.ComponentModel;
using StreamWeaver.Modules.Goals;
using StreamWeaver.Modules.Subathon;
namespace StreamWeaver.Core.Models.Settings;
public partial class ModuleSettings : ObservableObject
{
    [ObservableProperty]
    public partial SubathonSettings Subathon { get; set; } = new();
    [ObservableProperty]
    public partial GoalSettings Goals { get; set; } = new();
}
</file>

<file path="Core/Models/Settings/OverlaySettings.cs">
using CommunityToolkit.Mvvm.ComponentModel;
namespace StreamWeaver.Core.Models.Settings;
public partial class OverlaySettings : ObservableObject
{
    [ObservableProperty]
    public partial int WebServerPort { get; set; } = 5080;
    [ObservableProperty]
    public partial ChatOverlaySettings Chat { get; set; } = new();
}
</file>

<file path="Core/Models/Settings/TwitchAccount.cs">
using CommunityToolkit.Mvvm.ComponentModel;
namespace StreamWeaver.Core.Models.Settings;
public partial class TwitchAccount : ObservableObject
{
    [ObservableProperty]
    public partial string Username { get; set; } = string.Empty;
    [ObservableProperty]
    public partial string? UserId { get; set; }
    [ObservableProperty]
    public partial bool AutoConnect { get; set; } = true;
    [ObservableProperty]
    [System.Text.Json.Serialization.JsonIgnore]
    public partial ConnectionStatus Status { get; set; } = ConnectionStatus.Disconnected;
    [ObservableProperty]
    [System.Text.Json.Serialization.JsonIgnore]
    public partial string? StatusMessage { get; set; }
}
</file>

<file path="Core/Models/Settings/YouTubeAccount.cs">
using CommunityToolkit.Mvvm.ComponentModel;
namespace StreamWeaver.Core.Models.Settings;
public partial class YouTubeAccount : ObservableObject
{
    [ObservableProperty]
    public partial string ChannelName { get; set; } = string.Empty;
    [ObservableProperty]
    public partial string? ChannelId { get; set; }
    [ObservableProperty]
    public partial bool AutoConnect { get; set; } = true;
    [ObservableProperty]
    public partial string? OverrideVideoId { get; set; }
    [ObservableProperty]
    [System.Text.Json.Serialization.JsonIgnore]
    public partial ConnectionStatus Status { get; set; } = ConnectionStatus.Disconnected;
    [ObservableProperty]
    [System.Text.Json.Serialization.JsonIgnore]
    public partial string? StatusMessage { get; set; }
}
</file>

<file path="Core/Plugins/IChatCommandPlugin.cs">
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Models.Events;
namespace StreamWeaver.Core.Plugins;
public record ChatCommandContext
{
    public required string Command { get; init; }
    public required string Arguments { get; init; }
    public required ChatMessageEvent OriginalEvent { get; init; }
    public required IPluginHost Host { get; init; }
    public Task ReplyAsync(string message)
    {
        ILogger<ChatCommandContext> logger = App.GetService<ILogger<ChatCommandContext>>();
        if (Host == null)
        {
            logger.LogError("Cannot ReplyAsync: Host is null.");
            return Task.CompletedTask;
        }
        if (OriginalEvent.OriginatingAccountId == null)
        {
            logger.LogError("Cannot ReplyAsync: OriginatingAccountId on original event is null.");
            return Task.CompletedTask;
        }
        string? target = OriginalEvent.Platform switch
        {
            "Twitch" => OriginalEvent.Username,
            "YouTube" => OriginalEvent.OriginatingAccountId,
            _ => null,
        };
        if (target == null)
        {
            logger.LogWarning("Cannot determine reply target for platform '{Platform}'.", OriginalEvent.Platform);
            return Task.CompletedTask;
        }
        logger.LogInformation(
            "Sending explicit reply via {Platform} account {AccountId} to target {Target}: {Message}",
            OriginalEvent.Platform,
            OriginalEvent.OriginatingAccountId,
            target,
            message
        );
        return Host.SendChatMessageAsync(OriginalEvent.Platform, OriginalEvent.OriginatingAccountId, target, message);
    }
}
public interface IChatCommandPlugin : IPlugin
{
    IEnumerable<string> Commands { get; }
    Task<bool> HandleCommandAsync(ChatCommandContext context);
}
</file>

<file path="Core/Plugins/IEventProcessorPlugin.cs">
using StreamWeaver.Core.Models.Events;
namespace StreamWeaver.Core.Plugins;
public interface IEventProcessorPlugin : IPlugin
{
    Task ProcessEventAsync(BaseEvent eventData);
}
</file>

<file path="Core/Plugins/IPlugin.cs">
namespace StreamWeaver.Core.Plugins;
public interface IPlugin
{
    Guid Id { get; }
    string Name { get; }
    string Author { get; }
    Version Version { get; }
    Task InitializeAsync(IPluginHost host);
    Task ShutdownAsync();
}
</file>

<file path="Core/Plugins/IPluginHost.cs">
using CommunityToolkit.Mvvm.Messaging;
namespace StreamWeaver.Core.Plugins;
public interface IPluginHost
{
    IMessenger GetMessenger();
    Task SendChatMessageAsync(string platform, string senderAccountId, string target, string message);
}
</file>

<file path="Core/Plugins/PluginHost.cs">
using CommunityToolkit.Mvvm.Messaging;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Services;
namespace StreamWeaver.Core.Plugins;
internal class PluginHost : IPluginHost
{
    private readonly IServiceProvider _serviceProvider;
    private readonly IMessenger _messenger;
    private readonly UnifiedEventService _unifiedEventService;
    private readonly ILogger<PluginHost> _logger;
    public PluginHost(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
        _messenger = _serviceProvider.GetRequiredService<IMessenger>();
        _unifiedEventService = _serviceProvider.GetRequiredService<UnifiedEventService>();
        _logger = _serviceProvider.GetRequiredService<ILogger<PluginHost>>();
        _logger.LogDebug("Instance created and core services resolved.");
    }
    public IMessenger GetMessenger() => _messenger;
    public Task SendChatMessageAsync(string platform, string senderAccountId, string target, string message) =>
        _unifiedEventService.SendChatMessageAsync(platform, senderAccountId, target, message);
}
</file>

<file path="Core/Plugins/PluginManifest.cs">
using System.Text.Json.Serialization;
namespace StreamWeaver.Core.Plugins;
public class PluginManifest
{
    [JsonPropertyName("id")]
    public string? Id { get; set; }
    [JsonPropertyName("name")]
    public string? Name { get; set; }
    [JsonPropertyName("author")]
    public string? Author { get; set; }
    [JsonPropertyName("version")]
    public string? Version { get; set; }
    [JsonPropertyName("description")]
    public string? Description { get; set; }
    [JsonPropertyName("type")]
    public string? Type { get; set; }
    [JsonPropertyName("entryPoint")]
    public PluginEntryPoint? EntryPoint { get; set; }
}
public class PluginEntryPoint
{
    [JsonPropertyName("assembly")]
    public string? Assembly { get; set; }
    [JsonPropertyName("fullClassName")]
    public string? FullClassName { get; set; }
}
</file>

<file path="Core/Plugins/PluginService.cs">
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using StreamWeaver.Core.Models.Events;
namespace StreamWeaver.Core.Plugins;
public record PluginUIPageInfo(string DisplayName, Type PageType, IPlugin Plugin);
public class PluginService
{
    private readonly IServiceProvider _serviceProvider;
    private IPluginHost? _pluginHost;
    private readonly Dictionary<string, IChatCommandPlugin> _commandRegistry = new(StringComparer.OrdinalIgnoreCase);
    private readonly ILogger<PluginService> _logger;
    public ObservableCollection<IPlugin> LoadedPlugins { get; } = [];
    public ObservableCollection<PluginUIPageInfo> PluginSettingsPageProviders { get; } = [];
    private static readonly JsonSerializerOptions s_jsonSerializerOptions = new() { PropertyNameCaseInsensitive = true };
    private List<Type> _discoveredPluginTypesForInstance = [];
    public PluginService(IServiceProvider serviceProvider, ILogger<PluginService> logger)
    {
        _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _logger.LogInformation("PluginService instance created. Ready for plugin initialization.");
    }
    public static List<Type> DiscoverAndRegisterPlugins(string pluginDirectory, IServiceCollection services, IConfiguration applicationConfiguration)
    {
        var discoveredTypes = new List<Type>();
        Debug.WriteLine($"[PluginService.StaticDiscovery] Starting plugin type discovery in: {pluginDirectory}");
        if (!Directory.Exists(pluginDirectory))
        {
            Debug.WriteLine($"[PluginService.StaticDiscovery] Plugin directory not found: {pluginDirectory}. Creating it.");
            try
            {
                Directory.CreateDirectory(pluginDirectory);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[PluginService.StaticDiscovery] Failed to create plugin directory: {ex.Message}");
            }
            return discoveredTypes;
        }
        foreach (string subDir in Directory.GetDirectories(pluginDirectory))
        {
            string manifestPath = Path.Combine(subDir, "manifest.json");
            if (!File.Exists(manifestPath))
                continue;
            Debug.WriteLine($"[PluginService.StaticDiscovery] Found manifest: {manifestPath}");
            try
            {
                string manifestJson = File.ReadAllText(manifestPath);
                PluginManifest? manifest = JsonSerializer.Deserialize<PluginManifest>(manifestJson, s_jsonSerializerOptions);
                if (!ValidateManifestInternalStatic(manifest, manifestPath) || manifest!.EntryPoint == null)
                    continue;
                if (manifest.Type?.Equals("dotnet", StringComparison.OrdinalIgnoreCase) == true)
                {
                    string assemblyPath = Path.GetFullPath(Path.Combine(subDir, manifest.EntryPoint.Assembly!));
                    if (!File.Exists(assemblyPath))
                    {
                        Debug.WriteLine($"[PluginService.StaticDiscovery] Assembly file not found: {assemblyPath}");
                        continue;
                    }
                    Assembly pluginAssembly = Assembly.LoadFrom(assemblyPath);
                    Type? pluginType = pluginAssembly.GetType(manifest.EntryPoint.FullClassName!, throwOnError: false);
                    if (pluginType == null || !typeof(IPlugin).IsAssignableFrom(pluginType) || pluginType.IsInterface || pluginType.IsAbstract)
                    {
                        Debug.WriteLine(
                            $"[PluginService.StaticDiscovery] Invalid plugin type '{manifest.EntryPoint.FullClassName}' in {assemblyPath}."
                        );
                        continue;
                    }
                    services.AddSingleton(pluginType);
                    discoveredTypes.Add(pluginType);
                    Debug.WriteLine($"[PluginService.StaticDiscovery] Registered plugin type for DI: {pluginType.FullName}");
                    if (typeof(IConfigurablePlugin).IsAssignableFrom(pluginType))
                    {
                        Debug.WriteLine(
                            $"[PluginService.StaticDiscovery] Plugin type {pluginType.FullName} implements IConfigurablePlugin. Configuring options..."
                        );
                        ConfigurePluginOptionsInternal(pluginType, services, applicationConfiguration);
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[PluginService.StaticDiscovery] Error processing manifest {manifestPath}: {ex.Message}");
            }
        }
        Debug.WriteLine(
            $"[PluginService.StaticDiscovery] Plugin type discovery and DI registration complete. {discoveredTypes.Count} types registered."
        );
        return discoveredTypes;
    }
    private static void ConfigurePluginOptionsInternal(Type pluginType, IServiceCollection services, IConfiguration applicationConfiguration)
    {
        try
        {
            PropertyInfo? optionsTypeProp = pluginType.GetProperty(
                "OptionsType",
                BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy
            );
            PropertyInfo? sectionNameProp = pluginType.GetProperty(
                "DefaultConfigurationSectionName",
                BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy
            );
            if (optionsTypeProp?.GetValue(null) is Type actualOptionsType && sectionNameProp?.GetValue(null) is string actualSectionName)
            {
                string fullSectionPath = $"Plugins:{actualSectionName}";
                IConfigurationSection pluginSpecificConfigSection = applicationConfiguration.GetSection(fullSectionPath);
                MethodInfo? configureMethod = typeof(OptionsConfigurationServiceCollectionExtensions)
                    .GetMethods(BindingFlags.Public | BindingFlags.Static)
                    .FirstOrDefault(m =>
                        m.Name == "Configure"
                        && m.IsGenericMethodDefinition
                        && m.GetParameters().Length == 2
                        && m.GetParameters()[1].ParameterType == typeof(IConfiguration)
                    );
                if (configureMethod != null)
                {
                    MethodInfo genericConfigureMethod = configureMethod.MakeGenericMethod(actualOptionsType);
                    genericConfigureMethod.Invoke(null, [services, pluginSpecificConfigSection]);
                    Debug.WriteLine(
                        $"[PluginService.StaticDiscovery] Configured options for {pluginType.FullName} (Type: {actualOptionsType.Name}, Section: {fullSectionPath})"
                    );
                }
                else
                {
                    Debug.WriteLine(
                        $"[PluginService.StaticDiscovery] Could not find services.Configure<T>(IConfiguration) method for plugin {pluginType.FullName}."
                    );
                }
            }
            else
            {
                Debug.WriteLine(
                    $"[PluginService.StaticDiscovery] Plugin type {pluginType.FullName} implements IConfigurablePlugin but static 'OptionsType' or 'DefaultConfigurationSectionName' properties were not found or returned null."
                );
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine(
                $"[PluginService.StaticDiscovery] Error while trying to configure options for plugin {pluginType.FullName} using static members: {ex.Message}"
            );
        }
    }
    private static bool ValidateManifestInternalStatic(PluginManifest? manifest, string manifestPath, ILogger? logger = null)
    {
        Action<string> logError = msg =>
        {
            logger?.LogError(msg);
            Debug.WriteLine($"[ValidateManifestStatic] {msg}");
        };
        Action<string> logWarning = msg =>
        {
            logger?.LogWarning(msg);
            Debug.WriteLine($"[ValidateManifestStatic] {msg}");
        };
        if (manifest == null)
        {
            logError($"Error in manifest {manifestPath}: Failed to deserialize.");
            return false;
        }
        if (!Guid.TryParse(manifest.Id, out _))
        {
            logError($"Error in manifest {manifestPath}: 'id' is missing or not a valid GUID.");
            return false;
        }
        if (string.IsNullOrWhiteSpace(manifest.Name))
        {
            logError($"Error in manifest {manifestPath}: 'name' is missing.");
            return false;
        }
        return true;
    }
    public async Task InitializeLoadedPluginsAsync(List<Type> discoveredPluginTypes, IConfiguration applicationConfiguration)
    {
        if (LoadedPlugins.Any())
        {
            _logger.LogWarning("InitializeLoadedPluginsAsync called, but plugins seem already initialized. Skipping.");
            return;
        }
        _discoveredPluginTypesForInstance = discoveredPluginTypes ?? throw new ArgumentNullException(nameof(discoveredPluginTypes));
        if (!_discoveredPluginTypesForInstance.Any())
        {
            _logger.LogInformation("No plugin types provided to initialize. Skipping initialization phase.");
            return;
        }
        _logger.LogInformation("Initializing {Count} discovered plugin instances...", _discoveredPluginTypesForInstance.Count);
        _pluginHost = new PluginHost(_serviceProvider);
        foreach (Type pluginType in _discoveredPluginTypesForInstance)
        {
            try
            {
                if (_serviceProvider.GetService(pluginType) is not IPlugin pluginInstance)
                {
                    _logger.LogError("Failed to resolve plugin instance from DI for type {PluginTypeName}. Skipping.", pluginType.FullName);
                    continue;
                }
                if (pluginInstance is IPluginUIPageProvider uiProvider)
                {
                    _logger.LogDebug("Plugin {PluginName} implements IPluginUIPageProvider. Registering UI page...", pluginInstance.Name);
                    PluginSettingsPageProviders.Add(
                        new PluginUIPageInfo(uiProvider.SettingsPageDisplayName, uiProvider.SettingsPageType, pluginInstance)
                    );
                    _logger.LogDebug(
                        "Registered UI page '{PageName}' for plugin {PluginName}.",
                        uiProvider.SettingsPageType.Name,
                        pluginInstance.Name
                    );
                }
                await pluginInstance.InitializeAsync(_pluginHost);
                LoadedPlugins.Add(pluginInstance);
                _logger.LogInformation(
                    "Successfully initialized plugin: {PluginName} (Version: {PluginVersion}, ID: {PluginId})",
                    pluginInstance.Name,
                    pluginInstance.Version,
                    pluginInstance.Id
                );
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error initializing plugin instance of type {PluginTypeName}", pluginType.FullName);
            }
        }
        _logger.LogInformation("Plugin instance initialization complete. {Count} plugins fully loaded.", LoadedPlugins.Count);
        ProcessChatCommandPlugins();
        ProcessEventProcessorPlugins();
    }
    private bool ValidateManifest(PluginManifest? manifest, string manifestPath)
    {
        return ValidateManifestInternalStatic(manifest, manifestPath, _logger);
    }
    private bool VerifyInstanceMetadata(PluginManifest manifest, IPlugin instance)
    {
        if (!Guid.Parse(manifest.Id!).Equals(instance.Id))
        {
            _logger.LogWarning(
                "Manifest/Instance ID mismatch for plugin '{PluginName}'. Manifest: {ManifestId}, Instance: {InstanceId}",
                manifest.Name,
                manifest.Id,
                instance.Id
            );
        }
        if (!manifest.Name!.Equals(instance.Name, StringComparison.Ordinal))
        {
            _logger.LogWarning(
                "Manifest/Instance Name mismatch for plugin '{ManifestName}'. Instance Name: '{InstanceName}'",
                manifest.Name,
                instance.Name
            );
        }
        if (!manifest.Author!.Equals(instance.Author, StringComparison.Ordinal))
        {
            _logger.LogWarning(
                "Manifest/Instance Author mismatch for plugin '{PluginName}'. Manifest: '{ManifestAuthor}', Instance: '{InstanceAuthor}'",
                manifest.Name,
                manifest.Author,
                instance.Author
            );
        }
        if (!Version.Parse(manifest.Version!).Equals(instance.Version))
        {
            _logger.LogWarning(
                "Manifest/Instance Version mismatch for plugin '{PluginName}'. Manifest: {ManifestVersion}, Instance: {InstanceVersion}",
                manifest.Name,
                manifest.Version,
                instance.Version
            );
        }
        return true;
    }
    public async Task ShutdownPluginsAsync()
    {
        if (LoadedPlugins.Count == 0)
        {
            _logger.LogInformation("No plugins loaded, shutdown skipped.");
            return;
        }
        _logger.LogInformation("Shutting down {Count} plugins...", LoadedPlugins.Count);
        List<IPlugin> pluginsToShutdown = [.. LoadedPlugins];
        List<Task> shutdownTasks = [];
        foreach (IPlugin plugin in pluginsToShutdown)
        {
            shutdownTasks.Add(
                Task.Run(async () =>
                {
                    try
                    {
                        _logger.LogDebug("Shutting down plugin: {PluginName}...", plugin.Name);
                        await plugin.ShutdownAsync();
                        _logger.LogInformation("Plugin shutdown complete: {PluginName}", plugin.Name);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error shutting down plugin {PluginName}", plugin.Name);
                    }
                })
            );
        }
        try
        {
            await Task.WhenAll(shutdownTasks).WaitAsync(TimeSpan.FromSeconds(10));
            _logger.LogDebug("All plugin shutdown tasks completed or timed out.");
        }
        catch (TimeoutException)
        {
            _logger.LogWarning("Timeout waiting for plugins to shut down.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during plugin shutdown synchronization.");
        }
        LoadedPlugins.Clear();
        PluginSettingsPageProviders.Clear();
        _commandRegistry.Clear();
        _pluginHost = null;
        _logger.LogInformation("All plugins shut down and lists cleared.");
    }
    private void ProcessChatCommandPlugins()
    {
        _commandRegistry.Clear();
        IEnumerable<IChatCommandPlugin> commandPlugins = LoadedPlugins.OfType<IChatCommandPlugin>();
        _logger.LogInformation("Processing {Count} chat command plugins for registry...", commandPlugins.Count());
        foreach (IChatCommandPlugin plugin in commandPlugins)
        {
            if (plugin.Commands == null)
                continue;
            foreach (string command in plugin.Commands.Select(c => c?.ToLowerInvariant() ?? string.Empty).Where(c => !string.IsNullOrWhiteSpace(c)))
            {
                if (_commandRegistry.TryGetValue(command, out IChatCommandPlugin? existingPlugin))
                {
                    _logger.LogWarning(
                        "Command '{Command}' conflict. Plugin '{NewPlugin}' tried to register, but it's already handled by '{ExistingPlugin}'. Ignoring registration from '{NewPlugin}'.",
                        command,
                        plugin.Name,
                        existingPlugin.Name,
                        plugin.Name
                    );
                }
                else
                {
                    _commandRegistry.Add(command, plugin);
                    _logger.LogDebug("--> Registered command '{Command}' to plugin '{PluginName}'.", command, plugin.Name);
                }
            }
        }
        _logger.LogInformation("Command registry populated with {Count} commands.", _commandRegistry.Count);
    }
    private void ProcessEventProcessorPlugins()
    {
        int count = LoadedPlugins.OfType<IEventProcessorPlugin>().Count();
        _logger.LogInformation("Found {Count} event processor plugins.", count);
    }
    public async Task RouteEventToProcessorsAsync(BaseEvent eventData)
    {
        List<IEventProcessorPlugin> processors = [.. LoadedPlugins.OfType<IEventProcessorPlugin>()];
        if (processors.Count == 0)
            return;
        _logger.LogTrace(
            "Routing event {EventType} ({EventId}) to {ProcessorCount} processors...",
            eventData.GetType().Name,
            eventData.Id,
            processors.Count
        );
        foreach (IEventProcessorPlugin processor in processors)
        {
            try
            {
                await processor.ProcessEventAsync(eventData);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error routing event to plugin '{PluginName}'", processor.Name);
            }
        }
    }
    public static bool IsChatCommand(ChatMessageEvent messageEvent)
    {
        string messageText = messageEvent.RawMessage?.Trim() ?? string.Empty;
        if (string.IsNullOrWhiteSpace(messageText) || messageText.Length < 2 || messageText[0] != '!')
        {
            return false;
        }
        string[] parts = messageText.Split(' ', 2, StringSplitOptions.RemoveEmptyEntries);
        return parts[0].Length > 1;
    }
    public async Task<bool> TryHandleChatCommandAsync(ChatMessageEvent messageEvent)
    {
        string messageText = messageEvent.RawMessage?.Trim() ?? string.Empty;
        if (!IsChatCommand(messageEvent))
            return false;
        string[] parts = messageText.Split(' ', 2, StringSplitOptions.RemoveEmptyEntries);
        string command = parts[0].ToLowerInvariant();
        if (_commandRegistry.TryGetValue(command, out IChatCommandPlugin? handlerPlugin))
        {
            if (_pluginHost == null)
            {
                _logger.LogError(
                    "Cannot handle command '{Command}': PluginHost is null (was InitializeLoadedPluginsAsync called after DI build?).",
                    command
                );
                return false;
            }
            string arguments = parts.Length > 1 ? parts[1].Trim() : string.Empty;
            _logger.LogInformation("Matched command '{Command}' to plugin '{PluginName}'. Executing...", command, handlerPlugin.Name);
            try
            {
                ChatCommandContext context = new()
                {
                    Command = command,
                    Arguments = arguments,
                    OriginalEvent = messageEvent,
                    Host = _pluginHost,
                };
                bool suppressOriginal = await handlerPlugin.HandleCommandAsync(context);
                _logger.LogInformation(
                    "Command '{Command}' executed by plugin '{PluginName}'. Suppress original message: {Suppress}",
                    command,
                    handlerPlugin.Name,
                    suppressOriginal
                );
                return suppressOriginal;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error executing command '{Command}' in plugin '{PluginName}'", command, handlerPlugin.Name);
                return false;
            }
        }
        _logger.LogDebug("No registered handler found for potential command: {Command}", command);
        return false;
    }
}
</file>

<file path="Core/Services/Authentication/IAuthService.cs">
namespace StreamWeaver.Core.Services.Authentication;
public interface IAuthService
{
    Task<bool> InitiateLoginAsync();
    Task<bool> RefreshTokenAsync(string accountId);
    Task LogoutAsync(string accountId);
    Task<bool> IsAuthenticatedAsync(string accountId);
    Task<string?> GetAccessTokenAsync(string accountId);
}
</file>

<file path="Core/Services/Authentication/ITokenStorageService.cs">
namespace StreamWeaver.Core.Services.Authentication;
public interface ITokenStorageService
{
    Task SaveTokensAsync(string key, string accessToken, string? refreshToken);
    Task<(string? AccessToken, string? RefreshToken)> GetTokensAsync(string key);
    Task DeleteTokensAsync(string key);
}
</file>

<file path="Core/Services/Authentication/TokenStorageService.cs">
using Microsoft.Extensions.Logging;
using Windows.Security.Credentials;
namespace StreamWeaver.Core.Services.Authentication;
public class TokenStorageService(ILogger<TokenStorageService> logger) : ITokenStorageService
{
    private readonly PasswordVault _vault = new();
    private readonly ILogger<TokenStorageService> _logger = logger;
    private const string ResourceName = "StreamWeaverTokens";
    public Task SaveTokensAsync(string key, string accessToken, string? refreshToken)
    {
        string accessKey = key + "_access";
        string refreshKey = key + "_refresh";
        try
        {
            _vault.Add(new PasswordCredential(ResourceName, accessKey, accessToken));
            _logger.LogTrace("Added new access token credential for key {Key}", key);
            if (!string.IsNullOrEmpty(refreshToken))
            {
                _vault.Add(new PasswordCredential(ResourceName, refreshKey, refreshToken));
                _logger.LogTrace("Added new refresh token credential for key {Key}", key);
            }
            else
            {
                try
                {
                    PasswordCredential? existingRefresh = _vault.Retrieve(ResourceName, refreshKey);
                    if (existingRefresh != null)
                    {
                        _vault.Remove(existingRefresh);
                        _logger.LogTrace("Removed existing refresh token for key {Key} as new one is null/empty.", key);
                    }
                }
                catch (Exception ex) when (ex.HResult == -2147023728)
                {
                    _logger.LogTrace("No existing refresh token found to remove for key {Key}.", key);
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(
                        ex,
                        "Failed to remove potentially existing refresh token for key {Key}. This might leave an orphaned refresh token.",
                        key
                    );
                }
            }
            _logger.LogInformation("Tokens saved successfully for key {Key}", key);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to initially add token(s) for key {Key}, attempting update.", key);
            try
            {
                PasswordCredential existingAccess = _vault.Retrieve(ResourceName, accessKey);
                existingAccess.Password = accessToken;
                _vault.Add(existingAccess);
                _logger.LogTrace("Updated existing access token credential for key {Key}", key);
                if (!string.IsNullOrEmpty(refreshToken))
                {
                    try
                    {
                        PasswordCredential existingRefresh = _vault.Retrieve(ResourceName, refreshKey);
                        existingRefresh.Password = refreshToken;
                        _vault.Add(existingRefresh);
                        _logger.LogTrace("Updated existing refresh token credential for key {Key}", key);
                    }
                    catch (Exception refreshEx) when (refreshEx.HResult == -2147023728)
                    {
                        _logger.LogTrace("Existing refresh token not found for key {Key}, adding new one during update.", key);
                        _vault.Add(new PasswordCredential(ResourceName, refreshKey, refreshToken));
                    }
                }
                else
                {
                    try
                    {
                        PasswordCredential? existingRefresh = _vault.Retrieve(ResourceName, refreshKey);
                        if (existingRefresh != null)
                        {
                            _vault.Remove(existingRefresh);
                            _logger.LogTrace("Removed existing refresh token for key {Key} during update process.", key);
                        }
                    }
                    catch (Exception removeEx) when (removeEx.HResult == -2147023728)
                    {
                        _logger.LogTrace("No existing refresh token found to remove during update for key {Key}.", key);
                    }
                    catch (Exception removeEx)
                    {
                        _logger.LogWarning(removeEx, "Failed to remove potentially existing refresh token during update for key {Key}.", key);
                    }
                }
                _logger.LogInformation("Tokens updated successfully for key {Key}", key);
            }
            catch (Exception updateEx)
            {
                _logger.LogError(updateEx, "Failed to save or update tokens for key {Key}", key);
            }
        }
        return Task.CompletedTask;
    }
    public Task<(string? AccessToken, string? RefreshToken)> GetTokensAsync(string key)
    {
        string? accessToken = null;
        string? refreshToken = null;
        string accessKey = key + "_access";
        string refreshKey = key + "_refresh";
        try
        {
            PasswordCredential credAccess = _vault.Retrieve(ResourceName, accessKey);
            credAccess.RetrievePassword();
            accessToken = credAccess.Password;
        }
        catch (Exception ex) when (ex.HResult == -2147023728)
        {
            _logger.LogDebug("Access token not found for key {Key}", key);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to retrieve access token for key {Key}", key);
        }
        try
        {
            PasswordCredential credRefresh = _vault.Retrieve(ResourceName, refreshKey);
            credRefresh.RetrievePassword();
            refreshToken = credRefresh.Password;
        }
        catch (Exception ex) when (ex.HResult == -2147023728)
        {
            _logger.LogDebug("Refresh token not found for key {Key}", key);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to retrieve refresh token for key {Key}", key);
        }
        bool accessFound = !string.IsNullOrEmpty(accessToken);
        bool refreshFound = !string.IsNullOrEmpty(refreshToken);
        _logger.LogDebug(
            "Token retrieval attempt for key {Key} completed. Access found: {AccessFound}, Refresh found: {RefreshFound}",
            key,
            accessFound,
            refreshFound
        );
        return Task.FromResult<(string?, string?)>((accessToken, refreshToken));
    }
    public Task DeleteTokensAsync(string key)
    {
        string accessKey = key + "_access";
        string refreshKey = key + "_refresh";
        bool deletedAccess = false;
        bool deletedRefresh = false;
        try
        {
            PasswordCredential credAccess = _vault.Retrieve(ResourceName, accessKey);
            _vault.Remove(credAccess);
            deletedAccess = true;
        }
        catch (Exception ex) when (ex.HResult == -2147023728)
        {
            _logger.LogTrace("Access token not found for key {Key} during delete operation.", key);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to delete access token for key {Key}.", key);
        }
        try
        {
            PasswordCredential credRefresh = _vault.Retrieve(ResourceName, refreshKey);
            _vault.Remove(credRefresh);
            deletedRefresh = true;
        }
        catch (Exception ex) when (ex.HResult == -2147023728)
        {
            _logger.LogTrace("Refresh token not found for key {Key} during delete operation.", key);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to delete refresh token for key {Key}.", key);
        }
        if (deletedAccess || deletedRefresh)
        {
            _logger.LogInformation(
                "Token deletion attempt completed for key {Key}. Access deleted: {AccessDeleted}, Refresh deleted: {RefreshDeleted}",
                key,
                deletedAccess,
                deletedRefresh
            );
        }
        else
        {
            _logger.LogDebug("Token deletion attempt completed for key {Key}. No tokens found to delete.", key);
        }
        return Task.CompletedTask;
    }
}
</file>

<file path="Core/Services/Authentication/TwitchAuthService.cs">
using System.Net;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Web;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Models.Settings;
using StreamWeaver.Core.Services.Settings;
using Windows.System;
namespace StreamWeaver.Core.Services.Authentication;
public class TwitchAuthService(ITokenStorageService tokenStorage, ISettingsService settingsService, ILogger<TwitchAuthService> logger)
{
    private readonly ITokenStorageService _tokenStorage = tokenStorage ?? throw new ArgumentNullException(nameof(tokenStorage));
    private readonly ISettingsService _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
    private readonly HttpClient _httpClient = new();
    private readonly ILogger<TwitchAuthService> _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    private const string RedirectUri = "http://localhost:5081/callback/twitch";
    private readonly string[] _scopes =
    [
        "chat:read",
        "chat:edit",
        "user:read:email",
        "whispers:read",
    ];
    private static string? s_oauthState;
    public async Task<bool> InitiateLoginAsync()
    {
        (string? ClientId, string? ClientSecret)? credentials = GetCredentialsFromSettings();
        if (credentials == null)
        {
            _logger.LogWarning("Cannot initiate Twitch login: Client credentials missing or invalid in settings.");
            return false;
        }
        s_oauthState = Guid.NewGuid().ToString("N");
        _logger.LogDebug("Generated OAuth State: {OAuthState}", s_oauthState);
        string scopesString = string.Join(" ", _scopes);
        string authUrl =
            $"https://id.twitch.tv/oauth2/authorize"
            + $"?response_type=code"
            + $"&client_id={credentials.Value.ClientId}"
            + $"&redirect_uri={Uri.EscapeDataString(RedirectUri)}"
            + $"&scope={Uri.EscapeDataString(scopesString)}"
            + $"&state={s_oauthState}";
        string? authorizationCode = null;
        HttpListener? listener = null;
        try
        {
            _logger.LogInformation("Starting HttpListener on {RedirectUri}...", RedirectUri);
            listener = new HttpListener();
            listener.Prefixes.Add(RedirectUri.EndsWith('/') ? RedirectUri : RedirectUri + "/");
            listener.Start();
            _logger.LogInformation("Launching browser for Twitch auth: {AuthUrl}", authUrl);
            bool successLaunch = await Launcher.LaunchUriAsync(new Uri(authUrl));
            if (!successLaunch)
            {
                _logger.LogWarning("Failed to launch the default system browser.");
                listener.Stop();
                return false;
            }
            _logger.LogInformation("Waiting for OAuth callback from Twitch...");
            HttpListenerContext context = await listener.GetContextAsync().WaitAsync(TimeSpan.FromMinutes(2));
            HttpListenerRequest request = context.Request;
            HttpListenerResponse response = context.Response;
            try
            {
                _logger.LogDebug("Received callback: {CallbackUrl}", request.Url);
                string? receivedState = request.QueryString["state"];
                string? receivedCode = request.QueryString["code"];
                string? receivedError = request.QueryString["error"];
                string? receivedErrorDesc = request.QueryString["error_description"];
                if (!string.IsNullOrEmpty(receivedError))
                {
                    _logger.LogError("OAuth Error received from Twitch: {Error} - {ErrorDescription}", receivedError, receivedErrorDesc);
                    await SendResponseAsync(
                        response,
                        $"<html><body>OAuth Error: {HttpUtility.HtmlEncode(receivedErrorDesc ?? receivedError)}. Please close this window.</body></html>",
                        HttpStatusCode.BadRequest
                    );
                    s_oauthState = null;
                    return false;
                }
                if (string.IsNullOrEmpty(receivedState) || receivedState != s_oauthState)
                {
                    _logger.LogError("OAuth State mismatch! Expected: '{ExpectedState}', Received: '{ReceivedState}'", s_oauthState, receivedState);
                    await SendResponseAsync(
                        response,
                        "<html><body>OAuth Security Error (State mismatch). Please close this window and try logging in again.</body></html>",
                        HttpStatusCode.BadRequest
                    );
                    s_oauthState = null;
                    return false;
                }
                s_oauthState = null;
                if (string.IsNullOrEmpty(receivedCode))
                {
                    _logger.LogError("OAuth callback did not contain the required authorization code.");
                    await SendResponseAsync(
                        response,
                        "<html><body>OAuth callback error: Authorization code missing. Please close this window.</body></html>",
                        HttpStatusCode.BadRequest
                    );
                    return false;
                }
                authorizationCode = receivedCode;
                _logger.LogInformation("OAuth authorization code received successfully.");
                await SendResponseAsync(
                    response,
                    "<html><body>Authentication successful! You can close this window and return to StreamWeaver.</body></html>"
                );
            }
            finally
            {
                response?.Close();
            }
        }
        catch (TimeoutException)
        {
            _logger.LogWarning("OAuth callback timed out after 2 minutes.");
            s_oauthState = null;
            return false;
        }
        catch (ObjectDisposedException ode) when (ode.ObjectName == "System.Net.HttpListener")
        {
            _logger.LogWarning("HttpListener was disposed while waiting for callback, possibly due to cancellation or shutdown.");
            s_oauthState = null;
            return false;
        }
        catch (HttpListenerException hle)
        {
            _logger.LogError(hle, "HttpListener error during OAuth callback handling: {ErrorMessage}", hle.Message);
            s_oauthState = null;
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during OAuth listener/callback processing: {ErrorMessage}", ex.Message);
            s_oauthState = null;
            return false;
        }
        finally
        {
            if (listener?.IsListening ?? false)
            {
                listener.Stop();
                _logger.LogInformation("HttpListener stopped.");
            }
            listener?.Close();
        }
        if (!string.IsNullOrEmpty(authorizationCode))
        {
            return await ExchangeCodeForTokenAsync(authorizationCode);
        }
        else
        {
            _logger.LogError("Authorization code was null after listener processing, login failed.");
            return false;
        }
    }
    private (string? ClientId, string? ClientSecret)? GetCredentialsFromSettings()
    {
        AppSettings settings = _settingsService.CurrentSettings;
        string? clientId = settings.Credentials?.TwitchApiClientId;
        string? clientSecret = settings.Credentials?.TwitchApiClientSecret;
        if (string.IsNullOrWhiteSpace(clientId) || string.IsNullOrWhiteSpace(clientSecret))
        {
            _logger.LogWarning("Twitch Client ID or Client Secret is missing in application settings.");
            return null;
        }
        if (clientId.StartsWith("YOUR_") || clientId.Length < 10 || clientSecret.StartsWith("YOUR_") || clientSecret.Length < 10)
        {
            _logger.LogWarning("Twitch Client ID or Client Secret appears to be a placeholder or invalid value in settings.");
            return null;
        }
        return (clientId, clientSecret);
    }
    private async Task SendResponseAsync(HttpListenerResponse response, string content, HttpStatusCode statusCode = HttpStatusCode.OK)
    {
        try
        {
            byte[] buffer = Encoding.UTF8.GetBytes(content);
            response.ContentLength64 = buffer.Length;
            response.ContentType = "text/html; charset=utf-8";
            response.StatusCode = (int)statusCode;
            using Stream output = response.OutputStream;
            await output.WriteAsync(buffer);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to send response back to browser via HttpListener.");
        }
    }
    private async Task<bool> ExchangeCodeForTokenAsync(string code)
    {
        _logger.LogInformation("Exchanging Twitch authorization code for tokens...");
        (string? ClientId, string? ClientSecret)? credentials = GetCredentialsFromSettings();
        if (credentials == null || credentials.Value.ClientId == null || credentials.Value.ClientSecret == null)
        {
            _logger.LogError("Cannot exchange code for token: Client credentials missing or invalid.");
            return false;
        }
        string tokenEndpoint = "https://id.twitch.tv/oauth2/token";
        var content = new FormUrlEncodedContent(
            new Dictionary<string, string>
            {
                { "client_id", credentials.Value.ClientId },
                { "client_secret", credentials.Value.ClientSecret },
                { "code", code },
                { "grant_type", "authorization_code" },
                { "redirect_uri", RedirectUri },
            }
        );
        try
        {
            HttpResponseMessage response = await _httpClient.PostAsync(tokenEndpoint, content);
            string responseBody = await response.Content.ReadAsStringAsync();
            if (!response.IsSuccessStatusCode)
            {
                _logger.LogError(
                    "Error exchanging Twitch code for token. Status: {StatusCode}, Response: {ResponseBody}",
                    response.StatusCode,
                    responseBody
                );
                return false;
            }
            _logger.LogInformation("Token exchange successful. Parsing response...");
            using JsonDocument jsonDoc = JsonDocument.Parse(responseBody);
            JsonElement root = jsonDoc.RootElement;
            string? accessToken = root.TryGetProperty("access_token", out JsonElement accessTokenElement) ? accessTokenElement.GetString() : null;
            string? refreshToken = root.TryGetProperty("refresh_token", out JsonElement refreshTokenElement) ? refreshTokenElement.GetString() : null;
            if (string.IsNullOrEmpty(accessToken) || string.IsNullOrEmpty(refreshToken))
            {
                _logger.LogError("Error parsing token response: Access token or refresh token missing. Response: {ResponseBody}", responseBody);
                return false;
            }
            _logger.LogInformation("Access and refresh tokens received. Getting user info...");
            (string UserId, string Login)? userInfo = await GetAuthenticatedUserInfoAsync(accessToken, credentials.Value.ClientId);
            if (userInfo == null)
            {
                _logger.LogError("Failed to get user info after successful token exchange. Cannot save authentication.");
                return false;
            }
            _logger.LogInformation("User info obtained: ID={UserId}, Login={UserLogin}", userInfo.Value.UserId, userInfo.Value.Login);
            return await SaveAuthenticationAsync(userInfo.Value.UserId, userInfo.Value.Login, accessToken, refreshToken);
        }
        catch (JsonException jsonEx)
        {
            _logger.LogError(jsonEx, "Error parsing JSON response during token exchange.");
            return false;
        }
        catch (HttpRequestException httpEx)
        {
            _logger.LogError(httpEx, "HTTP network error during token exchange.");
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during token exchange.");
            return false;
        }
    }
    private async Task<(string UserId, string Login)?> GetAuthenticatedUserInfoAsync(string accessToken, string clientId)
    {
        _logger.LogDebug("Fetching authenticated user's info from Twitch API...");
        string usersEndpoint = "https://api.twitch.tv/helix/users";
        try
        {
            using var request = new HttpRequestMessage(HttpMethod.Get, usersEndpoint);
            request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", accessToken);
            request.Headers.Add("Client-Id", clientId);
            HttpResponseMessage response = await _httpClient.SendAsync(request);
            string responseBody = await response.Content.ReadAsStringAsync();
            if (!response.IsSuccessStatusCode)
            {
                _logger.LogError(
                    "Error getting user info from Twitch API. Status: {StatusCode}, Response: {ResponseBody}",
                    response.StatusCode,
                    responseBody
                );
                return null;
            }
            using JsonDocument jsonDoc = JsonDocument.Parse(responseBody);
            if (!jsonDoc.RootElement.TryGetProperty("data", out JsonElement usersArray) || usersArray.ValueKind != JsonValueKind.Array)
            {
                _logger.LogError("Invalid JSON structure in user info response: 'data' array not found. Response: {ResponseBody}", responseBody);
                return null;
            }
            if (usersArray.GetArrayLength() == 0)
            {
                _logger.LogError("User info API response contained an empty 'data' array. Response: {ResponseBody}", responseBody);
                return null;
            }
            JsonElement userObject = usersArray[0];
            string? userId = userObject.TryGetProperty("id", out JsonElement idElement) ? idElement.GetString() : null;
            string? loginName = userObject.TryGetProperty("login", out JsonElement loginElement) ? loginElement.GetString() : null;
            if (string.IsNullOrEmpty(userId) || string.IsNullOrEmpty(loginName))
            {
                _logger.LogError("User ID or Login name missing in user info API response object. Response: {ResponseBody}", responseBody);
                return null;
            }
            _logger.LogDebug("Successfully retrieved user info: ID={UserId}, Login={UserLogin}", userId, loginName);
            return (userId, loginName);
        }
        catch (JsonException jsonEx)
        {
            _logger.LogError(jsonEx, "Error parsing JSON response when getting user info.");
            return null;
        }
        catch (HttpRequestException httpEx)
        {
            _logger.LogError(httpEx, "HTTP network error when getting user info.");
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error when getting user info.");
            return null;
        }
    }
    private async Task<bool> SaveAuthenticationAsync(string userId, string username, string accessToken, string refreshToken)
    {
        _logger.LogInformation("Saving authentication data for User ID: {UserId}, Username: {Username}", userId, username);
        try
        {
            string storageKey = $"twitch_{userId}";
            await _tokenStorage.SaveTokensAsync(storageKey, accessToken, refreshToken);
            _logger.LogDebug("Tokens saved to secure storage with key: {StorageKey}", storageKey);
            AppSettings settings = await _settingsService.LoadSettingsAsync();
            TwitchAccount? existingAccount = settings.Connections.TwitchAccounts.FirstOrDefault(a => a.UserId == userId);
            if (existingAccount != null)
            {
                _logger.LogDebug("Updating existing Twitch account in settings for Username: {Username}", username);
                existingAccount.Username = username;
                existingAccount.AutoConnect = true;
            }
            else
            {
                _logger.LogDebug("Adding new Twitch account to settings for Username: {Username}", username);
                settings.Connections.TwitchAccounts.Add(
                    new TwitchAccount
                    {
                        UserId = userId,
                        Username = username,
                        AutoConnect = true,
                    }
                );
            }
            await _settingsService.SaveSettingsAsync(settings);
            _logger.LogInformation("Authentication data saved successfully for Username: {Username}", username);
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error saving authentication data (tokens or settings) for User ID: {UserId}", userId);
            return false;
        }
    }
    public async Task<bool> RefreshTokenAsync(string userId)
    {
        _logger.LogInformation("Attempting to refresh token for Twitch User ID: {UserId}", userId);
        (string? ClientId, string? ClientSecret)? credentials = GetCredentialsFromSettings();
        if (credentials == null || credentials.Value.ClientId == null || credentials.Value.ClientSecret == null)
        {
            _logger.LogError("Cannot refresh token for User ID {UserId}: Client credentials missing or invalid.", userId);
            return false;
        }
        string storageKey = $"twitch_{userId}";
        (string? _, string? RefreshToken) = await _tokenStorage.GetTokensAsync(storageKey);
        if (string.IsNullOrEmpty(RefreshToken))
        {
            _logger.LogWarning("No refresh token found for User ID: {UserId}. Cannot refresh. User may need to log in again.", userId);
            return false;
        }
        string tokenEndpoint = "https://id.twitch.tv/oauth2/token";
        var content = new FormUrlEncodedContent(
            new Dictionary<string, string>
            {
                { "client_id", credentials.Value.ClientId },
                { "client_secret", credentials.Value.ClientSecret },
                { "grant_type", "refresh_token" },
                { "refresh_token", RefreshToken },
            }
        );
        try
        {
            HttpResponseMessage response = await _httpClient.PostAsync(tokenEndpoint, content);
            string responseBody = await response.Content.ReadAsStringAsync();
            if (!response.IsSuccessStatusCode)
            {
                _logger.LogError(
                    "Error refreshing Twitch token for User ID {UserId}. Status: {StatusCode}, Response: {ResponseBody}",
                    userId,
                    response.StatusCode,
                    responseBody
                );
                if (response.StatusCode is HttpStatusCode.BadRequest or HttpStatusCode.Unauthorized)
                {
                    _logger.LogWarning("Refresh token for User ID {UserId} is likely invalid or revoked. Logging out account.", userId);
                    await LogoutAsync(userId);
                }
                return false;
            }
            _logger.LogInformation("Token refresh successful for User ID {UserId}. Parsing response...", userId);
            using JsonDocument jsonDoc = JsonDocument.Parse(responseBody);
            JsonElement root = jsonDoc.RootElement;
            string? newAccessToken = root.TryGetProperty("access_token", out JsonElement accessTokenElement) ? accessTokenElement.GetString() : null;
            string? newRefreshToken = root.TryGetProperty("refresh_token", out JsonElement refreshTokenElement)
                ? refreshTokenElement.GetString()
                : null;
            if (string.IsNullOrEmpty(newAccessToken) || string.IsNullOrEmpty(newRefreshToken))
            {
                _logger.LogError(
                    "Error parsing refresh response for User ID {UserId}: New access or refresh token missing. Response: {ResponseBody}",
                    userId,
                    responseBody
                );
                return false;
            }
            _logger.LogInformation("New tokens received for User ID {UserId}. Saving updated tokens...", userId);
            await _tokenStorage.SaveTokensAsync(storageKey, newAccessToken, newRefreshToken);
            _logger.LogInformation("Tokens updated successfully via refresh for User ID {UserId}.", userId);
            return true;
        }
        catch (JsonException jsonEx)
        {
            _logger.LogError(jsonEx, "Error parsing JSON response during token refresh for User ID {UserId}.", userId);
            return false;
        }
        catch (HttpRequestException httpEx)
        {
            _logger.LogError(httpEx, "HTTP network error during token refresh for User ID {UserId}.", userId);
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during token refresh for User ID {UserId}.", userId);
            return false;
        }
    }
    public async Task LogoutAsync(string userId)
    {
        _logger.LogInformation("Logging out Twitch User ID: {UserId}", userId);
        (string? ClientId, string? ClientSecret)? cred = GetCredentialsFromSettings();
        string storageKey = $"twitch_{userId}";
        (string? AccessToken, string? _) = await _tokenStorage.GetTokensAsync(storageKey);
        if (!string.IsNullOrEmpty(AccessToken) && !string.IsNullOrEmpty(cred?.ClientId))
        {
            string revokeEndpoint = "https://id.twitch.tv/oauth2/revoke";
            var content = new FormUrlEncodedContent(
                new Dictionary<string, string> { { "client_id", cred.Value.ClientId }, { "token", AccessToken } }
            );
            try
            {
                _logger.LogDebug("Attempting to revoke Twitch token for User ID {UserId}...", userId);
                HttpResponseMessage response = await _httpClient.PostAsync(revokeEndpoint, content);
                if (response.IsSuccessStatusCode)
                {
                    _logger.LogDebug(
                        "Token revoke request sent successfully (Status: {StatusCode}) for User ID {UserId}.",
                        response.StatusCode,
                        userId
                    );
                }
                else
                {
                    string responseBody = await response.Content.ReadAsStringAsync();
                    _logger.LogWarning(
                        "Token revoke request failed with status {StatusCode} for User ID {UserId}. Response: {ResponseBody}",
                        response.StatusCode,
                        userId,
                        responseBody
                    );
                }
            }
            catch (HttpRequestException httpEx)
            {
                _logger.LogWarning(httpEx, "HTTP network error while attempting to revoke token for User ID {UserId}. Continuing logout.", userId);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Error occurred during token revocation for User ID {UserId}. Continuing logout.", userId);
            }
        }
        else
        {
            _logger.LogDebug("Skipping token revocation for User ID {UserId}: Access token or Client ID missing.", userId);
        }
        _logger.LogDebug("Deleting locally stored tokens for key: {StorageKey}", storageKey);
        await _tokenStorage.DeleteTokensAsync(storageKey);
        try
        {
            AppSettings settings = await _settingsService.LoadSettingsAsync();
            TwitchAccount? accountToRemove = settings.Connections.TwitchAccounts.FirstOrDefault(a => a.UserId == userId);
            if (accountToRemove != null)
            {
                _logger.LogDebug("Removing account {Username} (ID: {UserId}) from settings.", accountToRemove.Username, userId);
                settings.Connections.TwitchAccounts.Remove(accountToRemove);
                await _settingsService.SaveSettingsAsync(settings);
                _logger.LogDebug("Account removed from settings successfully.");
            }
            else
            {
                _logger.LogDebug("Account for User ID {UserId} not found in settings, nothing to remove.", userId);
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error removing account from settings for User ID {UserId} during logout.", userId);
        }
        _logger.LogInformation("Logout process completed for User ID: {UserId}", userId);
    }
    public async Task<bool> ValidateAndRefreshAccessTokenAsync(string userId)
    {
        _logger.LogInformation("Validating token for Twitch User ID: {UserId}", userId);
        string storageKey = $"twitch_{userId}";
        (string? AccessToken, string? _) = await _tokenStorage.GetTokensAsync(storageKey);
        if (string.IsNullOrEmpty(AccessToken))
        {
            _logger.LogDebug("No access token found locally for User ID: {UserId}. Cannot validate.", userId);
            return false;
        }
        string validateEndpoint = "https://id.twitch.tv/oauth2/validate";
        try
        {
            using var request = new HttpRequestMessage(HttpMethod.Get, validateEndpoint);
            request.Headers.Authorization = new AuthenticationHeaderValue("OAuth", AccessToken);
            HttpResponseMessage response = await _httpClient.SendAsync(request);
            if (response.IsSuccessStatusCode)
            {
                _logger.LogDebug("Token for User ID {UserId} is currently valid.", userId);
                return true;
            }
            else if (response.StatusCode == HttpStatusCode.Unauthorized)
            {
                string responseBody = await response.Content.ReadAsStringAsync();
                _logger.LogInformation(
                    "Token for User ID {UserId} is invalid/expired (Status: {StatusCode}). Attempting refresh...",
                    userId,
                    response.StatusCode
                );
                _logger.LogDebug("Validation failure response: {ResponseBody}", responseBody);
                return await RefreshTokenAsync(userId);
            }
            else
            {
                string responseBody = await response.Content.ReadAsStringAsync();
                _logger.LogWarning(
                    "Unexpected validation response for User ID {UserId}. Status: {StatusCode}. Assuming token invalid, attempting refresh...",
                    userId,
                    response.StatusCode
                );
                _logger.LogDebug("Validation failure response: {ResponseBody}", responseBody);
                return await RefreshTokenAsync(userId);
            }
        }
        catch (HttpRequestException httpEx)
        {
            _logger.LogWarning(httpEx, "HTTP network error during token validation for User ID {UserId}. Attempting refresh...", userId);
            return await RefreshTokenAsync(userId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during token validation for User ID {UserId}. Attempting refresh...", userId);
            return await RefreshTokenAsync(userId);
        }
    }
}
</file>

<file path="Core/Services/Authentication/YouTubeAuthService.cs">
using System.Net;
using System.Text;
using System.Web;
using Google.Apis.Auth.OAuth2;
using Google.Apis.Auth.OAuth2.Responses;
using Google.Apis.Json;
using Google.Apis.Services;
using Google.Apis.YouTube.v3;
using Google.Apis.YouTube.v3.Data;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Models.Settings;
using StreamWeaver.Core.Services.Settings;
using Windows.System;
namespace StreamWeaver.Core.Services.Authentication;
public record YouTubeAuthResult(bool Success, string? ChannelId = null, string? ChannelName = null, string? ErrorMessage = null);
public class YouTubeAuthService
{
    private readonly ISettingsService _settingsService;
    private readonly ITokenStorageService _tokenStorage;
    private readonly HttpClient _httpClient;
    private readonly ILogger<YouTubeAuthService> _logger;
    private const string GoogleRedirectUri = "http://localhost:5081/callback/google";
    private readonly string[] _scopes = [YouTubeService.Scope.YoutubeReadonly, YouTubeService.Scope.YoutubeForceSsl, YouTubeService.Scope.Youtube];
    private static string? s_oauthState;
    public YouTubeAuthService(ISettingsService settingsService, ITokenStorageService tokenStorage, ILogger<YouTubeAuthService> logger)
    {
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        _tokenStorage = tokenStorage ?? throw new ArgumentNullException(nameof(tokenStorage));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _httpClient = new HttpClient();
        _logger.LogInformation("Initialized. Callback URI: {CallbackUri}", GoogleRedirectUri);
    }
    public async Task<YouTubeAuthResult> AuthenticateAsync()
    {
        _logger.LogInformation("Starting YouTube authentication process...");
        (string? ClientId, string? ClientSecret)? credentials = GetCredentialsFromSettings();
        if (credentials == null || credentials.Value.ClientId == null || credentials.Value.ClientSecret == null)
        {
            const string errorMsg = "YouTube Client ID or Secret is missing or invalid in settings.";
            _logger.LogWarning(errorMsg);
            return new(false, ErrorMessage: errorMsg);
        }
        s_oauthState = Guid.NewGuid().ToString("N");
        _logger.LogDebug("Generated OAuth State: {OAuthState}", s_oauthState);
        string scopesString = string.Join(" ", _scopes);
        string authUrl =
            $"https://accounts.google.com/o/oauth2/v2/auth"
            + $"?client_id={credentials.Value.ClientId}"
            + $"&redirect_uri={Uri.EscapeDataString(GoogleRedirectUri)}"
            + $"&response_type=code"
            + $"&scope={Uri.EscapeDataString(scopesString)}"
            + $"&state={s_oauthState}"
            + $"&access_type=offline"
            + $"&prompt=consent select_account";
        string? authorizationCode = null;
        string? errorFromCallback = null;
        HttpListener? listener = null;
        try
        {
            _logger.LogInformation("Starting HttpListener on {RedirectUri}...", GoogleRedirectUri);
            listener = new HttpListener();
            listener.Prefixes.Add(GoogleRedirectUri.EndsWith('/') ? GoogleRedirectUri : GoogleRedirectUri + "/");
            listener.Start();
            _logger.LogInformation("Launching browser for Google/YouTube authentication: {AuthUrl}", authUrl);
            bool successLaunch = await Launcher.LaunchUriAsync(new Uri(authUrl));
            if (!successLaunch)
            {
                const string errorMsg = "Failed to launch the default system browser for authentication.";
                _logger.LogWarning(errorMsg);
                listener.Stop();
                return new(false, ErrorMessage: errorMsg);
            }
            _logger.LogInformation("Waiting for Google OAuth callback...");
            HttpListenerContext context = await listener.GetContextAsync().WaitAsync(TimeSpan.FromMinutes(3));
            HttpListenerRequest request = context.Request;
            HttpListenerResponse response = context.Response;
            try
            {
                _logger.LogDebug("Received callback: {CallbackUrl}", request.Url);
                string? receivedState = request.QueryString["state"];
                string? receivedCode = request.QueryString["code"];
                string? receivedError = request.QueryString["error"];
                string? receivedErrorDesc = request.QueryString["error_description"] ?? receivedError;
                if (!string.IsNullOrEmpty(receivedError))
                {
                    errorFromCallback = $"OAuth Error received from Google: {receivedErrorDesc}";
                    _logger.LogError("OAuth Error received from Google: {Error}", receivedErrorDesc);
                    await SendBrowserResponseAsync(
                        response,
                        $"<html><body>{HttpUtility.HtmlEncode(errorFromCallback)}. Please close this window.</body></html>",
                        HttpStatusCode.BadRequest
                    );
                }
                else if (string.IsNullOrEmpty(receivedState) || receivedState != s_oauthState)
                {
                    errorFromCallback = "OAuth state mismatch error. This could indicate a security issue.";
                    _logger.LogError("OAuth State mismatch! Expected: '{ExpectedState}', Received: '{ReceivedState}'", s_oauthState, receivedState);
                    await SendBrowserResponseAsync(
                        response,
                        $"<html><body>{HttpUtility.HtmlEncode(errorFromCallback)} Please close this window and try logging in again.</body></html>",
                        HttpStatusCode.BadRequest
                    );
                }
                else if (string.IsNullOrEmpty(receivedCode))
                {
                    errorFromCallback = "OAuth callback did not contain the required authorization code.";
                    _logger.LogError("OAuth callback did not contain the required authorization code.");
                    await SendBrowserResponseAsync(
                        response,
                        $"<html><body>{HttpUtility.HtmlEncode(errorFromCallback)} Please close this window.</body></html>",
                        HttpStatusCode.BadRequest
                    );
                }
                else
                {
                    authorizationCode = receivedCode;
                    _logger.LogInformation("OAuth authorization code received successfully.");
                    await SendBrowserResponseAsync(
                        response,
                        "<html><body>Authentication successful! You can close this window and return to StreamWeaver.</body></html>"
                    );
                }
                s_oauthState = null;
            }
            finally
            {
                response?.Close();
            }
        }
        catch (TimeoutException ex)
        {
            const string errorMsg = "Google OAuth callback timed out after 3 minutes. Please try again.";
            _logger.LogWarning(ex, errorMsg);
            s_oauthState = null;
            return new(false, ErrorMessage: errorMsg);
        }
        catch (ObjectDisposedException ode) when (ode.ObjectName == "System.Net.HttpListener")
        {
            const string errorMsg = "HttpListener was disposed while waiting for callback.";
            _logger.LogWarning(ode, errorMsg);
            s_oauthState = null;
            return new(false, ErrorMessage: errorMsg);
        }
        catch (HttpListenerException hle)
        {
            string errorMsg = $"HttpListener error during OAuth callback handling: {hle.Message}";
            _logger.LogError(hle, "HttpListener error during OAuth callback handling");
            s_oauthState = null;
            return new(false, ErrorMessage: errorMsg);
        }
        catch (Exception ex)
        {
            string errorMsg = $"An unexpected error occurred during the OAuth listener/callback phase: {ex.Message}";
            _logger.LogError(ex, "An unexpected error occurred during the OAuth listener/callback phase");
            s_oauthState = null;
            return new(false, ErrorMessage: errorMsg);
        }
        finally
        {
            if (listener?.IsListening ?? false)
            {
                listener.Stop();
                _logger.LogInformation("HttpListener stopped.");
            }
            listener?.Close();
        }
        if (!string.IsNullOrEmpty(errorFromCallback))
        {
            return new(false, ErrorMessage: errorFromCallback);
        }
        if (string.IsNullOrEmpty(authorizationCode))
        {
            const string errorMsg = "Authentication failed: No authorization code was received after the callback.";
            _logger.LogError(errorMsg);
            return new(false, ErrorMessage: errorMsg);
        }
        _logger.LogInformation("Exchanging Google authorization code for tokens...");
        TokenResponse? tokenResponse = await ExchangeCodeForYouTubeTokenAsync(
            authorizationCode,
            credentials.Value.ClientId,
            credentials.Value.ClientSecret
        );
        if (tokenResponse == null || string.IsNullOrEmpty(tokenResponse.AccessToken) || string.IsNullOrEmpty(tokenResponse.RefreshToken))
        {
            const string errorMsg = "Failed to exchange authorization code for tokens, or the response was missing required tokens (Access/Refresh).";
            _logger.LogError(errorMsg);
            return new(false, ErrorMessage: errorMsg);
        }
        _logger.LogInformation(
            "Tokens obtained successfully. Refresh token received: {HasRefreshToken}",
            !string.IsNullOrEmpty(tokenResponse.RefreshToken)
        );
        _logger.LogInformation("Fetching YouTube channel information...");
        (string? ChannelId, string? Title)? channelInfo = await GetAuthenticatedChannelInfoAsync(tokenResponse.AccessToken);
        if (channelInfo == null || string.IsNullOrEmpty(channelInfo.Value.ChannelId))
        {
            const string errorMsg =
                "Successfully authenticated with Google, but failed to retrieve valid YouTube channel information. Ensure the selected Google account has a YouTube channel.";
            _logger.LogWarning(errorMsg);
            return new(false, ErrorMessage: errorMsg);
        }
        _logger.LogInformation(
            "Successfully retrieved channel info - ID: {ChannelId}, Name: {ChannelName}",
            channelInfo.Value.ChannelId,
            channelInfo.Value.Title
        );
        string storageKey = $"youtube_{channelInfo.Value.ChannelId}";
        try
        {
            await _tokenStorage.SaveTokensAsync(storageKey, tokenResponse.AccessToken, tokenResponse.RefreshToken);
            _logger.LogInformation("Tokens saved securely with storage key: {StorageKey}", storageKey);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to save YouTube tokens securely for Channel ID {ChannelId}.", channelInfo.Value.ChannelId);
            return new(
                false,
                ChannelId: channelInfo.Value.ChannelId,
                ChannelName: channelInfo.Value.Title,
                ErrorMessage: $"Failed to save YouTube tokens securely for Channel ID {channelInfo.Value.ChannelId}."
            );
        }
        _logger.LogInformation(
            "YouTube authentication process completed successfully for Channel: {ChannelName} ({ChannelId})",
            channelInfo.Value.Title,
            channelInfo.Value.ChannelId
        );
        return new(true, channelInfo.Value.ChannelId, channelInfo.Value.Title);
    }
    private (string? ClientId, string? ClientSecret)? GetCredentialsFromSettings()
    {
        AppSettings settings = _settingsService.CurrentSettings;
        string? clientId = settings.Credentials?.YouTubeApiClientId;
        string? clientSecret = settings.Credentials?.YouTubeApiClientSecret;
        bool isInvalid =
            string.IsNullOrWhiteSpace(clientId)
            || string.IsNullOrWhiteSpace(clientSecret)
            || clientId.StartsWith("YOUR_")
            || clientId.Length < 10
            || clientSecret.StartsWith("YOUR_")
            || clientSecret.Length < 10;
        if (isInvalid)
        {
            _logger.LogWarning(
                "YouTube Client ID or Client Secret is missing, appears to be a placeholder, or is too short in application settings."
            );
            return null;
        }
        return (clientId, clientSecret);
    }
    private async Task SendBrowserResponseAsync(HttpListenerResponse response, string content, HttpStatusCode statusCode = HttpStatusCode.OK)
    {
        try
        {
            byte[] buffer = Encoding.UTF8.GetBytes(content);
            response.ContentLength64 = buffer.Length;
            response.ContentType = "text/html; charset=utf-8";
            response.StatusCode = (int)statusCode;
            using Stream output = response.OutputStream;
            await output.WriteAsync(buffer);
            _logger.LogDebug("Sent HTTP {StatusCode} response to browser callback.", statusCode);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to send HTTP response back to browser via HttpListener.");
        }
    }
    private async Task<TokenResponse?> ExchangeCodeForYouTubeTokenAsync(string code, string clientId, string clientSecret)
    {
        string tokenEndpoint = GoogleAuthConsts.TokenUrl;
        var content = new FormUrlEncodedContent(
            new Dictionary<string, string>
            {
                { "client_id", clientId },
                { "client_secret", clientSecret },
                { "code", code },
                { "grant_type", "authorization_code" },
                { "redirect_uri", GoogleRedirectUri },
            }
        );
        try
        {
            HttpResponseMessage response = await _httpClient.PostAsync(tokenEndpoint, content);
            string responseBody = await response.Content.ReadAsStringAsync();
            if (!response.IsSuccessStatusCode)
            {
                _logger.LogError(
                    "Error exchanging Google code for token. Status: {StatusCode}, Response: {ResponseBody}",
                    response.StatusCode,
                    responseBody
                );
                return null;
            }
            _logger.LogDebug("Google token exchange successful. Parsing response...");
            TokenResponse? tokenResponse = NewtonsoftJsonSerializer.Instance.Deserialize<TokenResponse>(responseBody);
            if (tokenResponse == null || string.IsNullOrEmpty(tokenResponse.AccessToken))
            {
                _logger.LogError("Failed to parse token response or access token was missing. Response Body: {ResponseBody}", responseBody);
                return null;
            }
            if (string.IsNullOrEmpty(tokenResponse.RefreshToken))
            {
                _logger.LogWarning(
                    "Refresh token was missing from the initial token exchange response. Offline access might not be possible later. Response Body: {ResponseBody}",
                    responseBody
                );
            }
            return tokenResponse;
        }
        catch (HttpRequestException httpEx)
        {
            _logger.LogError(httpEx, "HTTP network error during Google token exchange.");
            return null;
        }
        catch (Newtonsoft.Json.JsonException jsonEx)
        {
            _logger.LogError(jsonEx, "Error parsing JSON response during Google token exchange.");
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during Google token exchange.");
            return null;
        }
    }
    private async Task<(string? Id, string? Title)?> GetAuthenticatedChannelInfoAsync(string accessToken)
    {
        _logger.LogDebug("Fetching authenticated user's YouTube channel info via API...");
        try
        {
            GoogleCredential credential = GoogleCredential.FromAccessToken(accessToken);
            using var youtubeService = new YouTubeService(
                new BaseClientService.Initializer() { HttpClientInitializer = credential, ApplicationName = "StreamWeaver" }
            );
            ChannelsResource.ListRequest request = youtubeService.Channels.List("snippet");
            request.Mine = true;
            ChannelListResponse? response = await request.ExecuteAsync();
            Channel? channel = response?.Items?.FirstOrDefault();
            if (channel != null && !string.IsNullOrEmpty(channel.Id) && !string.IsNullOrEmpty(channel.Snippet?.Title))
            {
                _logger.LogDebug("Found YouTube channel: ID={ChannelId}, Title={ChannelTitle}", channel.Id, channel.Snippet.Title);
                return (channel.Id, channel.Snippet.Title);
            }
            else
            {
                _logger.LogWarning(
                    "Could not find valid channel ID or Title in YouTube API response for the authenticated user (mine=true). The Google account might not have a YouTube channel."
                );
                _logger.LogDebug("YouTube API response items count: {ItemCount}", response?.Items?.Count ?? 0);
                return null;
            }
        }
        catch (Google.GoogleApiException apiEx)
        {
            _logger.LogError(
                apiEx,
                "Google API error fetching YouTube channel info. Status: {StatusCode}, Message: {ErrorMessage}",
                apiEx.HttpStatusCode,
                apiEx.Message
            );
            if (apiEx.HttpStatusCode is HttpStatusCode.Unauthorized or HttpStatusCode.Forbidden)
            {
                _logger.LogWarning("--> Access token might be invalid, expired, or lack necessary permissions.");
            }
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error while fetching YouTube channel info.");
            return null;
        }
    }
    public async Task<bool> RefreshTokenAsync(string channelId)
    {
        _logger.LogInformation("Attempting to refresh Google token for YouTube Channel ID: {ChannelId}", channelId);
        (string? ClientId, string? ClientSecret)? credentials = GetCredentialsFromSettings();
        if (credentials == null || credentials.Value.ClientId == null || credentials.Value.ClientSecret == null)
        {
            _logger.LogError("Cannot refresh token for Channel ID {ChannelId}: Client credentials missing or invalid.", channelId);
            return false;
        }
        string storageKey = $"youtube_{channelId}";
        (string? _, string? RefreshToken) = await _tokenStorage.GetTokensAsync(storageKey);
        if (string.IsNullOrEmpty(RefreshToken))
        {
            _logger.LogWarning(
                "No refresh token found stored for Channel ID: {ChannelId}. Cannot refresh. User needs to re-authenticate.",
                channelId
            );
            return false;
        }
        string tokenEndpoint = GoogleAuthConsts.TokenUrl;
        var content = new FormUrlEncodedContent(
            new Dictionary<string, string>
            {
                { "client_id", credentials.Value.ClientId },
                { "client_secret", credentials.Value.ClientSecret },
                { "refresh_token", RefreshToken },
                { "grant_type", "refresh_token" },
            }
        );
        try
        {
            HttpResponseMessage response = await _httpClient.PostAsync(tokenEndpoint, content);
            string responseBody = await response.Content.ReadAsStringAsync();
            if (!response.IsSuccessStatusCode)
            {
                _logger.LogError(
                    "Error refreshing Google token for Channel ID {ChannelId}. Status: {StatusCode}, Response: {ResponseBody}",
                    channelId,
                    response.StatusCode,
                    responseBody
                );
                if (response.StatusCode is HttpStatusCode.BadRequest or HttpStatusCode.Unauthorized && responseBody.Contains("invalid_grant"))
                {
                    _logger.LogWarning(
                        "Refresh token for Channel ID {ChannelId} is invalid or revoked ('invalid_grant'). Performing local logout.",
                        channelId
                    );
                    await LogoutAsync(channelId);
                }
                return false;
            }
            _logger.LogInformation("Google token refresh successful for Channel ID {ChannelId}. Parsing response...", channelId);
            TokenResponse? tokenResponse = NewtonsoftJsonSerializer.Instance.Deserialize<TokenResponse>(responseBody);
            if (string.IsNullOrEmpty(tokenResponse?.AccessToken))
            {
                _logger.LogError(
                    "Failed to parse refresh response or new access token was missing for Channel ID {ChannelId}. Response Body: {ResponseBody}",
                    channelId,
                    responseBody
                );
                return false;
            }
            string? newRefreshTokenToStore = tokenResponse.RefreshToken ?? RefreshToken;
            bool receivedNewRefreshToken = tokenResponse.RefreshToken != null;
            _logger.LogDebug("New access token received. Received new refresh token: {ReceivedNewRefreshToken}", receivedNewRefreshToken);
            _logger.LogInformation("Saving updated tokens from refresh for Channel ID {ChannelId}...", channelId);
            await _tokenStorage.SaveTokensAsync(storageKey, tokenResponse.AccessToken, newRefreshTokenToStore);
            _logger.LogInformation("Tokens updated successfully via refresh for Channel ID {ChannelId}.", channelId);
            return true;
        }
        catch (HttpRequestException httpEx)
        {
            _logger.LogError(httpEx, "HTTP network error during Google token refresh for Channel ID {ChannelId}.", channelId);
            return false;
        }
        catch (Newtonsoft.Json.JsonException jsonEx)
        {
            _logger.LogError(jsonEx, "Error parsing JSON response during Google token refresh for Channel ID {ChannelId}.", channelId);
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during Google token refresh for Channel ID {ChannelId}.", channelId);
            return false;
        }
    }
    public async Task LogoutAsync(string channelId)
    {
        _logger.LogInformation("Logging out YouTube Channel ID: {ChannelId}", channelId);
        string storageKey = $"youtube_{channelId}";
        (string? AccessToken, string? RefreshToken) = await _tokenStorage.GetTokensAsync(storageKey);
        string? tokenToRevoke = RefreshToken ?? AccessToken;
        if (!string.IsNullOrEmpty(tokenToRevoke))
        {
            string revokeEndpoint = GoogleAuthConsts.RevokeTokenUrl;
            var content = new FormUrlEncodedContent(new Dictionary<string, string> { { "token", tokenToRevoke } });
            try
            {
                _logger.LogDebug("Attempting to revoke Google token (Refresh or Access) for Channel ID {ChannelId}...", channelId);
                HttpResponseMessage response = await _httpClient.PostAsync(revokeEndpoint, content);
                if (response.IsSuccessStatusCode)
                {
                    _logger.LogInformation(
                        "Google token revoke request sent successfully (Status: {StatusCode}) for Channel ID {ChannelId}.",
                        response.StatusCode,
                        channelId
                    );
                }
                else
                {
                    string responseBody = await response.Content.ReadAsStringAsync();
                    _logger.LogWarning(
                        "Google token revoke request failed with status {StatusCode} for Channel ID {ChannelId}. Response: {ResponseBody}",
                        response.StatusCode,
                        channelId,
                        responseBody
                    );
                }
            }
            catch (HttpRequestException httpEx)
            {
                _logger.LogWarning(
                    httpEx,
                    "HTTP network error while attempting to revoke Google token for Channel ID {ChannelId}. Continuing local logout.",
                    channelId
                );
            }
            catch (Exception ex)
            {
                _logger.LogWarning(
                    ex,
                    "Error occurred during Google token revocation for Channel ID {ChannelId}. Continuing local logout.",
                    channelId
                );
            }
        }
        else
        {
            _logger.LogDebug("Skipping Google token revocation for Channel ID {ChannelId}: No access or refresh token found locally.", channelId);
        }
        _logger.LogDebug("Deleting locally stored tokens for key: {StorageKey}", storageKey);
        await _tokenStorage.DeleteTokensAsync(storageKey);
        _logger.LogInformation("Local token cleanup complete for YouTube Channel ID: {ChannelId}.", channelId);
    }
    public async Task<bool> ValidateAndRefreshAccessTokenAsync(string channelId)
    {
        _logger.LogInformation("Validating Google token for YouTube Channel ID: {ChannelId}", channelId);
        string storageKey = $"youtube_{channelId}";
        (string? AccessToken, string? RefreshToken) = await _tokenStorage.GetTokensAsync(storageKey);
        if (string.IsNullOrEmpty(AccessToken))
        {
            _logger.LogDebug("No access token found locally for Channel ID: {ChannelId}.", channelId);
            if (!string.IsNullOrEmpty(RefreshToken))
            {
                _logger.LogInformation(
                    "No access token found, but refresh token exists. Attempting refresh for Channel ID {ChannelId}...",
                    channelId
                );
                return await RefreshTokenAsync(channelId);
            }
            else
            {
                _logger.LogWarning("No access or refresh token found locally for Channel ID {ChannelId}. Cannot validate or refresh.", channelId);
                return false;
            }
        }
        string validateEndpoint = $"{GoogleAuthConsts.TokenInfoUrl}?access_token={Uri.EscapeDataString(AccessToken)}";
        try
        {
            HttpResponseMessage response = await _httpClient.GetAsync(validateEndpoint);
            string responseBody = await response.Content.ReadAsStringAsync();
            if (response.IsSuccessStatusCode)
            {
                _logger.LogDebug("Token for Channel ID {ChannelId} is valid according to tokeninfo endpoint.", channelId);
                return true;
            }
            else if (response.StatusCode is HttpStatusCode.BadRequest or HttpStatusCode.Unauthorized)
            {
                _logger.LogInformation(
                    "Token validation failed for Channel ID {ChannelId} (Status: {StatusCode}). Assuming invalid/expired. Attempting refresh...",
                    channelId,
                    response.StatusCode
                );
                _logger.LogDebug("Tokeninfo failure response: {ResponseBody}", responseBody);
                return await RefreshTokenAsync(channelId);
            }
            else
            {
                _logger.LogWarning(
                    "Unexpected token validation response for Channel ID {ChannelId}. Status: {StatusCode}. Assuming invalid, attempting refresh...",
                    channelId,
                    response.StatusCode
                );
                _logger.LogDebug("Tokeninfo failure response: {ResponseBody}", responseBody);
                return await RefreshTokenAsync(channelId);
            }
        }
        catch (HttpRequestException httpEx)
        {
            _logger.LogWarning(httpEx, "HTTP network error during token validation for Channel ID {ChannelId}. Attempting refresh...", channelId);
            return await RefreshTokenAsync(channelId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during token validation for Channel ID {ChannelId}. Attempting refresh...", channelId);
            return await RefreshTokenAsync(channelId);
        }
    }
}
internal static class GoogleAuthConsts
{
    public const string TokenUrl = "https://oauth2.googleapis.com/token";
    public const string RevokeTokenUrl = "https://oauth2.googleapis.com/revoke";
    public const string TokenInfoUrl = "https://www.googleapis.com/oauth2/v3/tokeninfo";
    public const string AuthorizationUrl = "https://accounts.google.com/o/oauth2/v2/auth";
}
</file>

<file path="Core/Services/IEmoteBadgeService.cs">
using StreamWeaver.Core.Models.Events.Messages;
namespace StreamWeaver.Core.Services;
public interface IEmoteBadgeService
{
    Task LoadGlobalTwitchDataAsync();
    Task LoadChannelTwitchDataAsync(string channelId, string userAccountId);
    string? GetTwitchBadgeUrl(string badgeSetId, string badgeVersionId);
    List<MessageSegment> ParseYouTubeMessage(string rawMessage);
    Task<string?> GetYouTubeStickerUrlAsync(string stickerId);
}
</file>

<file path="Core/Services/Logging/ObservableLogger.cs">
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Models;
namespace StreamWeaver.Core.Services.Logging;
public sealed class ObservableLogger(string categoryName, LogViewerService logViewerService) : ILogger
{
    private readonly string _categoryName = categoryName;
    private readonly LogViewerService _logViewerService = logViewerService;
    public IDisposable? BeginScope<TState>(TState state)
        where TState : notnull => default!;
    public bool IsEnabled(LogLevel logLevel) =>
        logLevel != LogLevel.None;
    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        if (!IsEnabled(logLevel))
        {
            return;
        }
        string message = formatter(state, exception);
        LogEntry entry = new(Timestamp: DateTime.Now, Level: logLevel, Category: _categoryName, Message: message, Exception: exception);
        _logViewerService.AddLogEntry(entry);
    }
}
</file>

<file path="Core/Services/Logging/ObservableLoggerProvider.cs">
using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
namespace StreamWeaver.Core.Services.Logging;
[ProviderAlias("Observable")]
public sealed partial class ObservableLoggerProvider(LogViewerService logViewerService) : ILoggerProvider
{
    private readonly LogViewerService _logViewerService = logViewerService;
    private readonly ConcurrentDictionary<string, ObservableLogger> _loggers = new(StringComparer.OrdinalIgnoreCase);
    public ILogger CreateLogger(string categoryName) => _loggers.GetOrAdd(categoryName, name => new ObservableLogger(name, _logViewerService));
    public void Dispose()
    {
        _loggers.Clear();
        GC.SuppressFinalize(this);
    }
}
</file>

<file path="Core/Services/LogViewerService.cs">
using System.Collections.ObjectModel;
using Microsoft.UI.Dispatching;
using StreamWeaver.Core.Models;
namespace StreamWeaver.Core.Services;
public class LogViewerService
{
    private const int MAX_LOG_ENTRIES = 500;
    private readonly DispatcherQueue _dispatcherQueue;
    public ObservableCollection<LogEntry> LogEntries { get; } = [];
    public LogViewerService() =>
        _dispatcherQueue =
            DispatcherQueue.GetForCurrentThread() ?? throw new InvalidOperationException("LogViewerService must be initialized on the UI thread.");
    public void AddLogEntry(LogEntry entry) =>
        _dispatcherQueue.TryEnqueue(() =>
        {
            LogEntries.Add(entry);
            while (LogEntries.Count > MAX_LOG_ENTRIES)
            {
                LogEntries.RemoveAt(0);
            }
        });
    public void ClearLogs() => _dispatcherQueue.TryEnqueue(LogEntries.Clear);
}
</file>

<file path="Core/Services/Platforms/IStreamlabsClient.cs">
using StreamWeaver.Core.Models.Settings;
namespace StreamWeaver.Core.Services.Platforms;
public interface IStreamlabsClient
{
    ConnectionStatus Status { get; }
    string? StatusMessage { get; }
    Task<bool> ConnectAsync(string socketToken);
    Task DisconnectAsync();
}
</file>

<file path="Core/Services/Platforms/ITwitchClient.cs">
using StreamWeaver.Core.Models.Settings;
namespace StreamWeaver.Core.Services.Platforms;
public interface ITwitchClient
{
    Task<bool> ConnectAsync(string accountId, string username, string accessToken);
    Task DisconnectAsync(string accountId);
    Task JoinChannelAsync(string accountId, string channelName);
    Task LeaveChannelAsync(string accountId, string channelName);
    Task SendMessageAsync(string accountId, string channelName, string message);
    ConnectionStatus GetStatus(string accountId);
    string? GetStatusMessage(string accountId);
}
</file>

<file path="Core/Services/Platforms/IYouTubeClient.cs">
using StreamWeaver.Core.Models.Settings;
namespace StreamWeaver.Core.Services.Platforms;
public interface IYouTubeClient
{
    Task<bool> ConnectAsync(string accountId, string accessToken);
    Task DisconnectAsync(string accountId);
    Task<string?> FindActiveVideoIdAsync(string accountId);
    Task StartPollingAsync(string accountId, string videoId);
    Task StopPollingAsync(string accountId);
    Task SendMessageAsync(string accountId, string liveChatId, string message);
    ConnectionStatus GetStatus(string accountId);
    string? GetStatusMessage(string accountId);
    string? GetActiveVideoId(string accountId);
    string? GetAssociatedLiveChatId(string accountId);
    Task<string?> LookupAndStoreLiveChatIdAsync(string accountId, string videoId);
    Task DeleteMessageAsync(string moderatorAccountId, string messageId);
    Task TimeoutUserAsync(string moderatorAccountId, string liveChatId, string userIdToTimeout, uint durationSeconds);
    Task BanUserAsync(string moderatorAccountId, string liveChatId, string userIdToBan);
    Task<string?> CreatePollAsync(string moderatorAccountId, string liveChatId, string question, List<string> options);
    Task<bool> EndPollAsync(string moderatorAccountId, string pollMessageId, string status = "ended");
}
</file>

<file path="Core/Services/Platforms/TwitchApiService.cs">
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Services.Authentication;
using StreamWeaver.Core.Services.Settings;
using TwitchLib.Api;
using TwitchLib.Api.Core.Exceptions;
using TwitchLib.Api.Helix.Models.Chat.Badges.GetChannelChatBadges;
using TwitchLib.Api.Helix.Models.Chat.Badges.GetGlobalChatBadges;
using TwitchLib.Api.Helix.Models.Chat.Emotes.GetChannelEmotes;
using TwitchLib.Api.Helix.Models.Chat.Emotes.GetGlobalEmotes;
using TwitchLib.Api.Helix.Models.Users.GetUsers;
namespace StreamWeaver.Core.Services.Platforms;
public class TwitchApiService
{
    private readonly ISettingsService _settingsService;
    private readonly ITokenStorageService _tokenStorage;
    private readonly ILogger<TwitchApiService> _logger;
    private TwitchAPI? _api;
    private static string? s_appAccessToken;
    private static DateTimeOffset s_appAccessTokenExpiry;
    public TwitchApiService(ISettingsService settingsService, ITokenStorageService tokenStorage, ILogger<TwitchApiService> logger)
    {
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        _tokenStorage = tokenStorage ?? throw new ArgumentNullException(nameof(tokenStorage));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _logger.LogInformation("Initialized.");
    }
    private async Task<TwitchAPI?> EnsureApiInitializedAsync(string? userAccountId = null)
    {
        string? clientId = _settingsService.CurrentSettings.Credentials.TwitchApiClientId;
        string? clientSecret = _settingsService.CurrentSettings.Credentials.TwitchApiClientSecret;
        if (
            string.IsNullOrWhiteSpace(clientId)
            || clientId.StartsWith("YOUR_")
            || string.IsNullOrWhiteSpace(clientSecret)
            || clientSecret.StartsWith("YOUR_")
        )
        {
            _logger.LogError("Cannot initialize Twitch API: Client ID or Secret is missing or appears invalid in settings.");
            return null;
        }
        _api ??= new TwitchAPI();
        _api.Settings.ClientId = clientId;
        _api.Settings.Secret = clientSecret;
        if (!string.IsNullOrEmpty(userAccountId))
        {
            string storageKey = $"twitch_{userAccountId}";
            _logger.LogDebug("Attempting to retrieve user token for Account ID: {UserAccountId} using key: {StorageKey}", userAccountId, storageKey);
            (string? userAccessToken, _) = await _tokenStorage.GetTokensAsync(storageKey);
            if (!string.IsNullOrEmpty(userAccessToken))
            {
                _api.Settings.AccessToken = userAccessToken;
                _logger.LogDebug("Using User Access Token for Account ID: {UserAccountId}.", userAccountId);
                return _api;
            }
            else
            {
                _logger.LogWarning(
                    "User token requested for Account ID {UserAccountId}, but none found in storage. Falling back to App Access Token.",
                    userAccountId
                );
            }
        }
        else
        {
            _logger.LogDebug("No specific User Account ID provided, attempting to use App Access Token.");
        }
        if (s_appAccessToken == null || s_appAccessTokenExpiry <= DateTimeOffset.UtcNow.AddMinutes(5))
        {
            _logger.LogInformation("App Access Token is missing, null, or expiring soon. Requesting new token...");
            try
            {
                string newAppAccessToken = await _api.Auth.GetAccessTokenAsync();
                if (!string.IsNullOrEmpty(newAppAccessToken))
                {
                    s_appAccessToken = newAppAccessToken;
                    s_appAccessTokenExpiry = DateTimeOffset.UtcNow.AddDays(50);
                    _api.Settings.AccessToken = s_appAccessToken;
                    _logger.LogInformation("Obtained and cached new App Access Token. Expires around: {ExpiryDate}", s_appAccessTokenExpiry);
                }
                else
                {
                    _logger.LogError("Failed to obtain a new App Access Token from Twitch API (response was null or empty).");
                    _api.Settings.AccessToken = null;
                    s_appAccessToken = null;
                    return null;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error occurred while obtaining App Access Token: {ErrorMessage}", ex.Message);
                _api.Settings.AccessToken = null;
                s_appAccessToken = null;
                return null;
            }
        }
        else
        {
            _api.Settings.AccessToken = s_appAccessToken;
            _logger.LogDebug("Using cached App Access Token.");
        }
        return _api;
    }
    public async Task<GetGlobalChatBadgesResponse?> GetGlobalBadgesAsync()
    {
        TwitchAPI? api = await EnsureApiInitializedAsync();
        if (api == null || string.IsNullOrEmpty(api.Settings.AccessToken))
        {
            _logger.LogWarning("Cannot get global badges: API client or App Access Token not available.");
            return null;
        }
        try
        {
            _logger.LogInformation("Fetching Global Twitch Chat Badges...");
            GetGlobalChatBadgesResponse? response = await api.Helix.Chat.GetGlobalChatBadgesAsync(api.Settings.AccessToken);
            _logger.LogDebug("Successfully fetched global badges. Set count: {SetCount}", response?.EmoteSet?.Length ?? 0);
            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching global Twitch badges: {ErrorMessage}", ex.Message);
            return null;
        }
    }
    public async Task<GetChannelChatBadgesResponse?> GetChannelBadgesAsync(string broadcasterId, string userAccountId)
    {
        TwitchAPI? api = await EnsureApiInitializedAsync(userAccountId);
        if (api == null || string.IsNullOrEmpty(api.Settings.AccessToken))
        {
            _logger.LogWarning(
                "Cannot get channel badges for Broadcaster ID {BroadcasterId}: API client or required User Access Token (for User ID {UserAccountId}) not available.",
                broadcasterId,
                userAccountId
            );
            return null;
        }
        try
        {
            _logger.LogInformation(
                "Fetching Channel Twitch Chat Badges for Broadcaster ID: {BroadcasterId} (using token for User ID: {UserAccountId})",
                broadcasterId,
                userAccountId
            );
            GetChannelChatBadgesResponse? response = await api.Helix.Chat.GetChannelChatBadgesAsync(broadcasterId, api.Settings.AccessToken);
            _logger.LogDebug(
                "Successfully fetched channel badges for {BroadcasterId}. Set count: {SetCount}",
                broadcasterId,
                response?.EmoteSet?.Length ?? 0
            );
            return response;
        }
        catch (BadScopeException bse)
        {
            _logger.LogError(
                bse,
                "Authorization error (Bad Scope) fetching channel badges for {BroadcasterId}. User token may lack required permissions. Message: {ErrorMessage}",
                broadcasterId,
                bse.Message
            );
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex,
                "Error fetching channel Twitch badges for Broadcaster ID {BroadcasterId}: {ErrorMessage}",
                broadcasterId,
                ex.Message
            );
            return null;
        }
    }
    public async Task<GetGlobalEmotesResponse?> GetGlobalEmotesAsync()
    {
        TwitchAPI? api = await EnsureApiInitializedAsync();
        if (api == null || string.IsNullOrEmpty(api.Settings.AccessToken))
        {
            _logger.LogWarning("Cannot get global emotes: API client or App Access Token not available.");
            return null;
        }
        try
        {
            _logger.LogInformation("Fetching Global Twitch Emotes...");
            GetGlobalEmotesResponse? response = await api.Helix.Chat.GetGlobalEmotesAsync(api.Settings.AccessToken);
            _logger.LogDebug("Successfully fetched global emotes. Count: {EmoteCount}", response?.GlobalEmotes?.Length ?? 0);
            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching global Twitch emotes: {ErrorMessage}", ex.Message);
            return null;
        }
    }
    public async Task<GetChannelEmotesResponse?> GetChannelEmotesAsync(string broadcasterId, string userAccountId)
    {
        TwitchAPI? api = await EnsureApiInitializedAsync(userAccountId);
        if (api == null || string.IsNullOrEmpty(api.Settings.AccessToken))
        {
            _logger.LogWarning(
                "Cannot get channel emotes for Broadcaster ID {BroadcasterId}: API client or required User Access Token (for User ID {UserAccountId}) not available.",
                broadcasterId,
                userAccountId
            );
            return null;
        }
        try
        {
            _logger.LogInformation(
                "Fetching Channel Twitch Emotes for Broadcaster ID: {BroadcasterId} (using token for User ID: {UserAccountId})",
                broadcasterId,
                userAccountId
            );
            GetChannelEmotesResponse? response = await api.Helix.Chat.GetChannelEmotesAsync(broadcasterId, api.Settings.AccessToken);
            _logger.LogDebug(
                "Successfully fetched channel emotes for {BroadcasterId}. Count: {EmoteCount}",
                broadcasterId,
                response?.ChannelEmotes?.Length ?? 0
            );
            return response;
        }
        catch (BadScopeException bse)
        {
            _logger.LogError(
                bse,
                "Authorization error (Bad Scope) fetching channel emotes for {BroadcasterId}. User token may lack required permissions. Message: {ErrorMessage}",
                broadcasterId,
                bse.Message
            );
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex,
                "Error fetching channel Twitch emotes for Broadcaster ID {BroadcasterId}: {ErrorMessage}",
                broadcasterId,
                ex.Message
            );
            return null;
        }
    }
    public async Task<User?> GetUserInfoAsync(string loginName, string? requestingUserAccountId = null)
    {
        if (string.IsNullOrWhiteSpace(loginName))
        {
            _logger.LogWarning("GetUserInfoAsync called with null or empty login name.");
            return null;
        }
        TwitchAPI? api = await EnsureApiInitializedAsync(requestingUserAccountId);
        if (api == null || string.IsNullOrEmpty(api.Settings.AccessToken))
        {
            _logger.LogWarning("Cannot get user info for Login Name '{LoginName}': API client or required Access Token not available.", loginName);
            return null;
        }
        try
        {
            _logger.LogDebug("Requesting user info from Twitch API for Login Name: {LoginName}", loginName);
            GetUsersResponse? usersResponse = await api.Helix.Users.GetUsersAsync(
                logins: [loginName.ToLowerInvariant()],
                accessToken: api.Settings.AccessToken
            );
            User? user = usersResponse?.Users.FirstOrDefault();
            if (user != null)
            {
                _logger.LogDebug("Successfully retrieved user info for Login Name {LoginName}. User ID: {UserId}", loginName, user.Id);
            }
            else
            {
                _logger.LogWarning("User info not found for Login Name {LoginName}.", loginName);
            }
            return user;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting Twitch user info for Login Name {LoginName}: {ErrorMessage}", loginName, ex.Message);
            return null;
        }
    }
}
</file>

<file path="Core/Services/Settings/ISettingsService.cs">
using StreamWeaver.Core.Models.Settings;
namespace StreamWeaver.Core.Services.Settings;
public interface ISettingsService
{
    Task<AppSettings> LoadSettingsAsync();
    Task SaveSettingsAsync(AppSettings settings);
    AppSettings CurrentSettings { get; }
    event EventHandler SettingsUpdated;
}
</file>

<file path="Core/Services/Tts/IEngineSpecificTtsService.cs">
namespace StreamWeaver.Core.Services.Tts;
public interface IEngineSpecificTtsService : IDisposable
{
    string EngineId { get; }
    Task InitializeAsync();
    Task<IEnumerable<string>> GetInstalledVoicesAsync();
    void SetVoice(string voiceName);
    void SetRate(int rate);
    void SetVolume(int volume);
    Task SpeakAsync(string textToSpeak);
}
</file>

<file path="Core/Services/Web/WebServerService.cs">
using System.Net.WebSockets;
using System.Text.Json;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.FileProviders;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Plugins;
using StreamWeaver.Core.Services.Settings;
namespace StreamWeaver.Core.Services.Web;
public partial class WebServerService(
    ILogger<WebServerService> logger,
    IServiceProvider serviceProvider,
    ISettingsService settingsService,
    WebSocketManager webSocketManager
    ) : IDisposable
{
    private readonly ILogger<WebServerService> _logger = logger;
    private readonly IServiceProvider _serviceProvider = serviceProvider;
    private readonly ISettingsService _settingsService = settingsService;
    private readonly WebSocketManager _webSocketManager = webSocketManager;
    private WebApplication? _webApp;
    private CancellationTokenSource? _cts;
    private string _reactAppDistPath = string.Empty;
    private string _pluginsWebPath = string.Empty;
    private List<WebPluginManifest> _discoveredWebPlugins = [];
    private bool _isDisposed;
    public IEnumerable<WebPluginManifest> DiscoveredWebPlugins => _discoveredWebPlugins;
    private static readonly JsonSerializerOptions s_manifestSerializerOptions = new()
    {
        PropertyNameCaseInsensitive = true,
        AllowTrailingCommas = true
    };
    public async Task StartAsync()
    {
        if (_webApp != null)
        {
            _logger.LogInformation("Start requested but web server is already running.");
            return;
        }
        _cts = new CancellationTokenSource();
        Models.Settings.AppSettings settings = await _settingsService.LoadSettingsAsync();
        int port = settings.Overlays.WebServerPort;
        DetermineWebPaths();
        if (string.IsNullOrEmpty(_reactAppDistPath) || !Directory.Exists(_reactAppDistPath))
        {
            _logger.LogCritical("React app distribution directory not found at '{ReactAppDistPath}'. Overlays will not work.", _reactAppDistPath);
            _cts.Dispose();
            _cts = null;
            return;
        }
        _discoveredWebPlugins = DiscoverWebPlugins();
        _logger.LogInformation("Starting web server on port {Port}...", port);
        _logger.LogInformation("Serving React App from: {ReactAppDistPath}", _reactAppDistPath);
        _logger.LogInformation("Serving Web Plugins from base: {PluginsWebPath}", _pluginsWebPath);
        _logger.LogInformation("Discovered {PluginCount} valid web plugins.", _discoveredWebPlugins.Count);
        try
        {
            WebApplicationBuilder builder = WebApplication.CreateBuilder();
            builder.WebHost.UseKestrel(options =>
            {
                options.ListenLocalhost(port);
                _logger.LogInformation("Kestrel configured to listen on http://localhost:{Port}", port);
            });
            builder.Logging.ClearProviders();
#if DEBUG
            builder.Logging.AddDebug();
#endif
            builder.Logging.SetMinimumLevel(LogLevel.Warning);
            builder.Services.AddSingleton(_webSocketManager);
            builder.Services.AddSingleton(_settingsService);
            builder.Services.AddSingleton(this);
            _webApp = builder.Build();
            _webApp.UseWebSockets();
            _webApp.Map("/ws", HandleWebSocketConnection);
            var reactAppProvider = new PhysicalFileProvider(_reactAppDistPath);
            _webApp.UseStaticFiles(new StaticFileOptions
            {
                FileProvider = reactAppProvider,
                RequestPath = "" // Serve from root
            });
            _logger.LogInformation("Configured static files for React app from {Path}", _reactAppDistPath);
            // Serve Static Files for each discovered Web Plugin
            foreach (WebPluginManifest plugin in _discoveredWebPlugins)
            {
                if (!string.IsNullOrEmpty(plugin.DirectoryPath) && !string.IsNullOrEmpty(plugin.BasePath))
                {
                    var pluginProvider = new PhysicalFileProvider(plugin.DirectoryPath);
                    _webApp.UseStaticFiles(new StaticFileOptions
                    {
                        FileProvider = pluginProvider,
                        RequestPath = plugin.BasePath // Serve under /plugins/{pluginId}
                    });
                    _logger.LogInformation("Configured static files for plugin '{PluginName}' from {Path} at '{BasePath}'",
                        plugin.Name, plugin.DirectoryPath, plugin.BasePath);
                }
            }
            // --- Fallback Routing for SPA ---
            // Serve index.html for the root and common overlay paths to support client-side routing
            string indexPath = Path.Combine(_reactAppDistPath, "index.html");
            if (File.Exists(indexPath))
            {
                _webApp.MapGet("/", () => Results.File(indexPath, "text/html"));
                _webApp.MapGet("/chat", () => Results.File(indexPath, "text/html"));
                _webApp.MapGet("/subtimer", () => Results.File(indexPath, "text/html"));
                _logger.LogInformation("Mapped SPA routes to serve index.html from {Path}", indexPath);
            }
            else
            {
                _logger.LogError("React app index.html not found at {Path}. SPA routing will fail.", indexPath);
                _webApp.MapGet("/", () => Results.NotFound("Overlay index.html not found."));
            }
            _logger.LogInformation("ASP.NET Core pipeline configured.");
            await _webApp.RunAsync(_cts.Token);
            _logger.LogInformation("Web host gracefully shut down.");
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Web host operation cancelled (likely due to StopAsync or Dispose).");
        }
        catch (IOException ioEx) when (ioEx.Message.Contains("address already in use", StringComparison.OrdinalIgnoreCase))
        {
            _logger.LogCritical(ioEx, "FATAL ERROR - Port {Port} is already in use. Please change the port in settings or close the conflicting application.", port);
            if (_webApp != null) await _webApp.DisposeAsync();
            _webApp = null;
            _cts?.Dispose(); _cts = null;
        }
        catch (Exception ex)
        {
            _logger.LogCritical(ex, "FATAL ERROR starting web host.");
            if (_webApp != null) await _webApp.DisposeAsync();
            _webApp = null;
            _cts?.Dispose(); _cts = null;
        }
        finally
        {
            _logger.LogInformation("StartAsync final execution block reached.");
        }
    }
    private async Task HandleWebSocketConnection(HttpContext context)
    {
        if (context.WebSockets.IsWebSocketRequest)
        {
            _logger.LogInformation("WebSocket connection request received from {RemoteIpAddress}.", context.Connection.RemoteIpAddress);
            using WebSocket webSocket = await context.WebSockets.AcceptWebSocketAsync();
            await _webSocketManager.HandleNewSocketAsync(webSocket, _discoveredWebPlugins, _cts?.Token ?? CancellationToken.None);
        }
        else
        {
            _logger.LogWarning("Non-WebSocket request received at /ws endpoint from {RemoteIpAddress}.", context.Connection.RemoteIpAddress);
            context.Response.StatusCode = StatusCodes.Status400BadRequest;
        }
    }
    private void DetermineWebPaths()
    {
        string baseDirectory = AppContext.BaseDirectory;
        _reactAppDistPath = Path.GetFullPath(Path.Combine(baseDirectory, "Web", "Overlay", "dist"));
        _pluginsWebPath = Path.GetFullPath(Path.Combine(baseDirectory, "Plugins", "Web"));
        _logger.LogDebug("Checking paths relative to Base Directory: {BaseDir}", baseDirectory);
        _logger.LogDebug("-> React Dist Path: {ReactPath}", _reactAppDistPath);
        _logger.LogDebug("-> Web Plugins Path: {PluginsPath}", _pluginsWebPath);
        if (!Directory.Exists(_reactAppDistPath))
        {
            _logger.LogWarning("React 'dist' directory NOT found at primary location: {Path}", _reactAppDistPath);
        }
        if (!Directory.Exists(_pluginsWebPath))
        {
            _logger.LogInformation("Web Plugins directory does not exist at: {Path}. No web plugins will be loaded.", _pluginsWebPath);
            try { Directory.CreateDirectory(_pluginsWebPath); } catch (Exception ex) { _logger.LogWarning(ex, "Failed to create Web Plugins directory."); }
        }
    }
    private List<WebPluginManifest> DiscoverWebPlugins()
    {
        var discovered = new List<WebPluginManifest>();
        if (string.IsNullOrEmpty(_pluginsWebPath) || !Directory.Exists(_pluginsWebPath))
        {
            _logger.LogInformation("Skipping web plugin discovery - directory path is invalid or not found.");
            return discovered;
        }
        _logger.LogInformation("Discovering web plugins in: {PluginsWebPath}", _pluginsWebPath);
        try
        {
            foreach (string subDir in Directory.GetDirectories(_pluginsWebPath))
            {
                string manifestPath = Path.Combine(subDir, "manifest.json");
                if (!File.Exists(manifestPath))
                {
                    _logger.LogTrace("Skipping directory '{DirName}': manifest.json not found.", Path.GetFileName(subDir));
                    continue;
                }
                _logger.LogDebug("Found manifest: {ManifestPath}", manifestPath);
                try
                {
                    string manifestJson = File.ReadAllText(manifestPath);
                    WebPluginManifest? manifest = JsonSerializer.Deserialize<WebPluginManifest>(manifestJson, s_manifestSerializerOptions);
                    if (manifest != null && ValidateWebManifest(manifest, manifestPath))
                    {
                        manifest.DirectoryPath = subDir;
                        manifest.BasePath = $"/plugins/{manifest.Id}/";
                        discovered.Add(manifest);
                        _logger.LogInformation("Successfully loaded web plugin: {PluginName} (v{PluginVersion}) from {DirName}",
                            manifest.Name, manifest.Version, Path.GetFileName(subDir));
                    }
                }
                catch (JsonException jsonEx)
                {
                    _logger.LogError(jsonEx, "Error parsing manifest JSON {ManifestPath}", manifestPath);
                }
                catch (IOException ioEx)
                {
                    _logger.LogError(ioEx, "Error reading manifest file {ManifestPath}", manifestPath);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Unexpected error processing web plugin manifest {ManifestPath}", manifestPath);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error enumerating web plugin directories in {PluginsWebPath}", _pluginsWebPath);
        }
        return discovered;
    }
    private bool ValidateWebManifest(WebPluginManifest manifest, string manifestPath)
    {
        bool isValid = true;
        if (string.IsNullOrWhiteSpace(manifest.Id))
        {
            _logger.LogError("Invalid manifest {ManifestPath}: 'id' is missing or empty.", manifestPath);
            isValid = false;
        }
        if (string.IsNullOrWhiteSpace(manifest.Name))
        {
            _logger.LogError("Invalid manifest {ManifestPath}: 'name' is missing or empty.", manifestPath);
            isValid = false;
        }
        if (string.IsNullOrWhiteSpace(manifest.Version) || !Version.TryParse(manifest.Version, out _))
        {
            _logger.LogError("Invalid manifest {ManifestPath}: 'version' is missing or not a valid format.", manifestPath);
            isValid = false;
        }
        if (string.IsNullOrWhiteSpace(manifest.EntryScript))
        {
            _logger.LogError("Invalid manifest {ManifestPath}: 'entryScript' is missing or empty.", manifestPath);
            isValid = false;
        }
        return isValid;
    }
    public async Task StopAsync()
    {
        _logger.LogInformation("Stopping web server...");
        if (_cts == null || _webApp == null)
        {
            _logger.LogInformation("Stop requested but web server is not running or already stopping.");
            return;
        }
        try
        {
            if (!_cts.IsCancellationRequested)
            {
                _cts.Cancel();
            }
            await _webApp.StopAsync(TimeSpan.FromSeconds(5));
        }
        catch (ObjectDisposedException) { _logger.LogDebug("StopAsync ignored ObjectDisposedException (likely CTS already disposed)."); }
        catch (OperationCanceledException) { _logger.LogInformation("StopAsync cancellation occurred during web host stop."); }
        catch (Exception ex) { _logger.LogError(ex, "Error occurred during StopAsync."); }
        finally { _logger.LogInformation("StopAsync request processed."); }
    }
    public async void Dispose()
    {
        if (_isDisposed) return;
        _isDisposed = true;
        _logger.LogInformation("Dispose called.");
        try { await StopAsync(); } catch (Exception ex) { _logger.LogError(ex, "Exception during StopAsync call within Dispose."); }
        _cts?.Dispose();
        if (_webApp != null)
        {
            try { await _webApp.DisposeAsync(); } catch (Exception ex) { _logger.LogError(ex, "Exception disposing WebApplication within Dispose."); }
            _webApp = null;
        }
        _logger.LogInformation("Dispose finished.");
        GC.SuppressFinalize(this);
    }
}
</file>

<file path="Core/Services/Web/WebSocketManager.cs">
using System.Collections.Concurrent;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using CommunityToolkit.Mvvm.Messaging;
using CommunityToolkit.Mvvm.Messaging.Messages;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Messaging;
using StreamWeaver.Core.Models.Events;
using StreamWeaver.Core.Models.Settings;
using StreamWeaver.Core.Plugins;
using StreamWeaver.Core.Services.Settings;
namespace StreamWeaver.Core.Services.Web;
public class OverlaySettingsUpdateMessage(OverlaySettings value) : ValueChangedMessage<OverlaySettings>(value);
public partial class WebSocketManager : IRecipient<NewEventMessage>, IRecipient<OverlaySettingsUpdateMessage>, IDisposable
{
    private readonly ILogger<WebSocketManager> _logger;
    private readonly ConcurrentDictionary<Guid, WebSocket> _sockets = new();
    private readonly IMessenger _messenger;
    private readonly ISettingsService _settingsService;
    private bool _isDisposed;
    private static readonly JsonSerializerOptions s_jsonSerializerOptions = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        ReferenceHandler = ReferenceHandler.IgnoreCycles,
    };
    public WebSocketManager(ILogger<WebSocketManager> logger, IMessenger messenger, ISettingsService settingsService)
    {
        _logger = logger;
        _messenger = messenger;
        _settingsService = settingsService;
        _messenger.Register<NewEventMessage>(this);
        _messenger.Register<OverlaySettingsUpdateMessage>(this);
        _logger.LogInformation("Initialized and registered for NewEventMessage and OverlaySettingsUpdateMessage.");
    }
    public async Task HandleNewSocketAsync(WebSocket socket, IEnumerable<WebPluginManifest> discoveredPlugins, CancellationToken appShutdownToken)
    {
        Guid socketId = Guid.NewGuid();
        if (!_sockets.TryAdd(socketId, socket))
        {
            _logger.LogWarning("Failed to add socket {SocketId} to collection. Aborting connection.", socketId);
            try { socket.Abort(); socket.Dispose(); } catch (Exception ex) { _logger.LogWarning(ex, "Exception during socket abort/dispose for failed add {SocketId}.", socketId); }
            return;
        }
        _logger.LogInformation("Socket connected: {SocketId}", socketId);
        using CancellationTokenSource linkedCts = CancellationTokenSource.CreateLinkedTokenSource(appShutdownToken);
        CancellationToken cancellationToken = linkedCts.Token;
        try
        {
            await SendInitialConfigurationAsync(socket, discoveredPlugins, cancellationToken);
            byte[] buffer = new byte[1024 * 4];
            WebSocketReceiveResult result = await socket.ReceiveAsync(new ArraySegment<byte>(buffer), cancellationToken);
            while (!result.CloseStatus.HasValue && !cancellationToken.IsCancellationRequested)
            {
                if (result.MessageType == WebSocketMessageType.Text)
                {
                    string receivedJson = Encoding.UTF8.GetString(buffer, 0, result.Count);
                    _logger.LogDebug("Socket {SocketId} received text message: {Message}", socketId, receivedJson);
                }
                else if (result.MessageType == WebSocketMessageType.Binary)
                {
                    _logger.LogDebug("Socket {SocketId} received binary message ({Count} bytes, ignored).", socketId, result.Count);
                }
                result = await socket.ReceiveAsync(new ArraySegment<byte>(buffer), cancellationToken);
            }
            if (result.CloseStatus.HasValue)
            {
                _logger.LogInformation("Socket {SocketId} initiated close: Status {Status}, Description '{Description}'", socketId, result.CloseStatus.Value, result.CloseStatusDescription);
                if (socket.State != WebSocketState.Closed && socket.State != WebSocketState.Aborted)
                {
                    await socket.CloseAsync(result.CloseStatus.Value, result.CloseStatusDescription, CancellationToken.None);
                }
            }
            else if (cancellationToken.IsCancellationRequested)
            {
                _logger.LogInformation("Socket {SocketId} handling cancelled externally. Closing socket.", socketId);
                if (socket.State is WebSocketState.Open or WebSocketState.CloseReceived)
                {
                    await socket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Server shutting down", CancellationToken.None);
                }
            }
        }
        catch (WebSocketException wsEx) when (wsEx.WebSocketErrorCode == WebSocketError.ConnectionClosedPrematurely)
        {
            _logger.LogInformation("Socket {SocketId} connection closed prematurely.", socketId);
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Socket {SocketId} handling task cancelled.", socketId);
            if (socket.State is WebSocketState.Open or WebSocketState.CloseReceived)
            {
                try { await socket.CloseOutputAsync(WebSocketCloseStatus.NormalClosure, "Server shutting down", CancellationToken.None); } catch {  }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error handling socket {SocketId}. State: {State}", socketId, socket.State);
            if (socket.State is WebSocketState.Open or WebSocketState.CloseReceived)
            {
                try { await socket.CloseOutputAsync(WebSocketCloseStatus.InternalServerError, "Server error", CancellationToken.None); } catch (Exception closeEx) { _logger.LogError(closeEx, "Further error attempting to close socket {SocketId} after previous error.", socketId); }
            }
        }
        finally
        {
            RemoveSocket(socketId, socket);
        }
    }
    private void RemoveSocket(Guid socketId, WebSocket socket)
    {
        if (_sockets.TryRemove(socketId, out _))
        {
            _logger.LogInformation("Socket removed: {SocketId}", socketId);
        }
        else
        {
            _logger.LogDebug("Attempted to remove socket {SocketId}, but it was not found (likely already removed).", socketId);
        }
        try { socket?.Dispose(); } catch (Exception ex) { _logger.LogWarning(ex, "Error disposing socket {SocketId}.", socketId); }
    }
    private async Task SendInitialConfigurationAsync(WebSocket socket, IEnumerable<WebPluginManifest> plugins, CancellationToken cancellationToken)
    {
        try
        {
            OverlaySettings currentSettings = _settingsService.CurrentSettings.Overlays;
            var pluginInfoList = plugins.Select(p => new
            {
                p.Id,
                p.Name,
                p.Version,
                p.Author,
                p.Description,
                p.EntryScript,
                p.EntryStyle,
                p.ProvidesComponents,
                p.RegistersWebComponents,
                p.BasePath
            }).ToList();
            var initPayload = new { type = "init", payload = new { settings = currentSettings, plugins = pluginInfoList } };
            string jsonPayload = JsonSerializer.Serialize(initPayload, s_jsonSerializerOptions);
            byte[] messageBytes = Encoding.UTF8.GetBytes(jsonPayload);
            ArraySegment<byte> messageBuffer = new(messageBytes);
            if (socket.State == WebSocketState.Open)
            {
                await socket.SendAsync(messageBuffer, WebSocketMessageType.Text, true, cancellationToken);
                _logger.LogDebug("Sent initial configuration ({PayloadSize} bytes) to socket.", messageBytes.Length);
            }
            else
            {
                _logger.LogWarning("Could not send initial configuration, socket state was {State}.", socket.State);
            }
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Sending initial configuration was cancelled.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending initial configuration.");
        }
    }
    public void Receive(NewEventMessage message)
    {
        if (_isDisposed) return;
        BaseEvent eventPayload = message.Value;
        var messageWrapper = new { type = "event", payload = eventPayload };
        string json = JsonSerializer.Serialize(messageWrapper, s_jsonSerializerOptions);
        _ = BroadcastJsonAsync(json);
    }
    public void Receive(OverlaySettingsUpdateMessage message)
    {
        if (_isDisposed) return;
        _logger.LogDebug("Received OverlaySettingsUpdateMessage. Broadcasting...");
        var messagePayload = new { type = "settings", payload = message.Value };
        string json = JsonSerializer.Serialize(messagePayload, s_jsonSerializerOptions);
        _ = BroadcastJsonAsync(json);
    }
    private async Task BroadcastJsonAsync(string jsonPayload)
    {
        if (_isDisposed || _sockets.IsEmpty) return;
        byte[] messageBytes = Encoding.UTF8.GetBytes(jsonPayload);
        ArraySegment<byte> messageBuffer = new(messageBytes);
        _logger.LogTrace("Broadcasting JSON ({Length} bytes) to {Count} clients: {PayloadPreview}...", messageBytes.Length, _sockets.Count, jsonPayload[..Math.Min(jsonPayload.Length, 150)]);
        List<Task> sendTasks = [];
        ConcurrentBag<Guid> socketsToRemove = [];
        foreach (KeyValuePair<Guid, WebSocket> pair in _sockets)
        {
            Guid socketId = pair.Key;
            WebSocket socket = pair.Value;
            if (socket.State == WebSocketState.Open)
            {
                sendTasks.Add(Task.Run(async () =>
                {
                    try
                    {
                        await socket.SendAsync(messageBuffer, WebSocketMessageType.Text, true, CancellationToken.None);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogWarning(ex, "Error sending message to socket {SocketId} (State: {State}). Marking for removal.", socketId, socket.State);
                        socketsToRemove.Add(socketId);
                    }
                }));
            }
            else
            {
                _logger.LogDebug("Socket {SocketId} is not open (State: {State}). Marking for removal during broadcast.", socketId, socket.State);
                socketsToRemove.Add(socketId);
            }
        }
        try
        {
            await Task.WhenAll(sendTasks).WaitAsync(TimeSpan.FromSeconds(5));
        }
        catch (TimeoutException)
        {
            _logger.LogWarning("Timeout waiting for some WebSocket send operations to complete during broadcast.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected exception during Task.WhenAll for broadcast sends.");
        }
        if (!socketsToRemove.IsEmpty)
        {
            IEnumerable<Guid> distinctIdsToRemove = socketsToRemove.Distinct();
            _logger.LogInformation("Removing {Count} disconnected/failed sockets after broadcast.", distinctIdsToRemove.Count());
            foreach (Guid idToRemove in distinctIdsToRemove)
            {
                if (_sockets.TryGetValue(idToRemove, out WebSocket? socketToRemove))
                {
                    RemoveSocket(idToRemove, socketToRemove);
                }
            }
        }
    }
    public void Dispose()
    {
        if (_isDisposed) return;
        _isDisposed = true;
        _logger.LogInformation("Disposing WebSocketManager...");
        _messenger.UnregisterAll(this);
        List<Task> closeTasks = [];
        foreach (Guid socketId in _sockets.Keys.ToList())
        {
            if (_sockets.TryRemove(socketId, out WebSocket? socket))
            {
                if (socket.State == WebSocketState.Open || socket.State == WebSocketState.CloseReceived)
                {
                    closeTasks.Add(Task.Run(async () => {
                        try
                        {
                            await socket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Server shutting down", CancellationToken.None);
                        }
                        catch (Exception ex)
                        {
                            _logger.LogWarning(ex, "Exception closing socket {SocketId} during dispose.", socketId);
                        }
                        finally
                        {
                            try { socket.Dispose(); } catch {  }
                        }
                    }));
                }
                else
                {
                    try { socket.Dispose(); } catch {  }
                }
            }
        }
        try { Task.WhenAll(closeTasks).Wait(TimeSpan.FromSeconds(2)); } catch {  }
        _sockets.Clear();
        _logger.LogInformation("WebSocketManager Dispose finished.");
        GC.SuppressFinalize(this);
    }
}
</file>

<file path="Modules/Goals/GoalService.cs">
using CommunityToolkit.Mvvm.Messaging;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Messaging;
using StreamWeaver.Core.Models.Events;
using StreamWeaver.Core.Services.Settings;
namespace StreamWeaver.Modules.Goals;
public partial class GoalService : IRecipient<NewEventMessage>, IDisposable
{
    private readonly ILogger<GoalService> _logger;
    private readonly ISettingsService _settingsService;
    private readonly IMessenger _messenger;
    private GoalSettings _moduleSettings = new();
    private bool _isDisposed;
    private int _currentSubGoalCount = 0;
    public GoalService(ILogger<GoalService> logger, ISettingsService settingsService, IMessenger messenger)
    {
        _logger = logger;
        _settingsService = settingsService;
        _messenger = messenger;
        LoadSettings();
        _settingsService.SettingsUpdated += OnSettingsUpdated;
        _messenger.Register(this);
        LoadInitialProgress();
        _logger.LogInformation("Initialized.");
    }
    private void LoadSettings()
    {
        _moduleSettings = _settingsService.CurrentSettings.Modules.Goals;
        _logger.LogDebug("Goal settings loaded/reloaded.");
    }
    private void LoadInitialProgress()
    {
        _currentSubGoalCount = _moduleSettings.PersistedSubCount;
        _logger.LogInformation("Initial goal progress loaded. Current Sub Count: {SubCount}", _currentSubGoalCount);
        PublishGoalUpdate();
    }
    private void PersistProgress()
    {
        if (_moduleSettings.PersistedSubCount != _currentSubGoalCount)
        {
            _moduleSettings.PersistedSubCount = _currentSubGoalCount;
            _logger.LogDebug("Persisting goal progress. Sub Count: {SubCount}", _currentSubGoalCount);
        }
    }
    private void OnSettingsUpdated(object? sender, EventArgs e)
    {
        _logger.LogDebug("SettingsUpdated event received.");
        GoalSettings oldSettings = _moduleSettings;
        LoadSettings();
        if (oldSettings.GoalType != _moduleSettings.GoalType)
        {
            _logger.LogInformation(
                "Goal type changed from {OldType} to {NewType}. Resetting progress.",
                oldSettings.GoalType,
                _moduleSettings.GoalType
            );
            _currentSubGoalCount = 0;
            LoadInitialProgress();
        }
        else if (
            oldSettings.SubGoalTarget != _moduleSettings.SubGoalTarget
        )
        {
            _logger.LogInformation("Goal target changed.");
        }
        PublishGoalUpdate();
    }
    public void Receive(NewEventMessage message)
    {
        if (!_moduleSettings.Enabled)
            return;
        bool progressChanged = false;
        switch (message.Value)
        {
            case SubscriptionEvent se when _moduleSettings.GoalType == GoalType.Subscriptions:
                int subsToAdd = se.GiftCount > 0 ? se.GiftCount : 1;
                _currentSubGoalCount += subsToAdd;
                progressChanged = true;
                _logger.LogDebug(
                    "Subscription event processed. Goal progress: {Current}/{Target}",
                    _currentSubGoalCount,
                    _moduleSettings.SubGoalTarget
                );
                break;
            case FollowEvent when _moduleSettings.GoalType == GoalType.Followers:
                break;
            case DonationEvent when _moduleSettings.GoalType == GoalType.Donations:
                break;
        }
        if (progressChanged)
        {
            PublishGoalUpdate();
            PersistProgress();
        }
    }
    private void PublishGoalUpdate()
    {
        if (!_moduleSettings.Enabled)
            return;
        decimal currentValue = 0;
        decimal targetValue = 0;
        string label = _moduleSettings.GoalLabel;
        switch (_moduleSettings.GoalType)
        {
            case GoalType.Subscriptions:
                currentValue = _currentSubGoalCount;
                targetValue = _moduleSettings.SubGoalTarget;
                if (string.IsNullOrWhiteSpace(label))
                    label = "Sub Goal";
                break;
            case GoalType.Followers:
                if (string.IsNullOrWhiteSpace(label))
                    label = "Follower Goal";
                break;
            case GoalType.Donations:
                if (string.IsNullOrWhiteSpace(label))
                    label = "Donation Goal";
                break;
        }
        _logger.LogDebug("Publishing Goal Update: Label='{Label}', Current={Current}, Target={Target}", label, currentValue, targetValue);
        GoalUpdateEvent updateEvent = new()
        {
            Label = label,
            CurrentValue = currentValue,
            TargetValue = targetValue,
        };
        _messenger.Send(new NewEventMessage(updateEvent));
    }
    public void Dispose()
    {
        if (_isDisposed)
            return;
        _isDisposed = true;
        _logger.LogInformation("Disposing...");
        PersistProgress();
        _settingsService.SettingsUpdated -= OnSettingsUpdated;
        _messenger.UnregisterAll(this);
        _logger.LogInformation("Dispose finished.");
        GC.SuppressFinalize(this);
    }
}
public class GoalUpdateEvent : BaseEvent
{
    public string Label { get; init; } = string.Empty;
    public decimal CurrentValue { get; init; } = 0;
    public decimal TargetValue { get; init; } = 0;
    public GoalUpdateEvent() => Platform = "Module";
}
</file>

<file path="Modules/Goals/GoalSettings.cs">
using CommunityToolkit.Mvvm.ComponentModel;
namespace StreamWeaver.Modules.Goals;
public enum GoalType
{
    Subscriptions,
    Followers,
    Donations,
}
public partial class GoalSettings : ObservableObject
{
    [ObservableProperty]
    public partial bool Enabled { get; set; } = false;
    [ObservableProperty]
    public partial GoalType GoalType { get; set; } = GoalType.Subscriptions;
    [ObservableProperty]
    public partial string GoalLabel { get; set; } = string.Empty;
    [ObservableProperty]
    public partial int SubGoalTarget { get; set; } = 50;
    [ObservableProperty]
    public partial int FollowerGoalTarget { get; set; } = 100;
    [ObservableProperty]
    public partial decimal DonationGoalTarget { get; set; } = 250.00m;
    [ObservableProperty]
    public partial string DonationGoalCurrency { get; set; } = "USD";
    [ObservableProperty]
    public partial int PersistedSubCount { get; set; } = 0;
}
</file>

<file path="Modules/Subathon/SubathonService.cs">
using System.Diagnostics;
using CommunityToolkit.Mvvm.Messaging;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Messaging;
using StreamWeaver.Core.Models.Events;
using StreamWeaver.Core.Services.Settings;
namespace StreamWeaver.Modules.Subathon;
public partial class SubathonService : IRecipient<NewEventMessage>, IDisposable
{
    private readonly ILogger<SubathonService> _logger;
    private readonly ISettingsService _settingsService;
    private readonly IMessenger _messenger;
    private Timer? _timer;
    private DateTime _timerEndTime = DateTime.MinValue;
    private bool _isRunning = false;
    private SubathonSettings _moduleSettings = new();
    private bool _isDisposed = false;
    private long _lastUpdateTimeTicks = 0;
    private static readonly TimeSpan s_updateInterval = TimeSpan.FromSeconds(1);
    public SubathonService(ILogger<SubathonService> logger, ISettingsService settingsService, IMessenger messenger)
    {
        _logger = logger;
        _settingsService = settingsService;
        _messenger = messenger;
        LoadSettings();
        _settingsService.SettingsUpdated += OnSettingsUpdated;
        _messenger.Register<NewEventMessage>(this);
        if (_moduleSettings.Enabled)
        {
            _ = Task.Run(StartTimerAsync);
        }
        _logger.LogInformation("Initialized.");
    }
    private void LoadSettings()
    {
        _moduleSettings = _settingsService.CurrentSettings.Modules.Subathon;
        _logger.LogDebug("Settings Loaded. Enabled={IsEnabled}", _moduleSettings.Enabled);
    }
    private async void OnSettingsUpdated(object? sender, EventArgs e)
    {
        if (_isDisposed)
            return;
        _logger.LogDebug("Settings updated event received.");
        bool oldEnabledState = _moduleSettings.Enabled;
        LoadSettings();
        if (!oldEnabledState && _moduleSettings.Enabled)
        {
            _logger.LogInformation("Subathon module enabled via settings change. Starting timer.");
            await StartTimerAsync();
        }
        else if (oldEnabledState && !_moduleSettings.Enabled)
        {
            _logger.LogInformation("Subathon module disabled via settings change. Stopping timer.");
            await StopTimerAsync();
        }
        if (_isRunning || (oldEnabledState && !_moduleSettings.Enabled))
        {
            PublishTimerUpdate();
        }
    }
    public void Receive(NewEventMessage message)
    {
        if (_isDisposed || !_moduleSettings.Enabled || !_isRunning)
            return;
        TimeSpan timeToAdd = TimeSpan.Zero;
        switch (message.Value)
        {
            case SubscriptionEvent se:
                timeToAdd = GetTimeForSubscription(se);
                break;
            case DonationEvent de:
                timeToAdd = GetTimeForDonation(de);
                break;
        }
        if (timeToAdd > TimeSpan.Zero)
        {
            AddTime(timeToAdd);
        }
    }
    private async Task StartTimerAsync()
    {
        if (_isDisposed || _isRunning)
            return;
        _logger.LogInformation("Attempting to start timer...");
        bool loadedFromPersistence = false;
        if (_moduleSettings.PersistedEndTimeUtcTicks > 0)
        {
            try
            {
                DateTime persistedEndTime = new(_moduleSettings.PersistedEndTimeUtcTicks, DateTimeKind.Utc);
                if (persistedEndTime > DateTime.UtcNow)
                {
                    _timerEndTime = persistedEndTime;
                    loadedFromPersistence = true;
                    _logger.LogInformation("Resuming timer from persistence. Ends at (UTC): {EndTime}", _timerEndTime);
                    _moduleSettings.PersistedEndTimeUtcTicks = 0;
                    await _settingsService.SaveSettingsAsync(_settingsService.CurrentSettings);
                }
                else
                {
                    _logger.LogInformation("Persisted end time is in the past ({PersistedTimeUtc}). Ignoring and clearing.", persistedEndTime);
                    _moduleSettings.PersistedEndTimeUtcTicks = 0;
                    await _settingsService.SaveSettingsAsync(_settingsService.CurrentSettings);
                }
            }
            catch (ArgumentOutOfRangeException ex)
            {
                _logger.LogWarning(
                    ex,
                    "Persisted end time ticks ({Ticks}) are invalid. Ignoring and clearing.",
                    _moduleSettings.PersistedEndTimeUtcTicks
                );
                _moduleSettings.PersistedEndTimeUtcTicks = 0;
                await _settingsService.SaveSettingsAsync(_settingsService.CurrentSettings);
            }
        }
        if (!loadedFromPersistence)
        {
            if (_timerEndTime <= DateTime.UtcNow)
            {
                if (_moduleSettings.InitialDurationMinutes > 0)
                {
                    _timerEndTime = DateTime.UtcNow.AddMinutes(_moduleSettings.InitialDurationMinutes);
                    _logger.LogInformation(
                        "Starting new timer with initial duration {InitialDuration} mins. Ends at (UTC): {EndTime}",
                        _moduleSettings.InitialDurationMinutes,
                        _timerEndTime
                    );
                }
                else
                {
                    _logger.LogWarning("Cannot start timer: No persisted time found, end time is in the past, and no initial duration is set.");
                    _isRunning = false;
                    PublishTimerUpdate();
                    return;
                }
            }
            else
            {
                _logger.LogInformation("Timer end time ({EndTimeUtc}) already set and in future. Resuming timer tick.", _timerEndTime);
            }
        }
        _isRunning = true;
        _timer?.Dispose();
        _timer = new Timer(TimerTick, null, TimeSpan.Zero, TimeSpan.FromMilliseconds(250));
        _logger.LogInformation("Timer started/resumed.");
        PublishTimerUpdate();
    }
    private async Task StopTimerAsync(bool persistState = true)
    {
        if (_isDisposed || !_isRunning)
            return;
        _isRunning = false;
        _timer?.Dispose();
        _timer = null;
        _logger.LogInformation("Timer stopped.");
        if (persistState)
        {
            if (_timerEndTime > DateTime.UtcNow)
            {
                _logger.LogInformation("Persisting end time...");
                _moduleSettings.PersistedEndTimeUtcTicks = _timerEndTime.ToUniversalTime().Ticks;
                await _settingsService.SaveSettingsAsync(_settingsService.CurrentSettings);
                _logger.LogInformation("Persisted EndTime Ticks: {EndTimeTicks}", _moduleSettings.PersistedEndTimeUtcTicks);
            }
            else
            {
                _logger.LogInformation("Timer already expired, clearing any previous persisted end time.");
                if (_moduleSettings.PersistedEndTimeUtcTicks != 0)
                {
                    _moduleSettings.PersistedEndTimeUtcTicks = 0;
                    await _settingsService.SaveSettingsAsync(_settingsService.CurrentSettings);
                }
            }
        }
        PublishTimerUpdate();
    }
    private void AddTime(TimeSpan timeToAdd)
    {
        if (_isDisposed)
            return;
        if (!_isRunning)
        {
            _logger.LogInformation("AddTime called while timer stopped. Attempting to start timer before adding time.");
            _ = Task.Run(StartTimerAsync);
        }
        if (_timerEndTime == DateTime.MinValue)
        {
            _logger.LogWarning("AddTime called but timer end time is not set (MinValue). Ignoring add for {SecondsToAdd}s.", timeToAdd.TotalSeconds);
            return;
        }
        _logger.LogDebug("Attempting to add {SecondsToAdd}s.", timeToAdd.TotalSeconds);
        TimeSpan currentRemaining = _timerEndTime - DateTime.UtcNow;
        if (currentRemaining < TimeSpan.Zero)
            currentRemaining = TimeSpan.Zero;
        TimeSpan cappedTimeToAdd = timeToAdd;
        if (_moduleSettings.MaximumDurationMinutes > 0)
        {
            TimeSpan maxDuration = TimeSpan.FromMinutes(_moduleSettings.MaximumDurationMinutes);
            TimeSpan potentialNewDuration = currentRemaining + timeToAdd;
            if (potentialNewDuration > maxDuration)
            {
                cappedTimeToAdd = maxDuration - currentRemaining;
                if (cappedTimeToAdd < TimeSpan.Zero)
                    cappedTimeToAdd = TimeSpan.Zero;
                _logger.LogInformation(
                    "Time add capped by maximum duration ({MaxMinutes} mins). Actual time added: {ActualSecondsAdded}s",
                    _moduleSettings.MaximumDurationMinutes,
                    cappedTimeToAdd.TotalSeconds
                );
            }
        }
        _timerEndTime = _timerEndTime.Add(cappedTimeToAdd);
        _logger.LogInformation(
            "Successfully added {ActualSecondsAdded}s. New EndTime (UTC): {NewEndTime}",
            cappedTimeToAdd.TotalSeconds,
            _timerEndTime
        );
        PublishTimerUpdate();
    }
    private void TimerTick(object? state)
    {
        if (_isDisposed || !_isRunning)
        {
            _timer?.Change(Timeout.Infinite, Timeout.Infinite);
            return;
        }
        TimeSpan remaining = _timerEndTime - DateTime.UtcNow;
        if (remaining <= TimeSpan.Zero)
        {
            _logger.LogInformation("Timer reached zero.");
            _ = Task.Run(() => StopTimerAsync(persistState: true));
        }
        else
        {
            long nowTicks = Stopwatch.GetTimestamp();
            TimeSpan elapsedSinceLastUpdate = Stopwatch.GetElapsedTime(nowTicks, _lastUpdateTimeTicks);
            bool isTimeLow = remaining < TimeSpan.FromSeconds(10);
            if (isTimeLow || elapsedSinceLastUpdate >= s_updateInterval)
            {
                PublishTimerUpdate(remaining);
                _lastUpdateTimeTicks = nowTicks;
            }
        }
    }
    private void PublishTimerUpdate(TimeSpan? remaining = null)
    {
        if (_isDisposed)
            return;
        remaining ??= _isRunning ? (_timerEndTime - DateTime.UtcNow) : TimeSpan.Zero;
        if (remaining < TimeSpan.Zero)
            remaining = TimeSpan.Zero;
        int remainingSeconds = (int)Math.Round(remaining.Value.TotalSeconds);
        _logger.LogTrace("Publishing timer update. IsRunning={IsRunning}, RemainingSeconds={Seconds}", _isRunning, remainingSeconds);
        SubTimerUpdateEvent updateEvent = new() { RemainingSeconds = remainingSeconds, IsRunning = _isRunning };
        _messenger.Send(new NewEventMessage(updateEvent));
    }
    private TimeSpan GetTimeForSubscription(SubscriptionEvent sub)
    {
        if (!_moduleSettings.AddTimeForSubs)
            return TimeSpan.Zero;
        double secondsToAdd;
        if (sub.IsGift)
        {
            secondsToAdd = _moduleSettings.SecondsPerGiftSub * sub.GiftCount;
            _logger.LogDebug("Calculated {Seconds}s for {GiftCount} gift subs.", secondsToAdd, sub.GiftCount);
        }
        else
        {
            secondsToAdd = sub.Tier?.ToLowerInvariant() switch
            {
                "tier 2" or "2000" => _moduleSettings.SecondsPerSubTier2,
                "tier 3" or "3000" => _moduleSettings.SecondsPerSubTier3,
                _ => _moduleSettings.SecondsPerSubTier1,
            };
            _logger.LogDebug("Calculated {Seconds}s for non-gift sub (Tier: {Tier}).", secondsToAdd, sub.Tier ?? "Unknown/T1/Prime");
        }
        return TimeSpan.FromSeconds(secondsToAdd);
    }
    private TimeSpan GetTimeForDonation(DonationEvent donation)
    {
        double secondsToAdd = 0;
        if (donation.Type == DonationType.Bits)
        {
            if (!_moduleSettings.AddTimeForBits)
                return TimeSpan.Zero;
            if (_moduleSettings.BitsPerSecond > 0)
            {
                secondsToAdd = (double)donation.Amount / _moduleSettings.BitsPerSecond;
                _logger.LogDebug("Calculated {Seconds}s for {Amount} bits.", secondsToAdd, donation.Amount);
            }
        }
        else
        {
            if (!_moduleSettings.AddTimeForDonations)
                return TimeSpan.Zero;
            if (_moduleSettings.AmountPerSecond > 0)
            {
                secondsToAdd = (double)(donation.Amount / _moduleSettings.AmountPerSecond);
                _logger.LogDebug(
                    "Calculated {Seconds}s for {Amount} {Currency} donation (currency ignored).",
                    secondsToAdd,
                    donation.Amount,
                    donation.Currency ?? "N/A"
                );
            }
        }
        return TimeSpan.FromSeconds(secondsToAdd);
    }
    public void Dispose()
    {
        if (_isDisposed)
            return;
        _isDisposed = true;
        _logger.LogInformation("Disposing...");
        _settingsService.SettingsUpdated -= OnSettingsUpdated;
        _messenger.UnregisterAll(this);
        try
        {
            Task.Run(() => StopTimerAsync(persistState: true)).Wait(TimeSpan.FromSeconds(2));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Exception during StopTimerAsync wait in Dispose.");
        }
        _timer?.Dispose();
        _logger.LogInformation("Dispose finished.");
        GC.SuppressFinalize(this);
    }
}
public class SubTimerUpdateEvent : BaseEvent
{
    public int RemainingSeconds { get; init; }
    public bool IsRunning { get; init; }
    public string EventType { get; init; }
    public SubTimerUpdateEvent()
    {
        Platform = "Module";
        EventType = nameof(SubTimerUpdateEvent);
    }
}
</file>

<file path="Modules/Subathon/SubathonSettings.cs">
using CommunityToolkit.Mvvm.ComponentModel;
namespace StreamWeaver.Modules.Subathon;
public partial class SubathonSettings : ObservableObject
{
    [ObservableProperty]
    public partial bool Enabled { get; set; } = false;
    [ObservableProperty]
    public partial int InitialDurationMinutes { get; set; } = 60;
    [ObservableProperty]
    public partial int MaximumDurationMinutes { get; set; } = 0;
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsSubConfigEnabled))]
    public partial bool AddTimeForSubs { get; set; } = true;
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsBitsConfigEnabled))]
    public partial bool AddTimeForBits { get; set; } = true;
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsDonationConfigEnabled))]
    public partial bool AddTimeForDonations { get; set; } = true;
    [ObservableProperty]
    public partial int SecondsPerSubTier1 { get; set; } = 30;
    [ObservableProperty]
    public partial int SecondsPerSubTier2 { get; set; } = 60;
    [ObservableProperty]
    public partial int SecondsPerSubTier3 { get; set; } = 120;
    [ObservableProperty]
    public partial int SecondsPerGiftSub { get; set; } = 30;
    [ObservableProperty]
    public partial int BitsPerSecond { get; set; } = 10;
    [ObservableProperty]
    public partial decimal AmountPerSecond { get; set; } = 0.10m;
    [ObservableProperty]
    public partial string DonationCurrencyAssumption { get; set; } = "USD";
    [ObservableProperty]
    public partial long PersistedEndTimeUtcTicks { get; set; } = 0;
    public bool IsSubConfigEnabled => AddTimeForSubs;
    public bool IsBitsConfigEnabled => AddTimeForBits;
    public bool IsDonationConfigEnabled => AddTimeForDonations;
}
</file>

<file path="Package.appxmanifest">
<?xml version="1.0" encoding="utf-8"?>

<Package
  xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
  xmlns:mp="http://schemas.microsoft.com/appx/2014/phone/manifest"
  xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
  xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities"
  IgnorableNamespaces="uap rescap">

  <Identity
    Name="cb3196f4-b40a-4e7e-a484-a2f70cf985bb"
    Publisher="CN=t_aga"
    Version="1.0.0.0" />

  <mp:PhoneIdentity PhoneProductId="cb3196f4-b40a-4e7e-a484-a2f70cf985bb" PhonePublisherId="00000000-0000-0000-0000-000000000000"/>

  <Properties>
    <DisplayName>StreamWeaver</DisplayName>
    <PublisherDisplayName>t_aga</PublisherDisplayName>
    <Logo>Assets\StoreLogo.png</Logo>
  </Properties>

  <Dependencies>
    <TargetDeviceFamily Name="Windows.Universal" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0" />
    <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0" />
  </Dependencies>

  <Resources>
    <Resource Language="x-generate"/>
  </Resources>

  <Applications>
    <Application Id="App"
      Executable="$targetnametoken$.exe"
      EntryPoint="$targetentrypoint$">
      <uap:VisualElements
        DisplayName="StreamWeaver"
        Description="StreamWeaver"
        BackgroundColor="transparent"
        Square150x150Logo="Assets\Square150x150Logo.png"
        Square44x44Logo="Assets\Square44x44Logo.png">
        <uap:DefaultTile Wide310x150Logo="Assets\Wide310x150Logo.png" />
        <uap:SplashScreen Image="Assets\SplashScreen.png" />
      </uap:VisualElements>
    </Application>
  </Applications>

  <Capabilities>
    <rescap:Capability Name="runFullTrust" />
  </Capabilities>
</Package>
</file>

<file path="Properties/launchSettings.json">
{
    "profiles": {
        "StreamWeaver (Package)": {
            "commandName": "MsixPackage"
        },
        "StreamWeaver (Unpackaged)": {
            "commandName": "Project"
        }
    }
}
</file>

<file path="Themes/Generic.xaml">
<ResourceDictionary
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:StreamWeaver">
</ResourceDictionary>
</file>

<file path="UI/Converters/AutoHostTextConverter.cs">
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class AutoHostTextConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language) =>
        value is bool isAutoHost && isAutoHost ? " (AutoHost)" : (object)string.Empty;
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/BadgeIdentifierToTwitchUrlConverter.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Media.Imaging;
using StreamWeaver.Core.Services;
namespace StreamWeaver.UI.Converters;
public partial class BadgeIdentifierToTwitchUrlConverter : IValueConverter
{
    private static readonly Lazy<ILogger<BadgeIdentifierToTwitchUrlConverter>?> s_lazyLogger = new(() =>
    {
        try
        {
            return App.GetService<ILogger<BadgeIdentifierToTwitchUrlConverter>>();
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine(
                $"[BadgeConverter.StaticInit] Failed to get ILogger<BadgeIdentifierToTwitchUrlConverter>: {ex.Message}"
            );
            return null;
        }
    });
    private static readonly Lazy<IEmoteBadgeService?> s_lazyEmoteBadgeService = new(() =>
    {
        try
        {
            return App.GetService<IEmoteBadgeService>();
        }
        catch (Exception ex)
        {
            Logger?.LogError(ex, "Failed to get IEmoteBadgeService during lazy initialization.");
            if (Logger == null)
            {
                System.Diagnostics.Debug.WriteLine($"[BadgeConverter.StaticInit] Failed to get IEmoteBadgeService: {ex.Message}");
            }
            return null;
        }
    });
    private static ILogger<BadgeIdentifierToTwitchUrlConverter>? Logger => s_lazyLogger.Value;
    private static IEmoteBadgeService? EmoteBadgeService => s_lazyEmoteBadgeService.Value;
    public object? Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is not string identifier || string.IsNullOrWhiteSpace(identifier))
        {
            Logger?.LogDebug("Input value is null or not a valid string identifier. Value: {Value}", value);
            return null;
        }
        if (EmoteBadgeService == null)
        {
            Logger?.LogError("EmoteBadgeService is null, cannot process badge identifier: {Identifier}", identifier);
            return null;
        }
        if (identifier.StartsWith("twitch/", StringComparison.OrdinalIgnoreCase))
        {
            string[] parts = identifier.Split('/');
            if (parts.Length == 3)
            {
                string setId = parts[1];
                string versionId = parts[2];
                try
                {
                    string? url = EmoteBadgeService.GetTwitchBadgeUrl(setId, versionId);
                    if (!string.IsNullOrEmpty(url) && Uri.TryCreate(url, UriKind.Absolute, out Uri? imageUri))
                    {
                        Logger?.LogTrace("Found URL for badge {Identifier}: {Url}", identifier, url);
                        return new BitmapImage(imageUri);
                    }
                    else
                    {
                        Logger?.LogWarning(
                            "URL not found or invalid for Twitch badge identifier: {Identifier} (Set: {SetId}, Version: {VersionId}). Returned URL: '{Url}'",
                            identifier,
                            setId,
                            versionId,
                            url ?? "null"
                        );
                    }
                }
                catch (Exception ex)
                {
                    string? fetchedUrl = EmoteBadgeService.GetTwitchBadgeUrl(setId, versionId);
                    Logger?.LogError(
                        ex,
                        "Error processing or creating BitmapImage for badge {Identifier} (Set: {SetId}, Version: {VersionId}, URL: '{Url}')",
                        identifier,
                        setId,
                        versionId,
                        fetchedUrl ?? "N/A"
                    );
                }
            }
            else
            {
                Logger?.LogWarning("Invalid Twitch badge identifier format: {Identifier}. Expected 'twitch/set_id/version_id'.", identifier);
            }
        }
        else
        {
            Logger?.LogTrace("Identifier '{Identifier}' is not a Twitch badge identifier, skipping conversion.", identifier);
        }
        return null;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language)
    {
        Logger?.LogWarning("ConvertBack called but is not implemented.");
        throw new NotImplementedException("BadgeIdentifierToTwitchUrlConverter does not support ConvertBack.");
    }
}
</file>

<file path="UI/Converters/BadgeIdentifierToUrlConverter.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Media.Imaging;
namespace StreamWeaver.UI.Converters;
public partial class BadgeIdentifierToUrlConverter : IValueConverter
{
    private static readonly Lazy<ILogger<BadgeIdentifierToUrlConverter>?> s_lazyLogger = new(() =>
    {
        try
        {
            return App.GetService<ILogger<BadgeIdentifierToUrlConverter>>();
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"[BadgeIdentifierToUrlConverter.StaticInit] Failed to get ILogger: {ex.Message}");
            return null;
        }
    });
    private static ILogger<BadgeIdentifierToUrlConverter>? Logger => s_lazyLogger.Value;
    private static readonly Dictionary<string, string?> s_badgeUrlMap = new()
    {
        { "twitch/moderator/1", "https://static-cdn.jtvnw.net/badges/v1/3267646d-33f0-4b17-b3df-f923a41db1d0/1" },
        { "twitch/subscriber/0", "https://static-cdn.jtvnw.net/badges/v1/5d9f2208-5dd8-11e7-8513-2ff4adfae661/1" },
        { "twitch/vip/1", "https://static-cdn.jtvnw.net/badges/v1/b817aba4-fad8-49e2-b88a-7cc744dfa6ec/1" },
        { "twitch/broadcaster/1", "https://static-cdn.jtvnw.net/badges/v1/5527c58c-fb7d-422d-b71b-f309dcb85cc1/1" },
        { "twitch/partner/1", "https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f6-41d0-ab77-b780518f00a3/1" },
        { "twitch/glitchcon2020/1", "https://static-cdn.jtvnw.net/badges/v1/1d4b00b9-f976-418f-8f97-3599ea8acfbb/1" },
        { "youtube/member", null },
        { "youtube/moderator", null },
        { "youtube/owner", null },
        { "youtube/verified", null },
    };
    public object? Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is string identifier && s_badgeUrlMap.TryGetValue(identifier, out string? url) && !string.IsNullOrEmpty(url))
        {
            try
            {
                return new BitmapImage(new Uri(url));
            }
            catch (FormatException uriEx)
            {
                Logger?.LogError(uriEx, "Invalid URL format for badge identifier {Identifier}. URL: {Url}", identifier, url);
                return null;
            }
            catch (Exception ex)
            {
                Logger?.LogError(ex, "Error creating BitmapImage for badge identifier {Identifier}. URL: {Url}", identifier, url);
                return null;
            }
        }
        if (value is string id)
        {
            Logger?.LogTrace("Badge identifier '{Identifier}' not found in static map or URL is null/empty.", id);
        }
        else
        {
            Logger?.LogTrace("Input value is not a string identifier. Value: {Value}", value);
        }
        return null;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language)
    {
        Logger?.LogWarning("ConvertBack called but is not implemented.");
        throw new NotImplementedException("BadgeIdentifierToUrlConverter does not support ConvertBack.");
    }
}
</file>

<file path="UI/Converters/BadgeInfoToImageSourceConverter.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Media.Imaging;
using StreamWeaver.Core.Models.Events;
using StreamWeaver.Core.Services;
namespace StreamWeaver.UI.Converters;
public partial class BadgeInfoToImageSourceConverter : IValueConverter
{
    private static readonly Lazy<ILogger<BadgeInfoToImageSourceConverter>?> s_lazyLogger = new(
        App.GetService<ILogger<BadgeInfoToImageSourceConverter>>
    );
    private static readonly Lazy<IEmoteBadgeService?> s_lazyEmoteBadgeService = new(App.GetService<IEmoteBadgeService>);
    private static ILogger<BadgeInfoToImageSourceConverter>? Logger => s_lazyLogger.Value;
    private static IEmoteBadgeService? EmoteBadgeService => s_lazyEmoteBadgeService.Value;
    public object? Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is not BadgeInfo badgeInfo)
        {
            Logger?.LogTrace("Input value is not a BadgeInfo object.");
            return null;
        }
        string? imageUrl = null;
        bool isSvg = false;
        if (!string.IsNullOrEmpty(badgeInfo.ImageUrl))
        {
            imageUrl = badgeInfo.ImageUrl;
            isSvg = imageUrl.EndsWith(".svg", StringComparison.OrdinalIgnoreCase);
            Logger?.LogTrace("Using ImageUrl from BadgeInfo for {Identifier}: {Url} (IsSvg={IsSvg})", badgeInfo.Identifier, imageUrl, isSvg);
        }
        else
        {
            if (EmoteBadgeService == null)
            {
                Logger?.LogError("Cannot lookup badge URL for {Identifier}: EmoteBadgeService is unavailable.", badgeInfo.Identifier);
                return null;
            }
            if (badgeInfo.Identifier.StartsWith("twitch/"))
            {
                string[] parts = badgeInfo.Identifier.Split('/');
                if (parts.Length == 3)
                {
                    imageUrl = EmoteBadgeService.GetTwitchBadgeUrl(parts[1], parts[2]);
                    if (imageUrl != null)
                        Logger?.LogTrace("Looked up Twitch badge URL for {Identifier}: {Url}", badgeInfo.Identifier, imageUrl);
                    else
                        Logger?.LogDebug("Badge URL lookup failed for Twitch identifier: {Identifier}", badgeInfo.Identifier);
                    isSvg = false;
                }
                else
                {
                    Logger?.LogWarning("Invalid Twitch badge identifier format for lookup: {Identifier}", badgeInfo.Identifier);
                }
            }
            else if (badgeInfo.Identifier.StartsWith("youtube/"))
            {
                Logger?.LogDebug(
                    "Service lookup for YouTube badge identifier '{Identifier}' not implemented (expected direct URL if available).",
                    badgeInfo.Identifier
                );
            }
            else
            {
                Logger?.LogWarning("Unknown platform prefix for badge identifier lookup: {Identifier}", badgeInfo.Identifier);
            }
        }
        if (!string.IsNullOrEmpty(imageUrl) && Uri.TryCreate(imageUrl, UriKind.Absolute, out Uri? imageUri))
        {
            try
            {
                if (isSvg)
                {
                    Logger?.LogTrace("Creating SvgImageSource for {Url}", imageUrl);
                    return new SvgImageSource(imageUri);
                }
                else
                {
                    Logger?.LogTrace("Creating BitmapImage for {Url}", imageUrl);
                    return new BitmapImage(imageUri);
                }
            }
            catch (Exception ex)
            {
                Logger?.LogError(
                    ex,
                    "Failed to create {SourceType} for badge {Identifier} from URL: {Url}",
                    isSvg ? "SvgImageSource" : "BitmapImage",
                    badgeInfo.Identifier,
                    imageUrl
                );
                return null;
            }
        }
        return null;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/BoolToOpacityConverter.cs">
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public class BoolToOpacityConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        bool invert = false;
        double falseOpacity = 0.5;
        if (parameter is string paramString)
        {
            string[] parts = paramString.Split(',');
            foreach (string part in parts)
            {
                if (part.Trim().Equals("Invert", StringComparison.OrdinalIgnoreCase))
                {
                    invert = true;
                }
                else if (
                    double.TryParse(
                        part.Trim(),
                        System.Globalization.NumberStyles.Any,
                        System.Globalization.CultureInfo.InvariantCulture,
                        out double opacityValue
                    )
                )
                {
                    falseOpacity = Math.Clamp(opacityValue, 0.0, 1.0);
                }
            }
        }
        bool boolValue = value is bool b && b;
        if (invert)
        {
            boolValue = !boolValue;
        }
        return boolValue ? 1.0 : falseOpacity;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/BoolToStringConverter.cs">
using Microsoft.UI.Xaml.Data;
using System;
namespace StreamWeaver.UI.Converters;
public partial class BoolToStringConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is not bool boolValue)
        {
            return string.Empty;
        }
        if (parameter is string paramString && !string.IsNullOrWhiteSpace(paramString))
        {
            string[] parts = paramString.Split(';');
            if (parts.Length == 2)
            {
                return boolValue ? parts[0] : parts[1];
            }
        }
        return boolValue.ToString();
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language)
    {
        throw new NotImplementedException();
    }
}
</file>

<file path="UI/Converters/BoolToVisibilityConverter.cs">
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public class BoolToVisibilityConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        bool invert = parameter is string s && s.Equals("Invert", StringComparison.OrdinalIgnoreCase);
        bool boolValue = value is bool b && b;
        return invert
            ? boolValue
                ? Visibility.Collapsed
                : Visibility.Visible
            : (object)(boolValue ? Visibility.Visible : Visibility.Collapsed);
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/ConnectionStatusToBrushConverter.cs">
using Microsoft.UI;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Media;
using StreamWeaver.Core.Models.Settings;
namespace StreamWeaver.UI.Converters;
public partial class ConnectionStatusToBrushConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language) =>
        value is ConnectionStatus status
            ? status switch
            {
                ConnectionStatus.Connected => new SolidColorBrush(Colors.LimeGreen),
                ConnectionStatus.Connecting => new SolidColorBrush(Colors.Orange),
                ConnectionStatus.Error => new SolidColorBrush(Colors.Red),
                ConnectionStatus.Disconnected => new SolidColorBrush(Colors.Gray),
                _ => new SolidColorBrush(Colors.Gray),
            }
            : (object)new SolidColorBrush(Colors.Gray);
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/DateTimeFormatConverter.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class DateTimeFormatConverter : IValueConverter
{
    private static readonly Lazy<ILogger<DateTimeFormatConverter>?> s_lazyLogger = new(() =>
    {
        try
        {
            return App.GetService<ILogger<DateTimeFormatConverter>>();
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"[DateTimeFormatConverter.StaticInit] Failed to get ILogger: {ex.Message}");
            return null;
        }
    });
    private static ILogger<DateTimeFormatConverter>? Logger => s_lazyLogger.Value;
    public object Convert(object? value, Type targetType, object parameter, string language)
    {
        string format = parameter as string ?? "g";
        try
        {
            switch (value)
            {
                case DateTime dt:
                    return dt.ToLocalTime().ToString(format);
                case DateTimeOffset dto:
                    return dto.LocalDateTime.ToString(format);
            }
        }
        catch (FormatException ex)
        {
            Logger?.LogError(ex, "Invalid format string provided: '{FormatString}'. Using default format 'g'.", format);
            format = "g";
            try
            {
                switch (value)
                {
                    case DateTime dtErr:
                        return dtErr.ToLocalTime().ToString(format);
                    case DateTimeOffset dtoErr:
                        return dtoErr.LocalDateTime.ToString(format);
                }
            }
            catch (Exception fallbackEx)
            {
                Logger?.LogError(fallbackEx, "Error formatting date/time value even with default format 'g'. Value: {Value}", value);
            }
        }
        catch (Exception ex)
        {
            Logger?.LogError(ex, "Failed to format date/time value. Value: {Value}, Format: {FormatString}", value, format);
        }
        Logger?.LogTrace("Value was not DateTime or DateTimeOffset, or formatting failed. Returning default ToString(). Value: {Value}", value);
        return value?.ToString() ?? string.Empty;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language)
    {
        Logger?.LogWarning("ConvertBack called but is not implemented.");
        throw new NotImplementedException("DateTimeFormatConverter does not support ConvertBack.");
    }
}
</file>

<file path="UI/Converters/EqualityToVisibilityConverter.cs">
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class EqualityToVisibilityConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        bool isEqual = value?.ToString()?.Equals(parameter?.ToString(), StringComparison.OrdinalIgnoreCase) ?? (parameter == null && value == null);
        return isEqual ? Visibility.Visible : Visibility.Collapsed;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/IntToVisibilityConverter.cs">
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class IntToVisibilityConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        bool invert = parameter is string s && s.Equals("Invert", StringComparison.OrdinalIgnoreCase);
        int count = 0;
        if (value is int i)
        {
            count = i;
        }
        bool isVisible = count > 0;
        if (invert)
        {
            isVisible = !isVisible;
        }
        return isVisible ? Visibility.Visible : Visibility.Collapsed;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/MembershipMilestoneConverter.cs">
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class MembershipMilestoneConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language) =>
        value is int months && months > 0 ? $" ({months}-Month Milestone)" : (object)string.Empty;
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/MembershipTypeToBrushConverter.cs">
using Microsoft.UI;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Media;
using StreamWeaver.Core.Models.Events;
using Windows.UI;
namespace StreamWeaver.UI.Converters;
public partial class MembershipTypeToBrushConverter : IValueConverter
{
    private static readonly Color s_baseMemberColor = Color.FromArgb(255, 15, 157, 88);
    private static readonly SolidColorBrush s_newBrush = new(Color.FromArgb(0x1A, s_baseMemberColor.R, s_baseMemberColor.G, s_baseMemberColor.B));
    private static readonly SolidColorBrush s_milestoneBrush = new(Color.FromArgb(0x26, s_baseMemberColor.R, s_baseMemberColor.G, s_baseMemberColor.B));
    private static readonly SolidColorBrush s_giftPurchaseBrush = new(Color.FromArgb(0x1A, 66, 133, 244));
    private static readonly SolidColorBrush s_giftRedemptionBrush = new(Color.FromArgb(0x1A, 219, 68, 55));
    private static readonly SolidColorBrush s_defaultBrush = new(Colors.Transparent);
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is not MembershipEventType type)
        {
            return s_defaultBrush;
        }
        return type switch
        {
            MembershipEventType.New => s_newBrush,
            MembershipEventType.Milestone => s_milestoneBrush,
            MembershipEventType.GiftPurchase => s_giftPurchaseBrush,
            MembershipEventType.GiftRedemption => s_giftRedemptionBrush,
            _ => s_defaultBrush,
        };
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) =>
        throw new NotImplementedException();
}
</file>

<file path="UI/Converters/PlatformToBrushConverter.cs">
using Microsoft.UI;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Media;
using Windows.UI;
namespace StreamWeaver.UI.Converters;
public partial class PlatformToBrushConverter : IValueConverter
{
    private static readonly SolidColorBrush s_twitchBrush = new(Color.FromArgb(255, 145, 70, 255));
    private static readonly SolidColorBrush s_youTubeBrush = new(Color.FromArgb(255, 255, 0, 0));
    private static readonly SolidColorBrush s_streamlabsBrush = new(Color.FromArgb(255, 128, 245, 160));
    private static readonly SolidColorBrush s_systemBrush = new(Colors.Gray);
    private static readonly SolidColorBrush s_defaultBrush = new(Colors.DimGray);
    public object Convert(object? value, Type targetType, object parameter, string language) =>
        (value as string)?.ToLowerInvariant() switch
        {
            "twitch" => s_twitchBrush,
            "youtube" => s_youTubeBrush,
            "streamlabs" => s_streamlabsBrush,
            "system" => s_systemBrush,
            _ => s_defaultBrush,
        };
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/PlatformToIconConverter.cs">
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class PlatformToIconConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language) =>
        (value as string) switch
        {
            "Twitch" => "\uE8A7",
            "YouTube" => "\uE714",
            "Streamlabs" => "\uE734",
            "System" => "\uE946",
            _ => "\uE9CE",
        };
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/PlatformToMarginConverter.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class PlatformToMarginConverter : IValueConverter
{
    private const double DEFAULT_LEFT_MARGIN = 42.0;
    private const double DEFAULT_TOP_MARGIN = -2.0;
    private static readonly Lazy<ILogger<PlatformToMarginConverter>?> s_lazyLogger = new(App.GetService<ILogger<PlatformToMarginConverter>>);
    private static ILogger<PlatformToMarginConverter>? Logger => s_lazyLogger.Value;
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        double topMargin = DEFAULT_TOP_MARGIN;
        double rightMargin = 0;
        double bottomMargin = 0;
        double nonYouTubeLeftMargin = DEFAULT_LEFT_MARGIN;
        if (parameter is string paramString && double.TryParse(paramString, out double paramMargin))
        {
            nonYouTubeLeftMargin = paramMargin;
        }
        double leftMargin;
        if (value is string platform)
        {
            if (platform.Equals("YouTube", StringComparison.OrdinalIgnoreCase))
            {
                leftMargin = 0;
                Logger?.LogTrace(
                    "Platform is YouTube, returning margin: {Left},{Top},{Right},{Bottom}",
                    leftMargin,
                    topMargin,
                    rightMargin,
                    bottomMargin
                );
            }
            else
            {
                leftMargin = nonYouTubeLeftMargin;
                Logger?.LogTrace(
                    "Platform is not YouTube ({Platform}), returning margin: {Left},{Top},{Right},{Bottom}",
                    platform,
                    leftMargin,
                    topMargin,
                    rightMargin,
                    bottomMargin
                );
            }
        }
        else
        {
            Logger?.LogTrace("Value is not a string ({Value}), returning default non-YouTube margin.", value);
            leftMargin = nonYouTubeLeftMargin;
        }
        return new Thickness(leftMargin, topMargin, rightMargin, bottomMargin);
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/PlatformToVisibilityConverter.cs">
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class PlatformToVisibilityConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        bool invert = parameter is string s && s.Equals("Invert", StringComparison.OrdinalIgnoreCase);
        bool isYouTube = value is string platform && platform.Equals("YouTube", StringComparison.OrdinalIgnoreCase);
        if (invert)
        {
            isYouTube = !isYouTube;
        }
        return isYouTube ? Visibility.Visible : Visibility.Collapsed;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/SegmentsToBlocksConverter.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Documents;
using Microsoft.UI.Xaml.Media;
using Microsoft.UI.Xaml.Media.Imaging;
using StreamWeaver.Core.Models.Events.Messages;
namespace StreamWeaver.UI.Converters;
public partial class SegmentsToBlocksConverter : IValueConverter
{
    private static readonly Lazy<ILogger<SegmentsToBlocksConverter>?> s_lazyLogger = new(() =>
    {
        try
        {
            return App.GetService<ILogger<SegmentsToBlocksConverter>>();
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"[SegmentsToBlocksConverter.StaticInit] Failed to get ILogger: {ex.Message}");
            return null;
        }
    });
    private static ILogger<SegmentsToBlocksConverter>? Logger => s_lazyLogger.Value;
    private const double EmoteHeight = 24;
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is not List<MessageSegment> segments || segments.Count == 0)
        {
            Logger?.LogTrace("Input value is null, not a List<MessageSegment>, or is empty. Value: {Value}", value);
            return new List<Block>();
        }
        var paragraph = new Paragraph();
        try
        {
            foreach (MessageSegment segment in segments)
            {
                if (segment is TextSegment textSegment && !string.IsNullOrEmpty(textSegment.Text))
                {
                    paragraph.Inlines.Add(new Run { Text = textSegment.Text });
                }
                else if (segment is EmoteSegment emoteSegment && !string.IsNullOrEmpty(emoteSegment.ImageUrl))
                {
                    try
                    {
                        var image = new Image
                        {
                            Source = new BitmapImage(new Uri(emoteSegment.ImageUrl)),
                            Height = EmoteHeight,
                            Width = double.NaN,
                            Stretch = Stretch.Uniform,
                            VerticalAlignment = VerticalAlignment.Bottom,
                        };
                        ToolTipService.SetToolTip(image, new ToolTip { Content = emoteSegment.Name });
                        var inlineContainer = new InlineUIContainer { Child = image };
                        paragraph.Inlines.Add(inlineContainer);
                    }
                    catch (FormatException uriEx)
                    {
                        Logger?.LogError(
                            uriEx,
                            "Invalid ImageUrl format for emote '{EmoteName}'. URL: {ImageUrl}",
                            emoteSegment.Name,
                            emoteSegment.ImageUrl
                        );
                        paragraph.Inlines.Add(new Run { Text = $"[{emoteSegment.Name}?]" });
                    }
                    catch (Exception imgEx)
                    {
                        Logger?.LogError(
                            imgEx,
                            "Error creating/loading image for emote '{EmoteName}'. URL: {ImageUrl}",
                            emoteSegment.Name,
                            emoteSegment.ImageUrl
                        );
                        paragraph.Inlines.Add(new Run { Text = $"[{emoteSegment.Name}?]" });
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Logger?.LogError(ex, "Error processing message segments.");
            var errorParagraph = new Paragraph();
            errorParagraph.Inlines.Add(new Run { Text = "[Error displaying message content]" });
            return new List<Block> { errorParagraph };
        }
        return new List<Block> { paragraph };
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language)
    {
        Logger?.LogWarning("ConvertBack called but is not implemented.");
        throw new NotImplementedException("SegmentsToBlocksConverter does not support ConvertBack.");
    }
}
</file>

<file path="UI/Converters/StringToBrushConverter.cs">
using System.Globalization;
using System.Reflection;
using Microsoft.Extensions.Logging;
using Microsoft.UI;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Media;
using Windows.UI;
namespace StreamWeaver.UI.Converters;
public partial class StringToBrushConverter : IValueConverter
{
    private static readonly Lazy<ILogger<StringToBrushConverter>?> s_lazyLogger = new(() =>
    {
        try
        {
            return App.GetService<ILogger<StringToBrushConverter>>();
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"[StringToBrushConverter.StaticInit] Failed to get ILogger: {ex.Message}");
            return null;
        }
    });
    private static ILogger<StringToBrushConverter>? Logger => s_lazyLogger.Value;
    public object Convert(object? value, Type targetType, object? parameter, string language)
    {
        if (value is string colorString && !string.IsNullOrEmpty(colorString))
        {
            try
            {
                if (colorString.StartsWith('#'))
                {
                    byte a = 255;
                    byte r,
                        g,
                        b;
                    string hex = colorString.TrimStart('#');
                    switch (hex.Length)
                    {
                        case 8:
                            a = byte.Parse(hex.AsSpan(0, 2), NumberStyles.HexNumber);
                            r = byte.Parse(hex.AsSpan(2, 2), NumberStyles.HexNumber);
                            g = byte.Parse(hex.AsSpan(4, 2), NumberStyles.HexNumber);
                            b = byte.Parse(hex.AsSpan(6, 2), NumberStyles.HexNumber);
                            break;
                        case 6:
                            r = byte.Parse(hex.AsSpan(0, 2), NumberStyles.HexNumber);
                            g = byte.Parse(hex.AsSpan(2, 2), NumberStyles.HexNumber);
                            b = byte.Parse(hex.AsSpan(4, 2), NumberStyles.HexNumber);
                            break;
                        case 3:
                            r = byte.Parse($"{hex[0]}{hex[0]}", NumberStyles.HexNumber);
                            g = byte.Parse($"{hex[1]}{hex[1]}", NumberStyles.HexNumber);
                            b = byte.Parse($"{hex[2]}{hex[2]}", NumberStyles.HexNumber);
                            break;
                        default:
                            Logger?.LogWarning("Invalid hex color string length ({Length}): {ColorString}. Using fallback.", hex.Length, colorString);
                            return GetFallbackBrush(parameter, colorString);
                    }
                    return new SolidColorBrush(Color.FromArgb(a, r, g, b));
                }
                PropertyInfo? colorProp = typeof(Colors).GetProperty(
                    colorString,
                    BindingFlags.Static | BindingFlags.Public | BindingFlags.IgnoreCase
                );
                if (colorProp?.GetValue(null) is Color namedColor)
                {
                    return new SolidColorBrush(namedColor);
                }
                else
                {
                    Logger?.LogWarning(
                        "Color string '{ColorString}' is not a valid hex code or recognized named color. Using fallback.",
                        colorString
                    );
                }
            }
            catch (FormatException formatEx)
            {
                Logger?.LogError(formatEx, "Format exception converting color string '{ColorString}'. Using fallback.", colorString);
            }
            catch (Exception ex)
            {
                Logger?.LogError(ex, "Error converting color string '{ColorString}'. Using fallback.", colorString);
            }
        }
        else if (value != null)
        {
            Logger?.LogDebug("Input value is not a string. Value type: {ValueType}. Using fallback.", value.GetType().Name);
        }
        return GetFallbackBrush(parameter, value?.ToString());
    }
    private SolidColorBrush GetFallbackBrush(object? parameter, string? originalValueForLog = null)
    {
        Logger?.LogTrace(
            "Using fallback brush for original value '{OriginalValue}'. Fallback Parameter: {FallbackParameter}",
            originalValueForLog ?? "null",
            parameter ?? "null"
        );
        if (parameter is SolidColorBrush brush)
            return brush;
        if (parameter is Color color)
            return new SolidColorBrush(color);
        if (parameter is string colorString)
        {
            object fallback = Convert(colorString, typeof(SolidColorBrush), null, "");
            if (fallback is SolidColorBrush sb)
                return sb;
        }
        return new SolidColorBrush(Colors.Gray);
    }
    /// <summary>
    /// Converts a value back - Not implemented for this converter.
    /// </summary>
    /// <exception cref="NotImplementedException">Always thrown.</exception>
    public object ConvertBack(object value, Type targetType, object? parameter, string language)
    {
        Logger?.LogWarning("ConvertBack called but is not implemented.");
        throw new NotImplementedException("StringToBrushConverter does not support ConvertBack.");
    }
}
</file>

<file path="UI/Converters/StringToVisibilityConverter.cs">
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class StringToVisibilityConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        bool invert = parameter is string s && s.Equals("Invert", StringComparison.OrdinalIgnoreCase);
        bool isVisible = !string.IsNullOrEmpty(value as string);
        if (invert)
        {
            isVisible = !isVisible;
        }
        return isVisible ? Visibility.Visible : Visibility.Collapsed;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/SubEventDurationConverter.cs">
using Microsoft.UI.Xaml.Data;
using StreamWeaver.Core.Models.Events;
namespace StreamWeaver.UI.Converters;
public partial class SubEventDurationConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is SubscriptionEvent subEvent)
        {
            if (subEvent.IsGift)
            {
                if (subEvent.Months > 1)
                    return $" ({subEvent.Months} months)";
            }
            else
            {
                if (subEvent.CumulativeMonths > 1)
                    return $" for {subEvent.CumulativeMonths} months!";
            }
        }
        return string.Empty;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/SubEventMessageConverter.cs">
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class SubEventMessageConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is string message && !string.IsNullOrEmpty(message))
        {
            bool addQuotes = (parameter as string) != "NoQuotes";
            return addQuotes ? $" \"{message}\"" : $" {message}";
        }
        return string.Empty;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/SubEventTotalGiftsConverter.cs">
using Microsoft.UI.Xaml.Data;
using StreamWeaver.Core.Models.Events;
namespace StreamWeaver.UI.Converters;
public partial class SubEventTotalGiftsConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is SubscriptionEvent subEvent && subEvent.IsGift && subEvent.TotalGiftCount > 0)
        {
            if (subEvent.GiftCount != subEvent.TotalGiftCount)
            {
                return $" (Total Gifts: {subEvent.TotalGiftCount})";
            }
        }
        return string.Empty;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/SubEventVerbConverter.cs">
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public class SubEventVerbConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language) =>
        value is bool isGift
            ? isGift
                ? " gifted a "
                : " subscribed with a "
            : (object)" subscribed with a ";
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/SystemMessageLevelToBrushConverter.cs">
using Microsoft.UI;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Media;
using StreamWeaver.Core.Models.Events;
namespace StreamWeaver.UI.Converters;
public class SystemMessageLevelToBrushConverter : IValueConverter
{
    private static readonly SolidColorBrush InfoBrush = new(Colors.CornflowerBlue);
    private static readonly SolidColorBrush WarningBrush = new(Colors.Orange);
    private static readonly SolidColorBrush ErrorBrush = new(Colors.Red);
    private static readonly SolidColorBrush DefaultBrush = new(Colors.Gray);
    public object Convert(object value, Type targetType, object parameter, string language) =>
        value is SystemMessageLevel level
            ? level switch
            {
                SystemMessageLevel.Info => InfoBrush,
                SystemMessageLevel.Warning => WarningBrush,
                SystemMessageLevel.Error => ErrorBrush,
                _ => DefaultBrush,
            }
            : (object)DefaultBrush;
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/SystemMessageLevelToSymbolConverter.cs">
using Microsoft.UI.Xaml.Data;
using StreamWeaver.Core.Models.Events;
namespace StreamWeaver.UI.Converters;
public class SystemMessageLevelToSymbolConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is SystemMessageLevel level)
        {
            return level switch
            {
                SystemMessageLevel.Info => "\uE946",
                SystemMessageLevel.Warning => "\uE7BA",
                SystemMessageLevel.Error => "\uEA39",
                _ => "\uE946",
            };
        }
        return "\uE946";
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Dialogs/ConnectAccountDialog.xaml">
<?xml version="1.0" encoding="utf-8"?>
<ContentDialog
        x:Class="StreamWeaver.UI.Views.ConnectAccountDialog"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="using:StreamWeaver.UI.Views"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        xmlns:viewmodels="using:StreamWeaver.UI.ViewModels"
        d:DataContext="{d:DesignInstance Type=viewmodels:ConnectAccountViewModel}"
        Title="Connect Account"
        PrimaryButtonText="Connect"
        CloseButtonText="Cancel"
        DefaultButton="Primary"
        PrimaryButtonClick="ContentDialog_PrimaryButtonClick"
        CloseButtonClick="ContentDialog_CloseButtonClick">

        <StackPanel Spacing="10">
                <TextBlock Text="{Binding DialogTitle}"
                           Style="{StaticResource BaseTextBlockStyle}"
                           Margin="0,0,0,10"/>
                <TextBlock Text="{Binding Description}"
                           TextWrapping="Wrap"
                           Margin="0,0,0,10"/>

                <StackPanel Visibility="{Binding IsStreamlabs, Converter={StaticResource BoolToVisibilityConverter}}">
                        <TextBlock Text="Streamlabs requires a Socket API Token."/>
                        <PasswordBox Header="Streamlabs Socket API Token"
                                     Password="{Binding StreamlabsToken, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>
                        <HyperlinkButton Content="Where do I find this?"
                                         NavigateUri="https://streamlabs.com/dashboard#/settings/api-settings"/>
                </StackPanel>

                <InfoBar Title="Authentication Note"
                         Severity="Informational"
                         Message="For Twitch and YouTube, clicking 'Connect' will open your web browser for secure authentication."
                         IsOpen="{Binding IsOAuthPlatform}"/>

                <InfoBar Title="Error"
                         Severity="Error"
                         Message="{Binding ErrorMessage}"
                         IsOpen="{Binding HasError}"
                         Margin="0,10,0,0"/>

        </StackPanel>
</ContentDialog>
</file>

<file path="UI/Dialogs/ConnectAccountDialog.xaml.cs">
using Microsoft.UI.Xaml.Controls;
using StreamWeaver.UI.ViewModels;
namespace StreamWeaver.UI.Views;
public sealed partial class ConnectAccountDialog : ContentDialog
{
    internal ConnectAccountViewModel ViewModel =>
        DataContext as ConnectAccountViewModel ?? throw new InvalidOperationException("DataContext must be ConnectAccountViewModel");
    public ConnectAccountDialog() => this.InitializeComponent();
    private async void ContentDialog_PrimaryButtonClick(ContentDialog sender, ContentDialogButtonClickEventArgs args)
    {
        ContentDialogButtonClickDeferral deferral = args.GetDeferral();
        try
        {
            bool success = await ViewModel.HandleConnectAsync();
            if (!success)
            {
                args.Cancel = true;
            }
        }
        finally
        {
            deferral.Complete();
        }
    }
    private void ContentDialog_CloseButtonClick(ContentDialog sender, ContentDialogButtonClickEventArgs args) => ViewModel.HandleCancel();
}
</file>

<file path="UI/Dialogs/CreatePollDialog.xaml">
<?xml version="1.0" encoding="utf-8"?>
<ContentDialog
    x:Class="StreamWeaver.UI.Dialogs.CreatePollDialog"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:viewmodels="using:StreamWeaver.UI.ViewModels"
    mc:Ignorable="d"
    d:DataContext="{d:DesignInstance Type=viewmodels:CreatePollDialogViewModel}"
    x:Name="CreatePollContentDialog"
    Title="Create YouTube Poll"
    PrimaryButtonText="Create"
    CloseButtonText="Cancel"
    DefaultButton="Primary"
    PrimaryButtonClick="ContentDialog_PrimaryButtonClick">

    <ContentDialog.Resources>
        <Style x:Key="RemoveButtonStyle" TargetType="Button">
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Padding" Value="4"/>
            <Setter Property="VerticalAlignment" Value="Center"/>
            <Setter Property="Foreground" Value="{ThemeResource SystemControlErrorTextForegroundBrush}"/>
        </Style>
    </ContentDialog.Resources>

    <StackPanel Spacing="10" MinWidth="400">

        <InfoBar Title="Error"
                 Severity="Error"
                 Message="{Binding ErrorMessage}"
                 IsOpen="{Binding HasError}"
                 IsClosable="False"/>

        <TextBox Header="Poll Question (Max 100 chars)"
                 Text="{Binding Question, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                 MaxLength="100"
                 TextWrapping="Wrap"
                 AcceptsReturn="True"
                 Height="80"/>

        <TextBlock Text="Options (2-5 required, Max 30 chars each)"
                   Style="{ThemeResource BodyStrongTextBlockStyle}"/>

        <ListView ItemsSource="{Binding Options}"
                  SelectionMode="None"
                  MaxHeight="200">
            <ListView.ItemTemplate>
                <DataTemplate x:DataType="viewmodels:PollOptionViewModel">
                    <Grid ColumnSpacing="5">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>

                        <TextBox Grid.Column="0"
                                 Text="{Binding Text, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                                 MaxLength="30"
                                 PlaceholderText="Enter option text..."/>

                        <Button Grid.Column="1"
                                Style="{StaticResource RemoveButtonStyle}"
                                Command="{Binding DataContext.RemoveOptionCommand, ElementName=CreatePollContentDialog}"
                            CommandParameter="{Binding}">
                            <ToolTipService.ToolTip>
                                <ToolTip Content="Remove this option"/>
                            </ToolTipService.ToolTip>
                            <FontIcon FontFamily="{StaticResource SymbolThemeFontFamily}" Glyph="" FontSize="14"/>
                        </Button>
                    </Grid>
                </DataTemplate>
            </ListView.ItemTemplate>
        </ListView>

        <Button Content="Add Option"
                HorizontalAlignment="Left"
                Command="{Binding AddOptionCommand}">
            <ToolTipService.ToolTip>
                <ToolTip Content="Add another poll option (max 5)"/>
            </ToolTipService.ToolTip>
        </Button>
    </StackPanel>
</ContentDialog>
</file>

<file path="UI/Dialogs/CreatePollDialog.xaml.cs">
using Microsoft.UI.Xaml.Controls;
using StreamWeaver.UI.ViewModels;
namespace StreamWeaver.UI.Dialogs;
public sealed partial class CreatePollDialog : ContentDialog
{
    internal CreatePollDialogViewModel ViewModel =>
        DataContext as CreatePollDialogViewModel ?? throw new InvalidOperationException("DataContext must be CreatePollDialogViewModel");
    public CreatePollDialog() => this.InitializeComponent();
    private void ContentDialog_PrimaryButtonClick(ContentDialog sender, ContentDialogButtonClickEventArgs args)
    {
        ContentDialogButtonClickDeferral deferral = args.GetDeferral();
        try
        {
            if (!ViewModel.TryGetValidatedData(out _, out _))
            {
                args.Cancel = true;
            }
        }
        finally
        {
            deferral.Complete();
        }
    }
}
</file>

<file path="UI/Helpers/RichTextBlockEventHelper.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI.Dispatching;
using Microsoft.UI.Text;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Documents;
using Microsoft.UI.Xaml.Media;
using Microsoft.UI.Xaml.Media.Imaging;
using StreamWeaver.Core.Models.Events;
using StreamWeaver.Core.Models.Events.Messages;
using StreamWeaver.UI.Converters;
using Windows.UI.Text;
namespace StreamWeaver.UI.Helpers;
public class RichTextBlockEventHelper
{
    private static readonly Lazy<ILogger<RichTextBlockEventHelper>?> s_lazyLogger = new(App.GetService<ILogger<RichTextBlockEventHelper>>);
    private static readonly Lazy<PlatformToBrushConverter> s_platformBrushConverter = new();
    private static readonly Lazy<StringToBrushConverter> s_stringBrushConverter = new();
    private static readonly Lazy<BadgeInfoToImageSourceConverter> s_badgeConverter = new();
    private static readonly Lazy<DateTimeFormatConverter> s_timeConverter = new();
    private static ILogger<RichTextBlockEventHelper>? Logger => s_lazyLogger.Value;
    private static readonly SolidColorBrush s_ownerBackgroundBrush = new(Microsoft.UI.Colors.Gold);
    private static readonly SolidColorBrush s_ownerForegroundBrush = new(Microsoft.UI.Colors.Black);
    private static readonly SolidColorBrush s_defaultUsernameFallbackBrush = (SolidColorBrush)
        Application.Current.Resources["SystemControlForegroundBaseMediumBrush"];
    public static readonly DependencyProperty ChatEventSourceProperty = DependencyProperty.RegisterAttached(
        "ChatEventSource",
        typeof(ChatMessageEvent),
        typeof(RichTextBlockEventHelper),
        new PropertyMetadata(null, OnChatEventSourceChanged)
    );
    public static ChatMessageEvent GetChatEventSource(DependencyObject obj) => (ChatMessageEvent)obj.GetValue(ChatEventSourceProperty);
    public static void SetChatEventSource(DependencyObject obj, ChatMessageEvent value) => obj.SetValue(ChatEventSourceProperty, value);
    private static void OnChatEventSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        if (d is not RichTextBlock richTextBlock)
        {
            Logger?.LogWarning("ChatEventSource attached property used on a non-RichTextBlock element.");
            return;
        }
        DispatcherQueue dispatcherQueue = richTextBlock.DispatcherQueue ?? DispatcherQueue.GetForCurrentThread();
        if (dispatcherQueue == null)
        {
            Logger?.LogError("Could not get DispatcherQueue for RichTextBlock. Cannot update content.");
            return;
        }
        bool enqueued = dispatcherQueue.TryEnqueue(() =>
        {
            richTextBlock.Blocks.Clear();
            if (e.NewValue is ChatMessageEvent chatEvent)
            {
                Paragraph? paragraph = BuildParagraph(chatEvent);
                if (paragraph != null)
                {
                    try
                    {
                        richTextBlock.Blocks.Add(paragraph);
                    }
                    catch (Exception ex)
                    {
                        Logger?.LogError(ex, "Error adding Paragraph to RichTextBlock for Event ID: {EventId}", chatEvent.Id);
                        richTextBlock.Blocks.Clear();
                        Paragraph errorParagraph = new();
                        errorParagraph.Inlines.Add(new Run { Text = "[Display Error]", Foreground = new SolidColorBrush(Microsoft.UI.Colors.Red) });
                        richTextBlock.Blocks.Add(errorParagraph);
                    }
                }
            }
        });
        if (!enqueued)
        {
            Logger?.LogError("Failed to enqueue RichTextBlock update.");
        }
    }
    private static Paragraph? BuildParagraph(ChatMessageEvent chatEvent)
    {
        Logger?.LogTrace(
            "BuildParagraph START for Event ID: {EventId}, IsOwner={IsOwner}, Username={Username}",
            chatEvent?.Id,
            chatEvent?.IsOwner,
            chatEvent?.Username
        );
        Paragraph paragraph = new() { LineStackingStrategy = LineStackingStrategy.BlockLineHeight };
        InlineCollection inlines = paragraph.Inlines;
        Brush fallbackUsernameBrush =
            (Brush?)s_stringBrushConverter.Value.Convert(chatEvent?.UsernameColor, typeof(Brush), s_defaultUsernameFallbackBrush, "")
            ?? s_defaultUsernameFallbackBrush;
        Brush effectiveBadgeColor = (chatEvent?.IsOwner ?? false) ? s_ownerForegroundBrush : fallbackUsernameBrush;
        try
        {
            // 1. Timestamp
            var timestampRun = new Run
            {
                Text = (string)s_timeConverter.Value.Convert(chatEvent?.Timestamp, typeof(string), "HH:mm", ""),
                FontSize = 10,
                Foreground = (SolidColorBrush)Application.Current.Resources["SystemControlPageTextBaseMediumBrush"],
            };
            inlines.Add(timestampRun);
            inlines.Add(new Run { Text = " " });
            var platformIcon = new FontIcon
            {
                FontFamily = (FontFamily)Application.Current.Resources["SymbolThemeFontFamily"],
                Glyph = GetPlatformGlyph(chatEvent?.Platform),
                FontSize = 14,
                Foreground = (Brush)s_platformBrushConverter.Value.Convert(chatEvent?.Platform, typeof(Brush), null!, ""),
                Margin = new Thickness(0, 0, 4, -2),
            };
            ToolTipService.SetToolTip(platformIcon, new ToolTip { Content = chatEvent?.Platform });
            var platformIconContainer = new InlineUIContainer { Child = platformIcon };
            inlines.Add(platformIconContainer);
            // 3. Username (Handle Owner Styling with Border)
            if (chatEvent?.IsOwner ?? false)
            {
                var ownerUsernameTextBlock = new TextBlock
                {
                    Text = chatEvent.Username,
                    FontWeight = FontWeights.SemiBold,
                    Foreground = s_ownerForegroundBrush,
                };
                var ownerUsernameBorder = new Border
                {
                    Background = s_ownerBackgroundBrush,
                    CornerRadius = new CornerRadius(2),
                    Padding = new Thickness(3, 0, 3, 1),
                    Child = ownerUsernameTextBlock,
                    VerticalAlignment = VerticalAlignment.Center,
                    Margin = new Thickness(0, 0, 0, -2),
                };
                var ownerUsernameContainer = new InlineUIContainer { Child = ownerUsernameBorder };
                Logger?.LogTrace("Adding Owner Username Container...");
                inlines.Add(ownerUsernameContainer);
            }
            else
            {
                // Add standard username Run using the calculated brush
                var usernameRun = new Run
                {
                    Text = chatEvent?.Username,
                    FontWeight = FontWeights.SemiBold,
                    Foreground = fallbackUsernameBrush,
                };
                Logger?.LogTrace("Adding Standard Username Run with calculated color.");
                inlines.Add(usernameRun);
            }
            // 4. Badges
            if (chatEvent?.Badges != null && chatEvent.Badges.Count > 0)
            {
                inlines.Add(new Run { Text = " " }); // Space after Username
                for (int i = 0; i < chatEvent.Badges.Count; i++)
                {
                    BadgeInfo badgeInfo = chatEvent.Badges[i];
                    FrameworkElement? badgeElement = null;
                    Logger?.LogTrace(
                        "Processing badge {Index}: {Identifier} (HasURL={HasUrl})",
                        i,
                        badgeInfo.Identifier,
                        !string.IsNullOrEmpty(badgeInfo.ImageUrl)
                    );
                    // --- Attempt to get ImageSource using the converter first ---
                    ImageSource? badgeImageSource = (ImageSource?)s_badgeConverter.Value.Convert(badgeInfo, typeof(ImageSource), null!, "");
                    if (badgeImageSource != null)
                    {
                        // --- Use Image or SvgImageSource from Converter ---
                        if (badgeImageSource is SvgImageSource svgSource)
                        {
                            // Use a standard Image control to display the SvgImageSource
                            badgeElement = new Image
                            {
                                Source = svgSource,
                                Height = 18,
                                Width = 18,
                                VerticalAlignment = VerticalAlignment.Center,
                                Margin = new Thickness(0, 0, i < chatEvent.Badges.Count - 1 ? 2 : 3, -2),
                            };
                            Logger?.LogTrace("--> Using SvgImageSource for {Identifier} from converter.", badgeInfo.Identifier);
                        }
                        else // Assume BitmapImage or other non-SVG source
                        {
                            badgeElement = new Image
                            {
                                Source = badgeImageSource,
                                Height = 18,
                                Width = 18,
                                VerticalAlignment = VerticalAlignment.Center,
                                Margin = new Thickness(0, 0, i < chatEvent.Badges.Count - 1 ? 2 : 3, -2),
                            };
                            Logger?.LogTrace("--> Using BitmapImage for {Identifier} from converter.", badgeInfo.Identifier);
                        }
                    }
                    else
                    {
                        // --- Converter failed or returned null, try fallback to standard FontIcon glyphs ---
                        string glyph = GetStandardYouTubeBadgeGlyph(badgeInfo.Identifier); // Check only YT standard glyphs
                        if (!string.IsNullOrEmpty(glyph))
                        {
                            badgeElement = new FontIcon
                            {
                                FontFamily = (FontFamily)Application.Current.Resources["SymbolThemeFontFamily"],
                                Glyph = glyph,
                                FontSize = 16,
                                Foreground =
                                    badgeInfo.Identifier == "youtube/verified/1"
                                        ? (SolidColorBrush)Application.Current.Resources["SystemControlPageTextBaseMediumBrush"]
                                        : effectiveBadgeColor,
                                Margin = new Thickness(0, 0, i < chatEvent.Badges.Count - 1 ? 2 : 3, -2),
                                VerticalAlignment = VerticalAlignment.Center,
                            };
                            Logger?.LogTrace(
                                "--> Converter failed/null for {Identifier}, using FontIcon fallback (Glyph: {Glyph}).",
                                badgeInfo.Identifier,
                                glyph
                            );
                        }
                        else
                        {
                            Logger?.LogWarning(
                                "--> Could not resolve badge '{Identifier}' via converter or standard glyph fallback. Skipping badge.",
                                badgeInfo.Identifier
                            );
                        }
                    }
                    if (badgeElement != null)
                    {
                        ToolTipService.SetToolTip(badgeElement, new ToolTip { Content = badgeInfo.Identifier });
                        inlines.Add(new InlineUIContainer { Child = badgeElement });
                    }
                }
            }
            if (!chatEvent?.IsActionMessage ?? false)
            {
                inlines.Add(new Run { Text = ": " });
            }
            else
            {
                inlines.Add(new Run { Text = " " });
            }
            if (chatEvent?.ParsedMessage != null)
            {
                if (chatEvent.IsActionMessage)
                {
                    var span = new Span { FontStyle = FontStyle.Italic };
                    PopulateInlinesFromSegments(span.Inlines, chatEvent.ParsedMessage);
                    inlines.Add(span);
                }
                else
                {
                    PopulateInlinesFromSegments(inlines, chatEvent.ParsedMessage);
                }
            }
            Logger?.LogTrace("BuildParagraph END for Event ID: {EventId}. Inline count: {Count}", chatEvent?.Id, inlines.Count);
            return paragraph;
        }
        catch (Exception ex)
        {
            Logger?.LogError(ex, "Error building Paragraph for ChatMessageEvent (ID: {EventId})", chatEvent?.Id);
            Paragraph errorParagraph = new();
            errorParagraph.Inlines.Add(new Run { Text = "[Error building message]", Foreground = new SolidColorBrush(Microsoft.UI.Colors.Red) });
            return errorParagraph;
        }
    }
    private static void PopulateInlinesFromSegments(InlineCollection targetInlines, List<MessageSegment> segments)
    {
        for (int i = 0; i < segments.Count; i++)
        {
            MessageSegment segment = segments[i];
            if (segment is TextSegment textSegment && !string.IsNullOrEmpty(textSegment.Text))
            {
                targetInlines.Add(new Run { Text = textSegment.Text });
            }
            else if (segment is EmoteSegment emoteSegment && !string.IsNullOrEmpty(emoteSegment.ImageUrl))
            {
                try
                {
                    var image = new Image
                    {
                        Source = new BitmapImage(new Uri(emoteSegment.ImageUrl)),
                        Height = 24,
                        Width = double.NaN,
                        Stretch = Stretch.Uniform,
                        VerticalAlignment = VerticalAlignment.Bottom,
                        Margin = new Thickness(1, 0, 1, -5),
                    };
                    ToolTipService.SetToolTip(image, new ToolTip { Content = emoteSegment.Name });
                    targetInlines.Add(new InlineUIContainer { Child = image });
                }
                catch (Exception imgEx)
                {
                    Logger?.LogError(imgEx, "Error creating image for emote {EmoteName}", emoteSegment.Name);
                    targetInlines.Add(new Run { Text = $"[{emoteSegment.Name}?]" });
                }
            }
            else
            {
                Logger?.LogWarning(
                    "Unknown or empty segment type encountered during inline population: {SegmentType}",
                    segment?.GetType().Name ?? "null"
                );
            }
        }
    }
    private static string GetStandardYouTubeBadgeGlyph(string identifier) =>
        identifier switch
        {
            "youtube/owner/1" => "\uE736",
            "youtube/moderator/1" => "\uE90F",
            "youtube/verified/1" => "\uE73E",
            _ => "", // No glyph for unknown or non-standard YT badges (like member)
        };
    // Helper method to get platform icon glyph
    private static string GetPlatformGlyph(string? platform) =>
        platform?.ToLowerInvariant() switch
        {
            // Consider more specific platform icons if available
            "twitch" => "\uE90A",
            "youtube" => "\uE786",
            _ => "\uE783",
        };
}
</file>

<file path="UI/Helpers/RichTextBlocksHelper.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Documents;
using Microsoft.UI.Xaml.Media;
using Microsoft.UI.Xaml.Media.Imaging;
using StreamWeaver.Core.Models.Events.Messages;
namespace StreamWeaver.UI.Helpers;
public class RichTextBlockHelper
{
    private static readonly Lazy<ILogger<RichTextBlockHelper>?> s_lazyLogger = new(() =>
    {
        try
        {
            return App.GetService<ILogger<RichTextBlockHelper>>();
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"[RichTextBlockHelper.StaticInit] Failed to get ILogger: {ex.Message}");
            return null;
        }
    });
    private static ILogger<RichTextBlockHelper>? Logger => s_lazyLogger.Value;
    public static readonly DependencyProperty SegmentsSourceProperty = DependencyProperty.RegisterAttached(
        "SegmentsSource",
        typeof(IEnumerable<MessageSegment>),
        typeof(RichTextBlockHelper),
        new PropertyMetadata(null, OnSegmentsSourceChanged)
    );
    public static IEnumerable<MessageSegment>? GetSegmentsSource(DependencyObject obj) =>
        (IEnumerable<MessageSegment>?)obj.GetValue(SegmentsSourceProperty);
    public static void SetSegmentsSource(DependencyObject obj, IEnumerable<MessageSegment>? value) => obj.SetValue(SegmentsSourceProperty, value);
    private static void OnSegmentsSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        if (d is not RichTextBlock richTextBlock)
        {
            Logger?.LogWarning(
                "SegmentsSource attached property used on a non-RichTextBlock element of type {ElementType}. Ignoring change.",
                d.GetType().Name
            );
            return;
        }
        var segments = e.NewValue as IEnumerable<MessageSegment>;
        GenerateRichTextBlockContent(richTextBlock, segments);
    }
    private static void GenerateRichTextBlockContent(RichTextBlock richTextBlock, IEnumerable<MessageSegment>? segments)
    {
        richTextBlock.Blocks.Clear();
        if (segments == null)
        {
            Logger?.LogTrace("Segments collection is null. RichTextBlock cleared.");
            return;
        }
        var paragraph = new Paragraph();
        bool paragraphHasContent = false;
        try
        {
            foreach (MessageSegment segment in segments)
            {
                if (segment is TextSegment textSegment && !string.IsNullOrEmpty(textSegment.Text))
                {
                    paragraph.Inlines.Add(new Run { Text = textSegment.Text });
                    paragraphHasContent = true;
                }
                else if (segment is EmoteSegment emoteSegment && !string.IsNullOrEmpty(emoteSegment.ImageUrl))
                {
                    try
                    {
                        var image = new Image
                        {
                            Source = new BitmapImage(new Uri(emoteSegment.ImageUrl)),
                            Height = 24,
                            Width = double.NaN,
                            Stretch = Stretch.Uniform,
                            VerticalAlignment = VerticalAlignment.Center,
                            Margin = new Thickness(1, 0, 1, -8),
                        };
                        ToolTipService.SetToolTip(image, new ToolTip { Content = emoteSegment.Name });
                        var inlineContainer = new InlineUIContainer { Child = image };
                        paragraph.Inlines.Add(inlineContainer);
                        paragraphHasContent = true;
                    }
                    catch (FormatException uriEx)
                    {
                        Logger?.LogError(
                            uriEx,
                            "Invalid ImageUrl format for emote '{EmoteName}'. URL: {ImageUrl}",
                            emoteSegment.Name,
                            emoteSegment.ImageUrl
                        );
                        paragraph.Inlines.Add(new Run { Text = $"[{emoteSegment.Name}?]" });
                        paragraphHasContent = true;
                    }
                    catch (Exception imgEx)
                    {
                        Logger?.LogError(
                            imgEx,
                            "Error creating/loading image for emote '{EmoteName}'. URL: {ImageUrl}",
                            emoteSegment.Name,
                            emoteSegment.ImageUrl
                        );
                        paragraph.Inlines.Add(new Run { Text = $"[{emoteSegment.Name}?]" });
                        paragraphHasContent = true;
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Logger?.LogError(ex, "Error processing segments collection.");
            paragraph.Inlines.Clear();
            paragraph.Inlines.Add(new Run { Text = "[Error displaying message content]" });
            paragraphHasContent = true;
        }
        if (paragraphHasContent)
        {
            richTextBlock.Blocks.Add(paragraph);
        }
    }
}
</file>

<file path="UI/Selectors/MessageSegmentTemplateSelector.cs">
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using StreamWeaver.Core.Models.Events.Messages;
namespace StreamWeaver.UI.Selectors;
public partial class MessageSegmentTemplateSelector : DataTemplateSelector
{
    public DataTemplate? TextSegmentTemplate { get; set; }
    public DataTemplate? EmoteSegmentTemplate { get; set; }
    protected override DataTemplate? SelectTemplateCore(object item) =>
        item switch
        {
            TextSegment _ => TextSegmentTemplate,
            EmoteSegment _ => EmoteSegmentTemplate,
            _ => base.SelectTemplateCore(item),
        };
    protected override DataTemplate? SelectTemplateCore(object item, DependencyObject container) => SelectTemplateCore(item);
}
</file>

<file path="UI/Selectors/SettingsSectionTemplateSelector.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using StreamWeaver.UI.ViewModels;
namespace StreamWeaver.UI.Selectors;
public partial class SettingsSectionTemplateSelector : DataTemplateSelector
{
    private static readonly Lazy<ILogger<SettingsSectionTemplateSelector>?> s_lazyLogger = new(() =>
    {
        try
        {
            return App.GetService<ILogger<SettingsSectionTemplateSelector>>();
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"[SettingsSectionTemplateSelector.StaticInit] Failed to get ILogger: {ex.Message}");
            return null;
        }
    });
    private static ILogger<SettingsSectionTemplateSelector>? Logger => s_lazyLogger.Value;
    public DataTemplate? CredentialsTemplate { get; set; }
    public DataTemplate? AccountsTemplate { get; set; }
    public DataTemplate? OverlaysTemplate { get; set; }
    public DataTemplate? TTSTemplate { get; set; }
    public DataTemplate? ModulesTemplate { get; set; }
    public DataTemplate? DefaultTemplate { get; set; }
    protected override DataTemplate? SelectTemplateCore(object item)
    {
        if (item is SettingsSection section && section.Tag != null)
        {
            DataTemplate? selectedTemplate = section.Tag switch
            {
                "Credentials" => CredentialsTemplate,
                "Accounts" => AccountsTemplate,
                "Overlays" => OverlaysTemplate,
                "TTS" => TTSTemplate,
                "Modules" => ModulesTemplate,
                _ => DefaultTemplate,
            };
            return selectedTemplate ?? DefaultTemplate ?? base.SelectTemplateCore(item);
        }
        Logger?.LogWarning(
            "Item is not a SettingsSection or its Tag is null. Item type: {ItemType}. Using fallback template.",
            item?.GetType().Name ?? "null"
        );
        return DefaultTemplate ?? base.SelectTemplateCore(item);
    }
    protected override DataTemplate? SelectTemplateCore(object item, DependencyObject container) => SelectTemplateCore(item);
}
</file>

<file path="UI/ViewModels/ConnectAccountViewModel.cs">
using CommunityToolkit.Mvvm.ComponentModel;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Models.Settings;
using StreamWeaver.Core.Services.Authentication;
using StreamWeaver.Core.Services.Settings;
namespace StreamWeaver.UI.ViewModels;
public enum AccountType
{
    Twitch,
    YouTube,
    Streamlabs,
}
public partial class ConnectAccountViewModel : ObservableObject
{
    private readonly ILogger<ConnectAccountViewModel> _logger;
    private readonly IServiceProvider _serviceProvider;
    private readonly AccountType _accountType;
    [ObservableProperty]
    public partial string DialogTitle { get; set; } = "Connect Account";
    [ObservableProperty]
    public partial string Description { get; set; } = string.Empty;
    [ObservableProperty]
    public partial bool IsStreamlabs { get; set; } = false;
    [ObservableProperty]
    public partial bool IsOAuthPlatform { get; set; } = false;
    [ObservableProperty]
    public partial string? StreamlabsToken { get; set; }
    [ObservableProperty]
    public partial string? ErrorMessage { get; set; }
    [ObservableProperty]
    public partial bool HasError { get; set; } = false;
    public ConnectAccountViewModel(ILogger<ConnectAccountViewModel> logger, AccountType accountType, IServiceProvider serviceProvider)
    {
        _logger = logger;
        _accountType = accountType;
        _serviceProvider = serviceProvider;
        SetupDialog();
    }
    private void SetupDialog()
    {
        IsStreamlabs = _accountType == AccountType.Streamlabs;
        IsOAuthPlatform = _accountType is AccountType.Twitch or AccountType.YouTube;
        DialogTitle = $"Connect {_accountType}";
        Description = _accountType switch
        {
            AccountType.Streamlabs =>
                "Enter your Streamlabs Socket API Token to receive donation and other alerts. Find this in your Streamlabs dashboard under Settings > API Settings > API Tokens > Socket API Token.",
            AccountType.Twitch => "Authenticate with Twitch to enable chat integration, event handling, and sending messages.",
            AccountType.YouTube => "Authenticate with YouTube to enable live chat integration, event handling, and sending messages.",
            _ => "Connect your account.",
        };
        _logger.LogDebug(
            "Dialog setup complete for {AccountType}. IsStreamlabs={IsStreamlabs}, IsOAuth={IsOAuth}",
            _accountType,
            IsStreamlabs,
            IsOAuthPlatform
        );
    }
    public async Task<bool> HandleConnectAsync()
    {
        ErrorMessage = null;
        HasError = false;
        _logger.LogInformation("Handling connect action for {AccountType}.", _accountType);
        try
        {
            return _accountType switch
            {
                AccountType.Streamlabs => await ConnectStreamlabsAsync(),
                AccountType.Twitch => await ConnectTwitchAsync(),
                AccountType.YouTube => await ConnectYouTubeAsync(),
                _ => throw new InvalidOperationException($"Unsupported account type: {_accountType}"),
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An unexpected error occurred during connect handle for {AccountType}", _accountType);
            SetError($"An unexpected error occurred: {ex.Message}");
            return false;
        }
    }
    private async Task<bool> ConnectStreamlabsAsync()
    {
        if (string.IsNullOrWhiteSpace(StreamlabsToken))
        {
            SetError("Streamlabs Socket API Token cannot be empty.");
            return false;
        }
        _logger.LogInformation("Attempting to save Streamlabs token.");
        ITokenStorageService tokenStorage = (ITokenStorageService)_serviceProvider.GetService(typeof(ITokenStorageService))!;
        ISettingsService settingsService = (ISettingsService)_serviceProvider.GetService(typeof(ISettingsService))!;
        string streamlabsStorageKey = "streamlabs_main_socket_token";
        try
        {
            await tokenStorage.SaveTokensAsync(streamlabsStorageKey, StreamlabsToken, null);
            AppSettings settings = await settingsService.LoadSettingsAsync();
            settings.Connections.StreamlabsTokenId = streamlabsStorageKey;
            settings.Connections.EnableStreamlabs = true;
            await settingsService.SaveSettingsAsync(settings);
            _logger.LogInformation("Streamlabs token saved securely and settings updated to enable Streamlabs.");
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to save Streamlabs token or update settings.");
            SetError($"Failed to save Streamlabs token: {ex.Message}");
            return false;
        }
    }
    private async Task<bool> ConnectTwitchAsync()
    {
        _logger.LogInformation("Initiating Twitch OAuth flow.");
        TwitchAuthService twitchAuth = (TwitchAuthService)_serviceProvider.GetService(typeof(TwitchAuthService))!;
        try
        {
            bool success = await twitchAuth.InitiateLoginAsync();
            if (!success)
            {
                _logger.LogWarning("Twitch authentication flow did not complete successfully (cancelled or failed).");
                SetError("Twitch authentication failed or was cancelled. Please check logs or try again.");
            }
            else
            {
                _logger.LogInformation("Twitch authentication flow completed successfully.");
            }
            return success;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred during Twitch OAuth initiation.");
            SetError($"An error occurred during Twitch login: {ex.Message}");
            return false;
        }
    }
    private async Task<bool> ConnectYouTubeAsync()
    {
        _logger.LogInformation("Initiating YouTube OAuth flow.");
        YouTubeAuthService youtubeAuth = (YouTubeAuthService)_serviceProvider.GetService(typeof(YouTubeAuthService))!;
        try
        {
            YouTubeAuthResult authResult = await youtubeAuth.AuthenticateAsync();
            if (authResult.Success && !string.IsNullOrEmpty(authResult.ChannelId))
            {
                _logger.LogInformation(
                    "YouTube authentication successful for {ChannelName} ({ChannelId}). Updating settings.",
                    authResult.ChannelName ?? "Unknown Channel",
                    authResult.ChannelId
                );
                ISettingsService settingsService = (ISettingsService)_serviceProvider.GetService(typeof(ISettingsService))!;
                AppSettings settings = await settingsService.LoadSettingsAsync();
                if (!settings.Connections.YouTubeAccounts.Any(a => a.ChannelId == authResult.ChannelId))
                {
                    settings.Connections.YouTubeAccounts.Add(
                        new YouTubeAccount
                        {
                            ChannelId = authResult.ChannelId,
                            ChannelName = authResult.ChannelName ?? "YouTube User",
                            AutoConnect = true,
                        }
                    );
                    await settingsService.SaveSettingsAsync(settings);
                    _logger.LogInformation(
                        "Added new YouTube account to settings: {ChannelName} ({ChannelId})",
                        authResult.ChannelName ?? "YouTube User",
                        authResult.ChannelId
                    );
                }
                else
                {
                    _logger.LogInformation(
                        "YouTube account already exists in settings: {ChannelName} ({ChannelId})",
                        authResult.ChannelName ?? "Existing User",
                        authResult.ChannelId
                    );
                }
                return true;
            }
            else
            {
                _logger.LogWarning(
                    "YouTube authentication flow did not complete successfully. Error: {ErrorMessage}",
                    authResult.ErrorMessage ?? "No error message provided."
                );
                SetError($"YouTube authentication failed or was cancelled: {authResult.ErrorMessage ?? "Please try again."}");
                return false;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred during YouTube OAuth initiation or settings update.");
            SetError($"An error occurred during YouTube login: {ex.Message}");
            return false;
        }
    }
    public void HandleCancel() => _logger.LogInformation("Connect account dialog cancelled by user for {AccountType}.", _accountType);
    private void SetError(string message)
    {
        ErrorMessage = message;
        HasError = true;
        _logger.LogError("Connection error set for user: {ErrorMessage}", message);
    }
}
</file>

<file path="UI/ViewModels/CreatePollDialogViewModel.cs">
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics.CodeAnalysis;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
namespace StreamWeaver.UI.ViewModels;
public partial class PollOptionViewModel : ObservableValidator
{
    [ObservableProperty]
    [Required(ErrorMessage = "Option text cannot be empty.")]
    [MaxLength(30, ErrorMessage = "Option text cannot exceed 30 characters.")]
    [NotifyDataErrorInfo]
    public partial string? Text { get; set; }
    public void Validate() => ValidateAllProperties();
}
public partial class CreatePollDialogViewModel : ObservableValidator
{
    private const int MaxOptions = 5;
    private const int MinOptions = 2;
    [ObservableProperty]
    [Required(ErrorMessage = "Poll question cannot be empty.")]
    [MaxLength(100, ErrorMessage = "Question cannot exceed 100 characters.")]
    [NotifyDataErrorInfo]
    public partial string? Question { get; set; }
    [ObservableProperty]
    public partial ObservableCollection<PollOptionViewModel> Options { get; set; } = [];
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(HasError))]
    public partial string? ErrorMessage { get; set; }
    public bool HasError => !string.IsNullOrEmpty(ErrorMessage);
    public CreatePollDialogViewModel()
    {
        AddOption();
        AddOption();
    }
    [RelayCommand(CanExecute = nameof(CanAddOption))]
    private void AddOption()
    {
        if (Options.Count < MaxOptions)
        {
            Options.Add(new PollOptionViewModel());
            AddOptionCommand.NotifyCanExecuteChanged();
            RemoveOptionCommand.NotifyCanExecuteChanged();
        }
    }
    private bool CanAddOption() => Options.Count < MaxOptions;
    [RelayCommand(CanExecute = nameof(CanRemoveOption))]
    private void RemoveOption(PollOptionViewModel? optionToRemove)
    {
        if (optionToRemove != null && Options.Count > MinOptions)
        {
            Options.Remove(optionToRemove);
            AddOptionCommand.NotifyCanExecuteChanged();
            RemoveOptionCommand.NotifyCanExecuteChanged();
        }
    }
    private bool CanRemoveOption() => Options.Count > MinOptions;
    public bool TryGetValidatedData([NotNullWhen(true)] out string? validatedQuestion, [NotNullWhen(true)] out List<string>? validatedOptions)
    {
        validatedQuestion = null;
        validatedOptions = null;
        ErrorMessage = null;
        ValidateAllProperties();
        if (HasErrors)
        {
            ErrorMessage = string.Join("; ", GetErrors().Select(e => e.ErrorMessage));
            return false;
        }
        bool allOptionsValid = true;
        List<string> currentOptions = [];
        foreach (PollOptionViewModel optionVm in Options)
        {
            optionVm.Validate();
            if (optionVm.HasErrors)
            {
                allOptionsValid = false;
                break;
            }
            if (optionVm.Text != null)
            {
                currentOptions.Add(optionVm.Text);
            }
        }
        if (!allOptionsValid)
        {
            ErrorMessage = "One or more options are invalid (empty or too long).";
            return false;
        }
        if (Options.Count is < MinOptions or > MaxOptions)
        {
            ErrorMessage = $"Poll must have between {MinOptions} and {MaxOptions} options.";
            return false;
        }
        if (currentOptions.GroupBy(opt => opt, StringComparer.OrdinalIgnoreCase).Any(g => g.Count() > 1))
        {
            ErrorMessage = "Poll options must be unique.";
            return false;
        }
        validatedQuestion = Question!;
        validatedOptions = currentOptions;
        return true;
    }
    protected override void OnPropertyChanged(PropertyChangedEventArgs e)
    {
        base.OnPropertyChanged(e);
        ValidateProperty(e.PropertyName!);
    }
}
</file>

<file path="UI/ViewModels/MainWindowViewModel.cs">
using CommunityToolkit.Mvvm.ComponentModel;
using Microsoft.Extensions.Logging;
namespace StreamWeaver.UI.ViewModels;
public partial class MainWindowViewModel : ObservableObject
{
    private readonly ILogger<MainWindowViewModel> _logger;
    private readonly IServiceProvider _serviceProvider;
    public MainWindowViewModel(ILogger<MainWindowViewModel> logger, IServiceProvider serviceProvider)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
        _logger.LogInformation("Initialized.");
    }
}
</file>

<file path="UI/Views/LogsView.xaml.cs">
using System.Collections.Specialized;
using System.Diagnostics;
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Media;
using StreamWeaver.UI.ViewModels;
namespace StreamWeaver.UI.Views;
public sealed partial class LogsView : Page
{
    private readonly ILogger<LogsView> _logger;
    private bool _shouldScrollToBottom = true;
    private ScrollViewer? _logScrollViewer;
    public LogsViewModel ViewModel => (LogsViewModel)DataContext;
    public LogsView()
    {
        InitializeComponent();
        try
        {
            DataContext = App.GetService<LogsViewModel>();
            _logger = App.GetService<ILogger<LogsView>>();
            _logger.LogInformation("LogsView initialized and DataContext set.");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[LogsView] FATAL: Failed to resolve LogsViewModel or ILogger: {ex}");
            throw;
        }
    }
    private void Page_Loaded(object sender, RoutedEventArgs e)
    {
        _logger.LogDebug("LogsView Page_Loaded.");
        if (ViewModel?.FilteredLogEntries != null)
        {
            ViewModel.FilteredLogEntries.CollectionChanged -= FilteredLogEntries_CollectionChanged;
            ViewModel.FilteredLogEntries.CollectionChanged += FilteredLogEntries_CollectionChanged;
            _logger.LogDebug("Subscribed to FilteredLogEntries CollectionChanged.");
        }
        else
        {
            _logger.LogWarning("ViewModel or FilteredLogEntries is null on Page_Loaded. CollectionChanged subscription skipped.");
        }
        FindAndHookScrollViewer();
        ScrollToBottom();
    }
    private void FindAndHookScrollViewer()
    {
        if (_logScrollViewer == null)
        {
            _logScrollViewer = FindScrollViewer(LogsListView);
            if (_logScrollViewer != null)
            {
                _logScrollViewer.ViewChanged -= ScrollViewer_ViewChanged;
                _logScrollViewer.ViewChanged += ScrollViewer_ViewChanged;
                _logger.LogInformation("Found and hooked ScrollViewer within LogsListView.");
            }
            else
            {
                _logger.LogWarning(
                    "Could not find the internal ScrollViewer for LogsListView on initial load. Auto-scroll may be delayed or disabled."
                );
            }
        }
        else
        {
            _logScrollViewer.ViewChanged -= ScrollViewer_ViewChanged;
            _logScrollViewer.ViewChanged += ScrollViewer_ViewChanged;
            _logger.LogDebug("LogsView ScrollViewer already cached, ensured ViewChanged event is hooked.");
        }
    }
    private void FilteredLogEntries_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        if (e.Action == NotifyCollectionChangedAction.Add && _shouldScrollToBottom)
        {
            _logger.LogTrace("New items added to filtered logs and auto-scroll enabled. Enqueueing ScrollToBottom.");
            bool enqueued = DispatcherQueue.TryEnqueue(ScrollToBottom);
            if (!enqueued)
                _logger.LogWarning("Failed to enqueue ScrollToBottom operation for logs.");
        }
        else if (e.Action == NotifyCollectionChangedAction.Reset)
        {
            _logger.LogDebug("Filtered log collection reset. Re-enabling auto-scroll.");
            _shouldScrollToBottom = true;
        }
    }
    private void ScrollViewer_ViewChanged(object? sender, ScrollViewerViewChangedEventArgs e)
    {
        if (_logScrollViewer != null && !e.IsIntermediate)
        {
            const double bottomTolerance = 10.0;
            bool isNearBottom = _logScrollViewer.VerticalOffset >= _logScrollViewer.ScrollableHeight - bottomTolerance;
            if (isNearBottom)
            {
                if (!_shouldScrollToBottom)
                {
                    _logger.LogDebug("User scrolled near bottom of logs. Re-enabling auto-scroll.");
                    _shouldScrollToBottom = true;
                }
            }
            else
            {
                if (_shouldScrollToBottom)
                {
                    _logger.LogDebug(
                        "User scrolled up in logs ({VerticalOffset}/{ScrollableHeight}). Disabling auto-scroll.",
                        _logScrollViewer.VerticalOffset,
                        _logScrollViewer.ScrollableHeight
                    );
                    _shouldScrollToBottom = false;
                }
            }
        }
    }
    private void ScrollToBottom()
    {
        if (_logScrollViewer == null)
        {
            _logger.LogTrace("LogsView ScrollToBottom called, attempting to find ScrollViewer first.");
            FindAndHookScrollViewer();
            if (_logScrollViewer == null)
            {
                _logger.LogWarning("LogsView ScrollToBottom: ScrollViewer still not found. Cannot scroll.");
                return;
            }
        }
        if (LogsListView.Items.Count > 0)
        {
            try
            {
                object lastItem = LogsListView.Items[^1];
                _logger.LogTrace("Scrolling last log item into view.");
                LogsListView.ScrollIntoView(lastItem, ScrollIntoViewAlignment.Leading);
                _shouldScrollToBottom = true;
            }
            catch (ArgumentOutOfRangeException ex)
            {
                _logger.LogWarning(ex, "Failed to get last log item for scrolling (collection might have changed).");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error occurred during log ScrollIntoView operation.");
            }
        }
        else
        {
            _logger.LogTrace("ScrollToBottom called but LogsListView is empty.");
        }
    }
    private static ScrollViewer? FindScrollViewer(DependencyObject element)
    {
        if (element is ScrollViewer viewer)
            return viewer;
        for (int i = 0; i < VisualTreeHelper.GetChildrenCount(element); i++)
        {
            DependencyObject child = VisualTreeHelper.GetChild(element, i);
            ScrollViewer? result = FindScrollViewer(child);
            if (result != null)
                return result;
        }
        return null;
    }
    private void Page_Unloaded(object sender, RoutedEventArgs e)
    {
        _logger.LogDebug("Page unloaded. Unsubscribing from log view event listeners.");
        if (ViewModel?.FilteredLogEntries != null)
        {
            ViewModel.FilteredLogEntries.CollectionChanged -= FilteredLogEntries_CollectionChanged;
        }
        if (_logScrollViewer != null)
        {
            _logScrollViewer.ViewChanged -= ScrollViewer_ViewChanged;
            _logScrollViewer = null;
        }
    }
}
</file>

<file path="UI/Views/SettingsPages/AccountsSettingsPage.xaml">
<Page
    x:Class="StreamWeaver.UI.Views.SettingsPages.AccountsSettingsPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:viewmodels="using:StreamWeaver.UI.ViewModels"
    xmlns:models="using:StreamWeaver.Core.Models.Settings"
    xmlns:converters="using:StreamWeaver.UI.Converters"
    mc:Ignorable="d"
    d:DataContext="{d:DesignInstance Type=viewmodels:SettingsViewModel, IsDesignTimeCreatable=False}"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Page.Resources>
        <converters:IntToVisibilityConverter x:Key="IntToVisibilityConverter"/>
        <converters:BoolToVisibilityConverter x:Key="BoolToVisibilityConverter"/>
        <converters:ConnectionStatusToBrushConverter x:Key="StatusToBrushConverter"/>
        <converters:ConnectionStatusToSymbolConverter x:Key="StatusToSymbolConverter"/>
        <converters:StringToVisibilityConverter x:Key="StringToVisibilityConverter"/>
        <converters:BoolToOpacityConverter x:Key="BoolToOpacityConverter"/>
        <converters:BoolInverterConverter x:Key="BoolInverterConverter"/>

        <!-- Style for Icon Button -->
        <Style x:Key="SubtleIconButton"
               TargetType="Button"
               BasedOn="{StaticResource DefaultButtonStyle}">
            <Setter Property="Background"
                    Value="Transparent"/>
            <Setter Property="BorderThickness"
                    Value="0"/>
            <Setter Property="Padding"
                    Value="4"/>
            <Setter Property="MinWidth"
                    Value="0"/>
            <Setter Property="MinHeight"
                    Value="0"/>
            <Setter Property="VerticalAlignment"
                    Value="Center"/>
        </Style>

        <!-- Style for Text Remove Button -->
        <Style x:Key="RemoveButtonTextBlockStyle"
               TargetType="TextBlock">
            <Setter Property="Foreground"
                    Value="{ThemeResource SystemControlErrorTextForegroundBrush}"/>
            <Setter Property="TextDecorations"
                    Value="Underline"/>
            <Setter Property="FontSize"
                    Value="12"/>
            <Setter Property="HorizontalAlignment"
                    Value="Right"/>
        </Style>
    </Page.Resources>

    <ScrollViewer VerticalScrollBarVisibility="Auto"
                  Padding="20">
        <StackPanel Spacing="15">
            <!-- Header Grid (Connect All/Disconnect All) -->
            <Grid ColumnSpacing="10"
                  Margin="0,0,0,10">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>
                <TextBlock Grid.Column="0"
                           Text="Connected Accounts"
                           Style="{ThemeResource SubtitleTextBlockStyle}"
                           VerticalAlignment="Center"/>
                <Button Grid.Column="1"
                        Command="{Binding ConnectAllCommand}"
                        VerticalAlignment="Center">
                    <!-- Tooltip & Content -->
                    <ToolTipService.ToolTip>
                        <ToolTip Content="Attempt to connect all accounts marked for auto-connect."/>
                    </ToolTipService.ToolTip>
                    <StackPanel Orientation="Horizontal"
                                Spacing="5">
                        <SymbolIcon Symbol="Play"/>
                        <TextBlock Text="Connect All"
                                   VerticalAlignment="Center"/>
                    </StackPanel>
                </Button>
                <Button Grid.Column="2"
                        Command="{Binding DisconnectAllCommand}"
                        VerticalAlignment="Center">
                    <!-- Tooltip & Content -->
                    <ToolTipService.ToolTip>
                        <ToolTip Content="Disconnect all currently active connections."/>
                    </ToolTipService.ToolTip>
                    <StackPanel Orientation="Horizontal"
                                Spacing="5">
                        <SymbolIcon Symbol="Stop"/>
                        <TextBlock Text="Disconnect All"
                                   VerticalAlignment="Center"/>
                    </StackPanel>
                </Button>
            </Grid>
            <TextBlock Text="Manage your connections to Twitch and YouTube. Add accounts using the '+' buttons. Credentials must be configured first."
                       TextWrapping="Wrap"
                       FontSize="12"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                       Margin="0,-5,0,10"/>

            <Grid Margin="0,0,0,5">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>
                <TextBlock Grid.Column="0"
                           Text="Twitch"
                           Style="{ThemeResource BodyStrongTextBlockStyle}"
                           VerticalAlignment="Center"/>
                <Button Grid.Column="1"
                        Style="{StaticResource SubtleIconButton}"
                        Command="{Binding ConnectTwitchAccountCommand}"
                        IsEnabled="{Binding IsTwitchConfigured}"
                        HorizontalAlignment="Right">
                    <ToolTipService.ToolTip>
                        <ToolTip Content="Add Twitch Account"/>
                    </ToolTipService.ToolTip>
                    <FontIcon Glyph=""
                              FontSize="16"/>
                </Button>
            </Grid>
            <InfoBar Severity="Warning"
                     Title="Twitch Credentials Required"
                     IsOpen="{Binding IsTwitchConfigured, Converter={StaticResource BoolInverterConverter}, ConverterParameter=Invert}"
                     Margin="0,0,0,5"
                     Message="Please enter credentials in the 'Credentials' tab to add Twitch accounts."/>

            <ItemsControl x:Name="TwitchAccountsItemsControl"
                          ItemsSource="{Binding TwitchAccounts}"
                          Margin="0,0,0,10">
                <ItemsControl.ItemTemplate>
                    <DataTemplate x:DataType="models:TwitchAccount">
                        <Expander HorizontalAlignment="Stretch"
                                  Margin="0,0,0,5">
                            <Expander.Header>
                                <Grid ColumnSpacing="10"
                                      Width="Auto">
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="Auto"/>
                                        <!-- Status Icon -->
                                        <ColumnDefinition Width="Auto"/>
                                        <!-- Platform Icon -->
                                        <ColumnDefinition Width="*"/>
                                        <!-- Name/ID -->
                                        <ColumnDefinition Width="Auto"/>
                                        <!-- Toggle Switch -->
                                    </Grid.ColumnDefinitions>
                                    <FontIcon Grid.Column="0"
                                              VerticalAlignment="Center"
                                              Margin="0,0,5,0"
                                              FontFamily="{StaticResource SymbolThemeFontFamily}"
                                              Glyph="{Binding Status, Converter={StaticResource StatusToSymbolConverter}}"
                                              Foreground="{Binding Status, Converter={StaticResource StatusToBrushConverter}}">
                                        <ToolTipService.ToolTip>
                                            <ToolTip Content="{Binding StatusMessage}"/>
                                        </ToolTipService.ToolTip>
                                    </FontIcon>
                                    <FontIcon Grid.Column="1"
                                              FontFamily="{StaticResource SymbolThemeFontFamily}"
                                              Glyph=""
                                              VerticalAlignment="Center"/>
                                    <!-- Twitch Icon -->
                                    <StackPanel Grid.Column="2"
                                                VerticalAlignment="Center">
                                        <TextBlock Text="{Binding Username}"
                                                   FontWeight="SemiBold"/>
                                        <TextBlock Text="{Binding StatusMessage}"
                                                   FontSize="11"
                                                   Foreground="{ThemeResource TextFillColorTertiaryBrush}"
                                                   Margin="0,1,0,0"
                                                   Visibility="{Binding StatusMessage, Converter={StaticResource StringToVisibilityConverter}}"/>
                                    </StackPanel>
                                    <ToggleSwitch Grid.Column="3"
                                                  VerticalAlignment="Center"
                                                  Margin="10,0,0,0"
                                                  IsOn="{Binding AutoConnect, Mode=OneWay}"
                                                  Toggled="AccountToggle_Toggled">
                                        <!-- Use shared handler -->
                                        <ToolTipService.ToolTip>
                                            <ToolTip Content="Toggle connection status and startup preference"/>
                                        </ToolTipService.ToolTip>
                                    </ToggleSwitch>
                                </Grid>
                            </Expander.Header>
                            <!-- Expander Content -->
                            <StackPanel Margin="48,10,0,10"
                                        Spacing="5">
                                <TextBlock FontSize="11"
                                           Foreground="{ThemeResource TextFillColorSecondaryBrush}">
                                     <Run Text="User ID:"/> <Run Text="{Binding UserId}"/>
                                </TextBlock>
                                <!-- Remove Button Command Binding -->
                                <Button HorizontalAlignment="Right"
                                        Margin="0,10,0,0"
                                        Background="Transparent"
                                        BorderThickness="0"
                                        Command="{Binding DataContext.RemoveTwitchAccountCommand, ElementName=TwitchAccountsItemsControl}"
                                        CommandParameter="{Binding}">
                                    <ToolTipService.ToolTip>
                                        <ToolTip Content="Log out, remove tokens, and delete this account from settings."/>
                                    </ToolTipService.ToolTip>
                                    <TextBlock Text="Remove Account"
                                               Style="{StaticResource RemoveButtonTextBlockStyle}"/>
                                </Button>
                            </StackPanel>
                        </Expander>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>
            <TextBlock Text="No Twitch accounts connected."
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                       FontStyle="Italic"
                       Margin="10,5"
                       Visibility="{Binding TwitchAccounts.Count, Converter={StaticResource IntToVisibilityConverter}, ConverterParameter=Invert}"/>

            <Grid Margin="0,15,0,5">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>
                <TextBlock Grid.Column="0"
                           Text="YouTube"
                           Style="{ThemeResource BodyStrongTextBlockStyle}"
                           VerticalAlignment="Center"/>
                <Button Grid.Column="1"
                        Style="{StaticResource SubtleIconButton}"
                        Command="{Binding ConnectYouTubeAccountCommand}"
                        IsEnabled="{Binding IsYouTubeConfigured}"
                        HorizontalAlignment="Right">
                    <ToolTipService.ToolTip>
                        <ToolTip Content="Add YouTube Account"/>
                    </ToolTipService.ToolTip>
                    <FontIcon Glyph=""
                              FontSize="16"/>
                </Button>
            </Grid>
            <InfoBar Severity="Warning"
                     Title="YouTube Credentials Required"
                     IsOpen="{Binding IsYouTubeConfigured, Converter={StaticResource BoolInverterConverter}, ConverterParameter=Invert}"
                     Margin="0,0,0,5"
                     Message="Please enter credentials in the 'Credentials' tab to add YouTube accounts."/>

            <!-- ItemsControl for YouTube Expanders -->
            <ItemsControl x:Name="YouTubeAccountsItemsControl"
                          ItemsSource="{Binding YouTubeAccounts}"
                          Margin="0,0,0,10">
                <ItemsControl.ItemTemplate>
                    <DataTemplate x:DataType="models:YouTubeAccount">
                        <Expander HorizontalAlignment="Stretch"
                                  Margin="0,0,0,5">
                            <Expander.Header>
                                <Grid ColumnSpacing="10">
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="Auto"/>
                                        <!-- Status Icon -->
                                        <ColumnDefinition Width="Auto"/>
                                        <!-- Platform Icon -->
                                        <ColumnDefinition Width="*"/>
                                        <!-- Name/ID -->
                                        <ColumnDefinition Width="Auto"/>
                                        <!-- Toggle Switch -->
                                    </Grid.ColumnDefinitions>
                                    <FontIcon Grid.Column="0"
                                              VerticalAlignment="Center"
                                              Margin="0,0,5,0"
                                              FontFamily="{StaticResource SymbolThemeFontFamily}"
                                              Glyph="{Binding Status, Converter={StaticResource StatusToSymbolConverter}}"
                                              Foreground="{Binding Status, Converter={StaticResource StatusToBrushConverter}}">
                                        <ToolTipService.ToolTip>
                                            <ToolTip Content="{Binding StatusMessage}"/>
                                        </ToolTipService.ToolTip>
                                    </FontIcon>
                                    <FontIcon Grid.Column="1"
                                              FontFamily="{StaticResource SymbolThemeFontFamily}"
                                              Glyph=""
                                              VerticalAlignment="Center"/>
                                    <!-- YouTube Icon -->
                                    <StackPanel Grid.Column="2"
                                                VerticalAlignment="Center">
                                        <TextBlock Text="{Binding ChannelName}"
                                                   FontWeight="SemiBold"/>
                                        <TextBlock Text="{Binding StatusMessage}"
                                                   FontSize="11"
                                                   Foreground="{ThemeResource TextFillColorTertiaryBrush}"
                                                   Margin="0,1,0,0"
                                                   Visibility="{Binding StatusMessage, Converter={StaticResource StringToVisibilityConverter}}"/>
                                    </StackPanel>
                                    <ToggleSwitch Grid.Column="3"
                                                  VerticalAlignment="Center"
                                                  Margin="10,0,0,0"
                                                  IsOn="{Binding AutoConnect, Mode=OneWay}"
                                                  Toggled="AccountToggle_Toggled">
                                        <!-- Use shared handler -->
                                        <ToolTipService.ToolTip>
                                            <ToolTip Content="Toggle connection status and startup preference"/>
                                        </ToolTipService.ToolTip>
                                    </ToggleSwitch>
                                </Grid>
                            </Expander.Header>
                            <!-- Expander Content -->
                            <StackPanel Margin="48,10,0,10"
                                        Spacing="5">
                                <TextBlock FontSize="11"
                                           Foreground="{ThemeResource TextFillColorSecondaryBrush}">
                                      <Run Text="Channel ID:"/> <Run Text="{Binding ChannelId}"/>
                                </TextBlock>
                                <TextBox Header="Override Live ID (Optional)"
                                         Margin="0,10,0,0"
                                         Text="{Binding OverrideVideoId, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                                         PlaceholderText="Video ID, e.g., WZafWA1NVrU"
                                         IsEnabled="{Binding AutoConnect}">
                                    <!-- Only allow edit if toggle is ON? Or always? -->
                                    <ToolTipService.ToolTip>
                                        <ToolTip Content="Force monitoring of this specific YouTube Video ID instead of looking for your active stream. Useful for testing or read-only mode."/>
                                    </ToolTipService.ToolTip>
                                </TextBox>
                                <!-- Remove Button Command Binding -->
                                <Button HorizontalAlignment="Right"
                                        Margin="0,10,0,0"
                                        Background="Transparent"
                                        BorderThickness="0"
                                        Command="{Binding DataContext.RemoveYouTubeAccountCommand, ElementName=YouTubeAccountsItemsControl}"
                                        CommandParameter="{Binding}">
                                    <ToolTipService.ToolTip>
                                        <ToolTip Content="Log out, remove tokens, and delete this account from settings."/>
                                    </ToolTipService.ToolTip>
                                    <TextBlock Text="Remove Account"
                                               Style="{StaticResource RemoveButtonTextBlockStyle}"/>
                                </Button>
                            </StackPanel>
                        </Expander>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>
            <TextBlock Text="No YouTube accounts connected."
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                       FontStyle="Italic"
                       Margin="10,5"
                       Visibility="{Binding YouTubeAccounts.Count, Converter={StaticResource IntToVisibilityConverter}, ConverterParameter=Invert}"/>

            <Grid Margin="0,15,0,5">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>
                <TextBlock Grid.Column="0"
                           Text="Streamlabs"
                           Style="{ThemeResource BodyStrongTextBlockStyle}"
                           VerticalAlignment="Center"/>
                <Button Grid.Column="1"
                        Style="{StaticResource SubtleIconButton}"
                        Command="{Binding SetupStreamlabsTokenCommand}"
                        HorizontalAlignment="Right">
                    <ToolTipService.ToolTip>
                        <ToolTip Content="Setup Streamlabs Connection"/>
                    </ToolTipService.ToolTip>
                    <FontIcon Glyph=""
                              FontSize="16"/>
                </Button>
            </Grid>
            <TextBlock Text="Connect Streamlabs to receive donation alerts and other events directly."
                       TextWrapping="Wrap"
                       FontSize="12"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                       Margin="0,-5,0,10"/>

            <!-- Expander shown when Streamlabs is configured -->
            <Expander HorizontalAlignment="Stretch"
                      Margin="0,0,0,5"
                      Visibility="{Binding IsStreamlabsTokenSetup, Converter={StaticResource BoolToVisibilityConverter}}">
                <Expander.Header>
                    <Grid ColumnSpacing="10">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto"/>
                            <!-- Status Icon -->
                            <ColumnDefinition Width="Auto"/>
                            <!-- Platform Icon -->
                            <ColumnDefinition Width="*"/>
                            <!-- Name/ID -->
                            <ColumnDefinition Width="Auto"/>
                            <!-- Toggle Switch -->
                        </Grid.ColumnDefinitions>
                        <FontIcon Grid.Column="0"
                                  VerticalAlignment="Center"
                                  Margin="0,0,5,0"
                                  FontFamily="{StaticResource SymbolThemeFontFamily}"
                                  Glyph="{Binding StreamlabsStatus, Converter={StaticResource StatusToSymbolConverter}}"
                                  Foreground="{Binding StreamlabsStatus, Converter={StaticResource StatusToBrushConverter}}">
                            <ToolTipService.ToolTip>
                                <ToolTip Content="{Binding StreamlabsStatusMessage}"/>
                            </ToolTipService.ToolTip>
                        </FontIcon>
                        <FontIcon Grid.Column="1"
                                  FontFamily="{StaticResource SymbolThemeFontFamily}"
                                  Glyph=""
                                  VerticalAlignment="Center"/>
                        <!-- Money Bag Icon -->
                        <StackPanel Grid.Column="2"
                                    VerticalAlignment="Center">
                            <TextBlock Text="Streamlabs Event Connection"
                                       FontWeight="SemiBold"/>
                            <TextBlock Text="{Binding StreamlabsStatusMessage}"
                                       FontSize="11"
                                       Foreground="{ThemeResource TextFillColorTertiaryBrush}"
                                       Margin="0,1,0,0"
                                       Visibility="{Binding StreamlabsStatusMessage, Converter={StaticResource StringToVisibilityConverter}}"/>
                        </StackPanel>
                        <ToggleSwitch Grid.Column="3"
                                      VerticalAlignment="Center"
                                      Margin="10,0,0,0"
                                      IsOn="{Binding Connections.EnableStreamlabs, Mode=TwoWay}"
                                      Toggled="StreamlabsEnableToggle_Toggled">
                            <ToolTipService.ToolTip>
                                <ToolTip Content="Enable/Disable receiving events from Streamlabs"/>
                            </ToolTipService.ToolTip>
                        </ToggleSwitch>
                    </Grid>
                </Expander.Header>
                <!-- Streamlabs Expander Content -->
                <StackPanel Margin="48,10,0,10"
                            Spacing="5">
                    <TextBlock FontSize="11"
                               Foreground="{ThemeResource TextFillColorSecondaryBrush}">
                          Click '+' above to change the Socket API token.
                    </TextBlock>
                    <Button HorizontalAlignment="Right"
                            Margin="0,10,0,0"
                            Background="Transparent"
                            BorderThickness="0"
                            Command="{Binding DisableStreamlabsCommand}"
                            IsEnabled="{Binding CanDisableStreamlabs}">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="Disable and remove Streamlabs connection"/>
                        </ToolTipService.ToolTip>
                        <TextBlock Text="Remove Connection"
                                   Style="{StaticResource RemoveButtonTextBlockStyle}"/>
                    </Button>
                </StackPanel>
            </Expander>

            <!-- Text shown when Streamlabs is NOT configured -->
            <TextBlock Text="No Streamlabs connection configured. Click '+' above to set it up."
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                       FontStyle="Italic"
                       Margin="10,5"
                       Visibility="{Binding IsStreamlabsTokenSetup, Converter={StaticResource BoolToVisibilityConverter}, ConverterParameter=Invert}"/>

        </StackPanel>
    </ScrollViewer>
</Page>
</file>

<file path="UI/Views/SettingsPages/CredentialsSettingsPage.xaml">
<?xml version="1.0" encoding="utf-8"?>
<Page
    x:Class="StreamWeaver.UI.Views.SettingsPages.CredentialsSettingsPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:StreamWeaver.UI.Views.SettingsPages"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:viewmodels="using:StreamWeaver.UI.ViewModels"
    xmlns:converters="using:StreamWeaver.UI.Converters"
    mc:Ignorable="d"
    d:DataContext="{d:DesignInstance Type=viewmodels:SettingsViewModel, IsDesignTimeCreatable=False}"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Page.Resources>
        <converters:BoolToVisibilityConverter x:Key="BoolToVisibilityConverter"/>
    </Page.Resources>

    <ScrollViewer VerticalScrollBarVisibility="Auto"
                  Padding="20">
        <StackPanel Spacing="15">
            <TextBlock Text="API Credentials"
                       Style="{ThemeResource SubtitleTextBlockStyle}"/>
            <TextBlock TextWrapping="Wrap"
                       Style="{ThemeResource BodyTextBlockStyle}"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}">
                StreamWeaver requires you to create your own Twitch and YouTube Application credentials. This ensures your API usage quotas are separate and keeps your connection secure. Please generate credentials and paste them below. Remember to keep your Client Secrets confidential. Click the links below to go to the respective developer consoles.
            </TextBlock>

            <!-- Twitch Credentials -->
            <TextBlock Text="Twitch Application"
                       Style="{ThemeResource BodyStrongTextBlockStyle}"/>
            <TextBox Header="Twitch Client ID"
                     Text="{Binding Credentials.TwitchApiClientId, Mode=TwoWay}"
                     Margin="0,5,0,0">
                <ToolTipService.ToolTip>
                    <ToolTip Content="Your unique Client ID obtained from the Twitch Developer Console."/>
                </ToolTipService.ToolTip>
            </TextBox>
            <PasswordBox Header="Twitch Client Secret"
                         Password="{Binding Credentials.TwitchApiClientSecret, Mode=TwoWay}"
                         Margin="0,5,0,0">
                <ToolTipService.ToolTip>
                    <ToolTip Content="Your confidential Client Secret obtained from the Twitch Developer Console. Keep this safe!"/>
                </ToolTipService.ToolTip>
            </PasswordBox>
            <HyperlinkButton Content="Go to Twitch Developer Console..."
                             Margin="0,5,0,0"
                             Command="{Binding OpenUrlCommand}"
                             CommandParameter="https://dev.twitch.tv/console/apps"/>
            <TextBlock Text="Ensure your Twitch app is configured for 'Chat Bot' or similar and add 'http://localhost:5081/callback/twitch' as an Authorized Redirect URI in the Twitch Console."
                       FontSize="12"
                       Opacity="0.8"
                       TextWrapping="Wrap"
                       Margin="0,2,0,10"
                       Foreground="{ThemeResource TextFillColorTertiaryBrush}"/>

            <!-- YouTube Credentials -->
            <TextBlock Text="YouTube Application"
                       Style="{ThemeResource BodyStrongTextBlockStyle}"
                       Margin="0,10,0,0"/>
            <TextBox Header="YouTube Client ID"
                     Text="{Binding Credentials.YouTubeApiClientId, Mode=TwoWay}"
                     Margin="0,5,0,0">
                <ToolTipService.ToolTip>
                    <ToolTip Content="Your unique Client ID obtained from the Google Cloud Console."/>
                </ToolTipService.ToolTip>
            </TextBox>
            <PasswordBox Header="YouTube Client Secret"
                         Password="{Binding Credentials.YouTubeApiClientSecret, Mode=TwoWay}"
                         Margin="0,5,0,0">
                <ToolTipService.ToolTip>
                    <ToolTip Content="Your confidential Client Secret obtained from the Google Cloud Console. Keep this safe!"/>
                </ToolTipService.ToolTip>
            </PasswordBox>
            <HyperlinkButton Content="Go to Google Cloud Console..."
                             Margin="0,5,0,0"
                             Command="{Binding OpenUrlCommand}"
                             CommandParameter="https://console.cloud.google.com/apis/credentials"/>
            <TextBlock Text="Ensure your YouTube app OAuth Consent Screen is configured and your Credentials are set up for 'Desktop app'. Add 'http://localhost:5081/callback/google' as an Authorized Redirect URI in the Google Console."
                       FontSize="12"
                       Opacity="0.8"
                       TextWrapping="Wrap"
                       Margin="0,2,0,10"
                       Foreground="{ThemeResource TextFillColorTertiaryBrush}"/>
        </StackPanel>
    </ScrollViewer>
</Page>
</file>

<file path="UI/Views/SettingsPages/CredentialsSettingsPage.xaml.cs">
using Microsoft.UI.Xaml.Controls;
namespace StreamWeaver.UI.Views.SettingsPages;
public sealed partial class CredentialsSettingsPage : Page
{
    public CredentialsSettingsPage() => this.InitializeComponent();
}
</file>

<file path="UI/Views/SettingsPages/ModulesSettingsPage.xaml">
<?xml version="1.0" encoding="utf-8"?>
<Page
    x:Class="StreamWeaver.UI.Views.SettingsPages.ModulesSettingsPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:StreamWeaver.UI.Views.SettingsPages"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:viewmodels="using:StreamWeaver.UI.ViewModels"
    xmlns:converters="using:StreamWeaver.UI.Converters"
    mc:Ignorable="d"
    d:DataContext="{d:DesignInstance Type=viewmodels:SettingsViewModel, IsDesignTimeCreatable=False}"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Page.Resources>
        <converters:BoolToOpacityConverter x:Key="BoolToOpacityConverter"/>
        <StaticResource x:Key="DecimalFormatter"
                        ResourceKey="DecimalFormatter"/>
        <StaticResource x:Key="IntegerFormatter"
                        ResourceKey="IntegerFormatter"/>
    </Page.Resources>

    <ScrollViewer VerticalScrollBarVisibility="Auto"
                  Padding="20">
        <StackPanel Spacing="15">
            <TextBlock Text="Modules"
                       Style="{ThemeResource SubtitleTextBlockStyle}"/>
            <TextBlock Text="Configure optional built-in modules like the Subathon Timer and Goal Tracker."
                       TextWrapping="Wrap"
                       Margin="0,0,0,10"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>

            <!-- Subathon Timer Expander -->
            <Expander Header="Subathon Timer"
                      IsExpanded="False">
                <StackPanel Spacing="10"
                            Margin="24,10,0,0">
                    <ToggleSwitch Header="Enable Subathon Timer Module"
                                  IsOn="{Binding ModuleSettings.Subathon.Enabled, Mode=TwoWay}">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="Enable or disable the subathon timer functionality and overlay."/>
                        </ToolTipService.ToolTip>
                    </ToggleSwitch>
                    <!-- Sub-panel gets slightly transparent when main toggle is off -->
                    <StackPanel Spacing="10"
                                Opacity="{Binding ModuleSettings.Subathon.Enabled, Converter={StaticResource BoolToOpacityConverter}}">
                        <TextBlock Text="Timer Setup"
                                   Style="{ThemeResource BodyStrongTextBlockStyle}"/>
                        <TextBlock Text="Configure the starting duration and maximum length of the timer."
                                   FontSize="12"
                                   Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                                   Margin="0,-5,0,5"/>
                        <NumberBox Header="Initial Duration (Minutes)"
                                   Minimum="0"
                                   SpinButtonPlacementMode="Inline"
                                   SmallChange="1"
                                   LargeChange="10"
                                   Value="{Binding ModuleSettings.Subathon.InitialDurationMinutes, Mode=TwoWay}"
                                   NumberFormatter="{StaticResource IntegerFormatter}"
                                   IsEnabled="{Binding ModuleSettings.Subathon.Enabled}">
                            <ToolTipService.ToolTip>
                                <ToolTip Content="The timer's starting duration when the module is first enabled or reset."/>
                            </ToolTipService.ToolTip>
                        </NumberBox>
                        <NumberBox Header="Maximum Duration Cap (Minutes, 0 for No Cap)"
                                   Minimum="0"
                                   SpinButtonPlacementMode="Inline"
                                   SmallChange="10"
                                   LargeChange="60"
                                   Value="{Binding ModuleSettings.Subathon.MaximumDurationMinutes, Mode=TwoWay}"
                                   NumberFormatter="{StaticResource IntegerFormatter}"
                                   IsEnabled="{Binding ModuleSettings.Subathon.Enabled}">
                            <ToolTipService.ToolTip>
                                <ToolTip Content="The maximum time the timer can reach. Set to 0 for no limit."/>
                            </ToolTipService.ToolTip>
                        </NumberBox>
                        <TextBlock Text="Time Added Per Event"
                                   Style="{ThemeResource BodyStrongTextBlockStyle}"
                                   Margin="0,15,0,0"/>
                        <TextBlock Text="Configure how much time is added for different events."
                                   FontSize="12"
                                   Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                                   Margin="0,-5,0,5"/>
                        <ToggleSwitch Header="Add Time for Subscriptions/Resubs/Gifts"
                                      Margin="0,5,0,0"
                                      IsOn="{Binding ModuleSettings.Subathon.AddTimeForSubs, Mode=TwoWay}"
                                      IsEnabled="{Binding ModuleSettings.Subathon.Enabled}">
                            <ToolTipService.ToolTip>
                                <ToolTip Content="Enable adding time for Twitch subscriptions and gifts."/>
                            </ToolTipService.ToolTip>
                        </ToggleSwitch>
                        <StackPanel Margin="20,5,0,10"
                                    Spacing="5"
                                    Opacity="{Binding ModuleSettings.Subathon.IsSubConfigEnabled, Converter={StaticResource BoolToOpacityConverter}}">
                            <NumberBox Header="Seconds per Tier 1 / Prime Sub"
                                       Minimum="0"
                                       Value="{Binding ModuleSettings.Subathon.SecondsPerSubTier1, Mode=TwoWay}"
                                       SpinButtonPlacementMode="Inline"
                                       SmallChange="1"
                                       NumberFormatter="{StaticResource IntegerFormatter}"
                                       IsEnabled="{Binding ModuleSettings.Subathon.IsSubConfigEnabled}"/>
                            <NumberBox Header="Seconds per Tier 2 Sub"
                                       Minimum="0"
                                       Value="{Binding ModuleSettings.Subathon.SecondsPerSubTier2, Mode=TwoWay}"
                                       SpinButtonPlacementMode="Inline"
                                       SmallChange="1"
                                       NumberFormatter="{StaticResource IntegerFormatter}"
                                       IsEnabled="{Binding ModuleSettings.Subathon.IsSubConfigEnabled}"/>
                            <NumberBox Header="Seconds per Tier 3 Sub"
                                       Minimum="0"
                                       Value="{Binding ModuleSettings.Subathon.SecondsPerSubTier3, Mode=TwoWay}"
                                       SpinButtonPlacementMode="Inline"
                                       SmallChange="1"
                                       NumberFormatter="{StaticResource IntegerFormatter}"
                                       IsEnabled="{Binding ModuleSettings.Subathon.IsSubConfigEnabled}"/>
                            <NumberBox Header="Seconds per Gifted Sub (Each)"
                                       Minimum="0"
                                       Value="{Binding ModuleSettings.Subathon.SecondsPerGiftSub, Mode=TwoWay}"
                                       SpinButtonPlacementMode="Inline"
                                       SmallChange="1"
                                       NumberFormatter="{StaticResource IntegerFormatter}"
                                       IsEnabled="{Binding ModuleSettings.Subathon.IsSubConfigEnabled}"/>
                        </StackPanel>
                        <ToggleSwitch Header="Add Time for Bits/Cheers"
                                      Margin="0,5,0,0"
                                      IsOn="{Binding ModuleSettings.Subathon.AddTimeForBits, Mode=TwoWay}"
                                      IsEnabled="{Binding ModuleSettings.Subathon.Enabled}">
                            <ToolTipService.ToolTip>
                                <ToolTip Content="Enable adding time for Twitch Bits/Cheers."/>
                            </ToolTipService.ToolTip>
                        </ToggleSwitch>
                        <StackPanel Margin="20,5,0,10"
                                    Spacing="5"
                                    Opacity="{Binding ModuleSettings.Subathon.IsBitsConfigEnabled, Converter={StaticResource BoolToOpacityConverter}}">
                            <NumberBox Header="Bits Required to Add 1 Second"
                                       Minimum="1"
                                       Value="{Binding ModuleSettings.Subathon.BitsPerSecond, Mode=TwoWay}"
                                       SpinButtonPlacementMode="Inline"
                                       SmallChange="1"
                                       NumberFormatter="{StaticResource IntegerFormatter}"
                                       IsEnabled="{Binding ModuleSettings.Subathon.IsBitsConfigEnabled}"/>
                        </StackPanel>
                        <ToggleSwitch Header="Add Time for Donations / Super Chats"
                                      Margin="0,5,0,0"
                                      IsOn="{Binding ModuleSettings.Subathon.AddTimeForDonations, Mode=TwoWay}"
                                      IsEnabled="{Binding ModuleSettings.Subathon.Enabled}">
                            <ToolTipService.ToolTip>
                                <ToolTip Content="Enable adding time for Streamlabs donations and YouTube Super Chats."/>
                            </ToolTipService.ToolTip>
                        </ToggleSwitch>
                        <StackPanel Margin="20,5,0,10"
                                    Spacing="5"
                                    Opacity="{Binding ModuleSettings.Subathon.IsDonationConfigEnabled, Converter={StaticResource BoolToOpacityConverter}}">
                            <NumberBox Header="Amount Required to Add 1 Second"
                                       Minimum="0.01"
                                       Value="{Binding ModuleSettings.Subathon.AmountPerSecond, Mode=TwoWay}"
                                       SpinButtonPlacementMode="Inline"
                                       SmallChange="0.01"
                                       LargeChange="0.1"
                                       NumberFormatter="{StaticResource DecimalFormatter}"
                                       IsEnabled="{Binding ModuleSettings.Subathon.IsDonationConfigEnabled}"/>
                            <TextBox Header="Assumed Currency for Calculation (e.g., USD)"
                                     Text="{Binding ModuleSettings.Subathon.DonationCurrencyAssumption, Mode=TwoWay}"
                                     IsEnabled="{Binding ModuleSettings.Subathon.IsDonationConfigEnabled}">
                                <ToolTipService.ToolTip>
                                    <ToolTip Content="The currency code (e.g., USD, EUR, JPY) used when comparing donation amounts to the 'Amount Required' setting. Does not perform live conversion."/>
                                </ToolTipService.ToolTip>
                            </TextBox>
                        </StackPanel>
                    </StackPanel>
                </StackPanel>
            </Expander>
            <!-- Goal Module Expander -->
            <Expander Header="Goal Tracker"
                      IsExpanded="False">
                <TextBlock Text="Goal Tracker settings will go here..."
                           Margin="24,5,0,0"
                           Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                           FontStyle="Italic"/>
                <!-- TODO: Add Goal settings bindings based on GoalSettings model -->
            </Expander>
        </StackPanel>
    </ScrollViewer>
</Page>
</file>

<file path="UI/Views/SettingsPages/ModulesSettingsPage.xaml.cs">
using Microsoft.UI.Xaml.Controls;
namespace StreamWeaver.UI.Views.SettingsPages;
public sealed partial class ModulesSettingsPage : Page
{
    public ModulesSettingsPage() => this.InitializeComponent();
}
</file>

<file path="UI/Views/SettingsPages/OverlaysSettingsPage.xaml">
<?xml version="1.0" encoding="utf-8"?>
<Page
    x:Class="StreamWeaver.UI.Views.SettingsPages.OverlaysSettingsPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:StreamWeaver.UI.Views.SettingsPages"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:viewmodels="using:StreamWeaver.UI.ViewModels"
    xmlns:converters="using:StreamWeaver.UI.Converters"
    mc:Ignorable="d"
    d:DataContext="{d:DesignInstance Type=viewmodels:SettingsViewModel, IsDesignTimeCreatable=False}"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Page.Resources>
        <converters:BoolToVisibilityConverter x:Key="BoolToVisibilityConverter"/>
    </Page.Resources>

    <ScrollViewer VerticalScrollBarVisibility="Auto"
                  Padding="20">
        <StackPanel Spacing="15">
            <TextBlock Text="OBS Overlays"
                       Style="{ThemeResource SubtitleTextBlockStyle}"/>
            <TextBlock Text="Configure the local web server and appearance of the browser source overlays."
                       TextWrapping="Wrap"
                       Margin="0,0,0,10"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
            <NumberBox Header="Web Server Port"
                       Minimum="1025"
                       Maximum="65535"
                       SpinButtonPlacementMode="Inline"
                       SmallChange="1"
                       LargeChange="10"
                       Value="{Binding OverlaySettings.WebServerPort, Mode=TwoWay}">
                <ToolTipService.ToolTip>
                    <ToolTip Content="The local network port the overlay server will run on. Ensure this port is not used by other applications and is allowed through your firewall if accessed from other devices."/>
                </ToolTipService.ToolTip>
            </NumberBox>
            <TextBox Header="Chat Overlay URL (Read Only)"
                     IsReadOnly="True"
                     Text="{Binding ChatOverlayUrl}">
                <ToolTipService.ToolTip>
                    <ToolTip Content="Add this URL as a Browser Source in OBS."/>
                </ToolTipService.ToolTip>
            </TextBox>
            <Button Content="Copy Chat URL"
                    Command="{Binding CopyOverlayUrlCommand}"
                    CommandParameter="Chat"
                    HorizontalAlignment="Left">
                <ToolTipService.ToolTip>
                    <ToolTip Content="Copy the chat overlay URL to your clipboard."/>
                </ToolTipService.ToolTip>
            </Button>

            <Expander Header="Chat Overlay Customization"
                      Margin="0,10,0,0">
                <StackPanel Spacing="10"
                            Margin="24,5,0,0">
                    <TextBlock Text="Customize the look and feel of the chat overlay displayed in OBS."
                               FontSize="12"
                               Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                               Margin="0,0,0,5"/>
                    <NumberBox Header="Max Messages"
                               Minimum="1"
                               Maximum="100"
                               Value="{Binding OverlaySettings.Chat.MaxMessages, Mode=TwoWay}"
                               SmallChange="1">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="The maximum number of messages to display on the overlay at once."/>
                        </ToolTipService.ToolTip>
                    </NumberBox>
                    <TextBox Header="Font Family"
                             Text="{Binding OverlaySettings.Chat.Font, Mode=TwoWay}"
                             PlaceholderText="e.g., Arial, Segoe UI, Impact">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="The CSS font-family to use for chat messages (ensure the font is installed)."/>
                        </ToolTipService.ToolTip>
                    </TextBox>
                    <NumberBox Header="Font Size (px)"
                               Minimum="8"
                               Maximum="72"
                               Value="{Binding OverlaySettings.Chat.FontSize, Mode=TwoWay}"
                               SmallChange="1">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="The font size in pixels."/>
                        </ToolTipService.ToolTip>
                    </NumberBox>
                    <TextBox Header="Text Color (Hex or Name)"
                             Text="{Binding OverlaySettings.Chat.TextColor, Mode=TwoWay}"
                             PlaceholderText="e.g., #FFFFFF, white">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="Default text color for messages (CSS color value)."/>
                        </ToolTipService.ToolTip>
                    </TextBox>
                    <TextBox Header="Background Color (CSS value)"
                             Text="{Binding OverlaySettings.Chat.BackgroundColor, Mode=TwoWay}"
                             PlaceholderText="e.g., rgba(0,0,0,0.5), transparent">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="Background color for message containers. Use 'transparent' or RGBA values for transparency."/>
                        </ToolTipService.ToolTip>
                    </TextBox>
                    <ToggleSwitch Header="Show Badges"
                                  IsOn="{Binding OverlaySettings.Chat.ShowBadges, Mode=TwoWay}">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="Display user badges (e.g., subscriber, moderator) next to usernames."/>
                        </ToolTipService.ToolTip>
                    </ToggleSwitch>
                    <ToggleSwitch Header="Show Platform Icons"
                                  IsOn="{Binding OverlaySettings.Chat.ShowPlatformIcons, Mode=TwoWay}">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="Display a small icon indicating the message's origin platform (Twitch/YouTube)."/>
                        </ToolTipService.ToolTip>
                    </ToggleSwitch>
                    <ToggleSwitch Header="Use Platform Colors for Names"
                                  IsOn="{Binding OverlaySettings.Chat.UsePlatformColors, Mode=TwoWay}">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="Color usernames based on the color set on the platform (e.g., Twitch user color)."/>
                        </ToolTipService.ToolTip>
                    </ToggleSwitch>
                    <ToggleSwitch Header="Fade Out Old Messages"
                                  IsOn="{Binding OverlaySettings.Chat.FadeMessages, Mode=TwoWay}">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="Automatically fade out and remove messages after a set delay."/>
                        </ToolTipService.ToolTip>
                    </ToggleSwitch>
                    <NumberBox Header="Fade Delay (seconds)"
                               Minimum="5"
                               Maximum="300"
                               IsEnabled="{Binding OverlaySettings.Chat.FadeMessages}"
                               Value="{Binding OverlaySettings.Chat.FadeDelaySeconds, Mode=TwoWay}"
                               SmallChange="1">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="How long (in seconds) a message stays fully visible before starting to fade out."/>
                        </ToolTipService.ToolTip>
                    </NumberBox>
                    <TextBox Header="Timestamp Format (e.g., HH:mm)"
                             PlaceholderText="Leave empty to hide"
                             Text="{Binding OverlaySettings.Chat.TimestampFormat, Mode=TwoWay}">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="Format for displaying timestamps (e.g., HH:mm, HH:mm:ss). Leave empty to hide timestamps."/>
                        </ToolTipService.ToolTip>
                    </TextBox>
                    <TextBox Header="Highlight Color (CSS)"
                             Text="{Binding OverlaySettings.Chat.HighlightColor, Mode=TwoWay}"
                             PlaceholderText="e.g., #FFD700, gold">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="Background/border color accent for highlighted messages (e.g., Twitch Channel Points)."/>
                        </ToolTipService.ToolTip>
                    </TextBox>
                    <TextBox Header="Subscription Color (CSS)"
                             Text="{Binding OverlaySettings.Chat.SubColor, Mode=TwoWay}"
                             PlaceholderText="e.g., #8A2BE2, blueviolet">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="Background/border color accent for subscription/membership messages."/>
                        </ToolTipService.ToolTip>
                    </TextBox>
                    <TextBox Header="Donation Color (CSS)"
                             Text="{Binding OverlaySettings.Chat.DonationColor, Mode=TwoWay}"
                             PlaceholderText="e.g., #1E90FF, dodgerblue">
                        <ToolTipService.ToolTip>
                            <ToolTip Content="Background/border color accent for donation/cheer/SuperChat messages."/>
                        </ToolTipService.ToolTip>
                    </TextBox>
                </StackPanel>
            </Expander>
            <Expander Header="Subathon Timer Overlay"
                      Margin="0,10,0,0">
                <!-- TODO: Add URL display/copy for Subtimer -->
                <TextBlock Text="Sub Timer overlay settings will go here..."
                           Margin="24,5,0,0"
                           Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                           FontStyle="Italic"/>
            </Expander>
            <Expander Header="Goal Overlay"
                      Margin="0,10,0,0">
                <!-- TODO: Add URL display/copy for Goal -->
                <TextBlock Text="Goal overlay settings will go here..."
                           Margin="24,5,0,0"
                           Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                           FontStyle="Italic"/>
            </Expander>
        </StackPanel>
    </ScrollViewer>
</Page>
</file>

<file path="UI/Views/SettingsPages/OverlaysSettingsPage.xaml.cs">
using Microsoft.UI.Xaml.Controls;
namespace StreamWeaver.UI.Views.SettingsPages;
public sealed partial class OverlaysSettingsPage : Page
{
    public OverlaysSettingsPage() => this.InitializeComponent();
}
</file>

<file path="UI/Views/SettingsPages/PluginsSettingsPage.xaml">
<?xml version="1.0" encoding="utf-8"?>
<Page
    x:Class="StreamWeaver.UI.Views.SettingsPages.PluginsSettingsPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:StreamWeaver.UI.Views.SettingsPages"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:viewmodels="using:StreamWeaver.UI.ViewModels"
    xmlns:plugins="using:StreamWeaver.Core.Plugins"
    xmlns:converters="using:StreamWeaver.UI.Converters"
    mc:Ignorable="d"
    d:DataContext="{d:DesignInstance Type=viewmodels:SettingsViewModel, IsDesignTimeCreatable=False}"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Page.Resources>
        <converters:IntToVisibilityConverter x:Key="IntToVisibilityConverter"/>
    </Page.Resources>

    <ScrollViewer VerticalScrollBarVisibility="Auto"
                  Padding="20">
        <StackPanel Spacing="15">
            <TextBlock Text="Loaded Plugins"
                       Style="{ThemeResource SubtitleTextBlockStyle}"/>
            <TextBlock Text="Displays information about successfully loaded plugins."
                       TextWrapping="Wrap"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                       Margin="0,0,0,10"/>

            <ListView ItemsSource="{Binding LoadedPlugins}"
                      SelectionMode="None">
                <ListView.ItemContainerStyle>
                    <Style TargetType="ListViewItem">
                        <Setter Property="Padding"
                                Value="10,8"/>
                        <Setter Property="MinHeight"
                                Value="0"/>
                        <Setter Property="HorizontalContentAlignment"
                                Value="Stretch"/>
                    </Style>
                </ListView.ItemContainerStyle>
                <ListView.ItemTemplate>
                    <DataTemplate x:DataType="plugins:IPlugin">
                        <Grid ColumnSpacing="10">
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="Auto"/>
                                <ColumnDefinition Width="Auto"/>
                            </Grid.ColumnDefinitions>

                            <StackPanel Grid.Column="0"
                                        VerticalAlignment="Center">
                                <TextBlock Text="{Binding Name}"
                                           FontWeight="SemiBold"/>
                                <TextBlock Text="{Binding Author}"
                                           FontSize="11"
                                           Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                                           Margin="0,1,0,0"/>
                            </StackPanel>

                            <TextBlock Grid.Column="1"
                                       Text="{Binding Version}"
                                       VerticalAlignment="Center"
                                       Margin="10,0"/>
                        </Grid>
                    </DataTemplate>
                </ListView.ItemTemplate>
                <ListView.Footer>
                    <TextBlock Text="No plugins loaded or found."
                               Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                               FontStyle="Italic"
                               Margin="10,5"
                               Visibility="{Binding LoadedPlugins.Count, Converter={StaticResource IntToVisibilityConverter}, ConverterParameter=Invert}"/>
                </ListView.Footer>
            </ListView>

            <TextBlock FontSize="11"
                       FontStyle="Italic"
                       Foreground="{ThemeResource TextFillColorTertiaryBrush}">
                Plugins are loaded from subdirectories within the 'Plugins' folder next to StreamWeaver.exe at startup. Each plugin requires a manifest.json file. Restart StreamWeaver to load new or updated plugins.
            </TextBlock>

        </StackPanel>
    </ScrollViewer>
</Page>
</file>

<file path="UI/Views/SettingsPages/PluginsSettingsPage.xaml.cs">
using Microsoft.UI.Xaml.Controls;
using StreamWeaver.UI.ViewModels;
namespace StreamWeaver.UI.Views.SettingsPages;
public sealed partial class PluginsSettingsPage : Page
{
    public SettingsViewModel? ViewModel => DataContext as SettingsViewModel;
    public PluginsSettingsPage() => this.InitializeComponent();
}
</file>

<file path="UI/Views/SettingsView.xaml">
<?xml version="1.0" encoding="utf-8"?>
<Page
    x:Class="StreamWeaver.UI.Views.SettingsView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:StreamWeaver.UI.Views"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:viewmodels="using:StreamWeaver.UI.ViewModels"
    xmlns:pages="using:StreamWeaver.UI.Views.SettingsPages"
    xmlns:selectors="using:StreamWeaver.UI.Selectors"
    mc:Ignorable="d"
    d:DataContext="{d:DesignInstance Type=viewmodels:SettingsViewModel, IsDesignTimeCreatable=False}">

    <Page.Resources>
        <Style x:Key="SettingsListBoxItemStyle"
               TargetType="ListBoxItem">
            <Setter Property="Padding"
                    Value="12,8"/>
            <Setter Property="HorizontalContentAlignment"
                    Value="Stretch"/>
        </Style>

        <DataTemplate x:Key="CredentialsSectionTemplate">
            <pages:CredentialsSettingsPage/>
        </DataTemplate>

        <DataTemplate x:Key="AccountsSectionTemplate">
            <pages:AccountsSettingsPage/>
        </DataTemplate>

        <DataTemplate x:Key="OverlaysSectionTemplate">
            <pages:OverlaysSettingsPage/>
        </DataTemplate>

        <DataTemplate x:Key="TTSSectionTemplate">
            <pages:TtsSettingsPage/>
        </DataTemplate>

        <DataTemplate x:Key="ModulesSectionTemplate">
            <pages:ModulesSettingsPage/>
        </DataTemplate>

        <DataTemplate x:Key="PluginsSectionTemplate">
            <pages:PluginsSettingsPage/>
        </DataTemplate>

        <DataTemplate x:Key="SettingsNavigationViewItemTemplate"
                      x:DataType="viewmodels:SettingsSection">
            <StackPanel Orientation="Horizontal"
                        Spacing="12">
                <FontIcon Glyph="{Binding Glyph}"
                          FontSize="16"/>
                <TextBlock Text="{Binding Name}"/>
            </StackPanel>
        </DataTemplate>
    </Page.Resources>

    <Grid x:Name="LayoutRoot"
          Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <NavigationView Grid.Row="0"
                        x:Name="SettingsNavView"
                        PaneDisplayMode="Left"
                        IsBackButtonVisible="Collapsed"
                        IsSettingsVisible="False"
                        IsPaneToggleButtonVisible="False"
                        MenuItemsSource="{Binding SettingsSections}"
                        SelectedItem="{Binding SelectedSection, Mode=TwoWay}"
                        MenuItemTemplate="{StaticResource SettingsNavigationViewItemTemplate}"
                        SelectionChanged="SettingsNavView_SelectionChanged">

            <NavigationView.PaneHeader>
                <TextBlock Text="Settings"
                           Style="{StaticResource SubtitleTextBlockStyle}"
                           Margin="12,12,0,12"
                           VerticalAlignment="Center"/>
            </NavigationView.PaneHeader>

            <Frame x:Name="SettingsContentFrame">
                <Frame.ContentTransitions>
                    <TransitionCollection>
                        <NavigationThemeTransition/>
                    </TransitionCollection>
                </Frame.ContentTransitions>
            </Frame>

        </NavigationView>

        <Border Grid.Row="1"
                BorderThickness="0,1,0,0"
                BorderBrush="{ThemeResource CardStrokeColorDefaultBrush}"
                Padding="20,10">
            <Button Content="Save Settings"
                    Command="{Binding SaveSettingsCommand}"
                    HorizontalAlignment="Left"
                    Style="{StaticResource AccentButtonStyle}"/>
        </Border>
    </Grid>
</Page>
</file>

<file path=".github/dependabot.yml">
version: 2
updates:
  - package-ecosystem: "nuget"
    directory: "/"
    schedule:
      interval: "weekly"
</file>

<file path=".gitignore">
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Oo]ut/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd
megalinter-reports/
/streamweaver-updated.xml
.checkov.yml
.devskim.json
.gitleaks.toml
.grype.yaml
repomix-output.xml
Web/Overlay/react-overlay-updated.xml
</file>

<file path="Core/Models/Events/YouTubePollUpdateEvent.cs">
using StreamWeaver.Core.Models.Events.Messages;
namespace StreamWeaver.Core.Models.Events;
public class YouTubePollUpdateEvent : BaseEvent
{
    public required string PollId { get; init; }
    public required string Question { get; init; }
    public List<PollOption> Options { get; init; } = [];
    public bool IsActive { get; init; }
    public YouTubePollUpdateEvent() => Platform = "YouTube";
}
</file>

<file path="Core/Services/EmoteBadgeService.cs">
using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Models.Events.Messages;
using StreamWeaver.Core.Models.ServiceModels;
using StreamWeaver.Core.Services.Platforms;
namespace StreamWeaver.Core.Services;
public partial class EmoteBadgeService : IEmoteBadgeService
{
    private readonly TwitchApiService _twitchApiService;
    private readonly ILogger<EmoteBadgeService> _logger;
    private readonly ConcurrentDictionary<string, TwitchBadgeSet> _globalTwitchBadges = new();
    private readonly ConcurrentDictionary<string, CachedChannelData<TwitchBadgeSet>> _channelTwitchBadges = new();
    private static readonly TimeSpan s_channelDataCacheDuration = TimeSpan.FromHours(4);
    private record CachedChannelData<T>(DateTimeOffset Timestamp, ConcurrentDictionary<string, T> Data);
    public EmoteBadgeService(TwitchApiService twitchApiService, ILogger<EmoteBadgeService> logger)
    {
        _twitchApiService = twitchApiService ?? throw new ArgumentNullException(nameof(twitchApiService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _logger.LogInformation("Initialized.");
    }
    public async Task LoadGlobalTwitchDataAsync()
    {
        _logger.LogInformation("Loading global Twitch data...");
        await LoadGlobalTwitchBadgesAsync();
        _logger.LogInformation("Global data load complete. Global badge sets cached: {BadgeCount}", _globalTwitchBadges.Count);
    }
    private async Task LoadGlobalTwitchBadgesAsync()
    {
        try
        {
            TwitchLib.Api.Helix.Models.Chat.Badges.GetGlobalChatBadges.GetGlobalChatBadgesResponse? response =
                await _twitchApiService.GetGlobalBadgesAsync();
            if (response?.EmoteSet == null)
            {
                _logger.LogWarning("Received null or empty response when fetching global Twitch badges.");
                return;
            }
            _globalTwitchBadges.Clear();
            int loadedSets = 0;
            foreach (TwitchLib.Api.Helix.Models.Chat.Badges.BadgeEmoteSet? badgeSet in response.EmoteSet)
            {
                if (string.IsNullOrEmpty(badgeSet?.SetId) || badgeSet.Versions == null)
                    continue;
                TwitchBadgeSet versions = [];
                foreach (TwitchLib.Api.Helix.Models.Chat.Badges.BadgeVersion? version in badgeSet.Versions)
                {
                    if (
                        string.IsNullOrEmpty(version?.Id)
                        || string.IsNullOrEmpty(version.ImageUrl1x)
                        || string.IsNullOrEmpty(version.ImageUrl2x)
                        || string.IsNullOrEmpty(version.ImageUrl4x)
                    )
                    {
                        continue;
                    }
                    versions[version.Id] = new TwitchBadgeInfo(version.ImageUrl1x, version.ImageUrl2x, version.ImageUrl4x, badgeSet.SetId);
                }
                if (versions.Count > 0)
                {
                    _globalTwitchBadges[badgeSet.SetId] = versions;
                    loadedSets++;
                }
            }
            _logger.LogDebug("Successfully processed {LoadedSets} global Twitch badge sets.", loadedSets);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error loading global Twitch badges: {ErrorMessage}", ex.Message);
        }
    }
    public async Task LoadChannelTwitchDataAsync(string channelId, string userAccountId)
    {
        if (string.IsNullOrEmpty(channelId) || string.IsNullOrEmpty(userAccountId))
        {
            _logger.LogWarning(
                "LoadChannelTwitchDataAsync called with null or empty channelId ({ChannelId}) or userAccountId ({UserAccountId}).",
                channelId,
                userAccountId
            );
            return;
        }
        if (_channelTwitchBadges.TryGetValue(channelId, out CachedChannelData<TwitchBadgeSet>? existingCache) && IsCacheEntryValid(existingCache))
        {
            _logger.LogDebug("Channel Twitch data for {ChannelId} is already cached and valid.", channelId);
            return;
        }
        _logger.LogInformation(
            "Loading channel Twitch data for Channel ID: {ChannelId} (requested by User ID: {UserAccountId})...",
            channelId,
            userAccountId
        );
        await LoadChannelTwitchBadgesAsync(channelId, userAccountId);
        _logger.LogInformation("Channel data load attempt complete for Channel ID: {ChannelId}.", channelId);
    }
    private async Task LoadChannelTwitchBadgesAsync(string channelId, string userAccountId)
    {
        try
        {
            TwitchLib.Api.Helix.Models.Chat.Badges.GetChannelChatBadges.GetChannelChatBadgesResponse? response =
                await _twitchApiService.GetChannelBadgesAsync(channelId, userAccountId);
            if (response?.EmoteSet == null)
            {
                _logger.LogWarning("Received null or empty response when fetching channel badges for Channel ID {ChannelId}.", channelId);
                _channelTwitchBadges[channelId] = new CachedChannelData<TwitchBadgeSet>(
                    DateTimeOffset.UtcNow,
                    new ConcurrentDictionary<string, TwitchBadgeSet>()
                );
                return;
            }
            ConcurrentDictionary<string, TwitchBadgeSet> channelCache = new();
            int loadedSets = 0;
            foreach (TwitchLib.Api.Helix.Models.Chat.Badges.BadgeEmoteSet? badgeSet in response.EmoteSet)
            {
                if (string.IsNullOrEmpty(badgeSet?.SetId) || badgeSet.Versions == null)
                    continue;
                TwitchBadgeSet versions = [];
                foreach (TwitchLib.Api.Helix.Models.Chat.Badges.BadgeVersion? version in badgeSet.Versions)
                {
                    if (
                        string.IsNullOrEmpty(version?.Id)
                        || string.IsNullOrEmpty(version.ImageUrl1x)
                        || string.IsNullOrEmpty(version.ImageUrl2x)
                        || string.IsNullOrEmpty(version.ImageUrl4x)
                    )
                    {
                        continue;
                    }
                    versions[version.Id] = new TwitchBadgeInfo(version.ImageUrl1x, version.ImageUrl2x, version.ImageUrl4x, badgeSet.SetId);
                }
                if (versions.Count > 0)
                {
                    channelCache[badgeSet.SetId] = versions;
                    loadedSets++;
                }
            }
            _channelTwitchBadges[channelId] = new CachedChannelData<TwitchBadgeSet>(DateTimeOffset.UtcNow, channelCache);
            _logger.LogInformation("Cached {BadgeSetCount} Twitch badge sets for Channel ID {ChannelId}.", loadedSets, channelId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error loading channel Twitch badges for Channel ID {ChannelId}: {ErrorMessage}", channelId, ex.Message);
            _channelTwitchBadges.TryRemove(channelId, out _);
        }
    }
    public string? GetTwitchBadgeUrl(string badgeSetId, string badgeVersionId)
    {
        if (
            _globalTwitchBadges.TryGetValue(badgeSetId, out TwitchBadgeSet? globalSet)
            && globalSet.TryGetValue(badgeVersionId, out TwitchBadgeInfo? globalBadge)
        )
        {
            _logger.LogTrace("Found badge {BadgeSetId}/{BadgeVersionId} in global cache.", badgeSetId, badgeVersionId);
            return globalBadge.ImageUrl1x;
        }
        foreach (KeyValuePair<string, CachedChannelData<TwitchBadgeSet>> kvp in _channelTwitchBadges)
        {
            string channelId = kvp.Key;
            CachedChannelData<TwitchBadgeSet> channelCacheEntry = kvp.Value;
            if (IsCacheEntryValid(channelCacheEntry))
            {
                if (
                    channelCacheEntry.Data.TryGetValue(badgeSetId, out TwitchBadgeSet? channelSet)
                    && channelSet.TryGetValue(badgeVersionId, out TwitchBadgeInfo? channelBadge)
                )
                {
                    _logger.LogTrace(
                        "Found badge {BadgeSetId}/{BadgeVersionId} in cache for channel {ChannelId}.",
                        badgeSetId,
                        badgeVersionId,
                        channelId
                    );
                    return channelBadge.ImageUrl1x;
                }
            }
        }
        _logger.LogDebug("Badge {BadgeSetId}/{BadgeVersionId} not found in any valid cache.", badgeSetId, badgeVersionId);
        return null;
    }
    public List<MessageSegment> ParseYouTubeMessage(string rawMessage)
    {
        if (string.IsNullOrEmpty(rawMessage))
        {
            _logger.LogTrace("ParseYouTubeMessage called with null or empty message.");
            return [];
        }
        _logger.LogTrace("Parsing YouTube message as a single text segment.");
        return [new TextSegment { Text = rawMessage }];
    }
    public Task<string?> GetYouTubeStickerUrlAsync(string stickerId)
    {
        _logger.LogWarning("YouTube sticker URL retrieval is not implemented. Requested Sticker ID: {StickerId}", stickerId);
        return Task.FromResult<string?>(null);
    }
    private static bool IsCacheEntryValid<T>(CachedChannelData<T>? entry) =>
        entry != null && (DateTimeOffset.UtcNow - entry.Timestamp) < s_channelDataCacheDuration;
}
</file>

<file path="Core/Services/Platforms/StreamlabsService.cs">
using System.Text.Json;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Messaging;
using Microsoft.Extensions.Logging;
using SocketIOClient;
using SocketIOClient.Transport;
using StreamWeaver.Core.Messaging;
using StreamWeaver.Core.Models.Events;
using StreamWeaver.Core.Models.Events.Messages;
using StreamWeaver.Core.Models.Settings;
using StreamWeaver.Core.Plugins;
namespace StreamWeaver.Core.Services.Platforms;
public partial class StreamlabsService : ObservableObject, IStreamlabsClient, IDisposable
{
    private readonly IMessenger _messenger;
    private readonly PluginService _pluginService;
    private readonly ILogger<StreamlabsService> _logger;
    private SocketIOClient.SocketIO? _client;
    private string? _socketToken;
    private bool _isDisposed = false;
    public StreamlabsService(IMessenger messenger, PluginService pluginService, ILogger<StreamlabsService> logger)
    {
        _messenger = messenger ?? throw new ArgumentNullException(nameof(messenger));
        _pluginService = pluginService ?? throw new ArgumentNullException(nameof(pluginService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _logger.LogInformation("Initialized.");
    }
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsConnected))]
    public partial ConnectionStatus Status { get; set; } = ConnectionStatus.Disconnected;
    [ObservableProperty]
    public partial string? StatusMessage { get; set; }
    public bool IsConnected => Status == ConnectionStatus.Connected;
    public async Task<bool> ConnectAsync(string socketToken)
    {
        if (Status is ConnectionStatus.Connected or ConnectionStatus.Connecting)
        {
            _logger.LogDebug("Connect requested but already {ConnectionStatus}.", Status);
            return Status == ConnectionStatus.Connected;
        }
        if (string.IsNullOrWhiteSpace(socketToken))
        {
            const string errorMsg = "Socket token is missing.";
            _logger.LogError("Connect failed - {ErrorMessage}", errorMsg);
            Status = ConnectionStatus.Error;
            StatusMessage = errorMsg;
            return false;
        }
        Status = ConnectionStatus.Connecting;
        StatusMessage = "Connecting...";
        _socketToken = socketToken;
        _logger.LogInformation("Attempting connection to Streamlabs Socket API...");
        await DisposeClientAsync();
        var uri = new Uri("https://sockets.streamlabs.com");
        _client = new SocketIOClient.SocketIO(
            uri,
            new SocketIOOptions
            {
                Query = new Dictionary<string, string> { { "token", _socketToken } },
                Transport = TransportProtocol.WebSocket,
                ConnectionTimeout = TimeSpan.FromSeconds(20),
            }
        );
        RegisterClientEvents();
        try
        {
            await _client.ConnectAsync();
            _logger.LogInformation("Connection attempt initiated.");
            return true;
        }
        catch (ConnectionException conEx)
        {
            _logger.LogError(conEx, "Connection failed during ConnectAsync: {ErrorMessage}", conEx.Message);
            Status = ConnectionStatus.Error;
            StatusMessage = $"Connection Failed: {conEx.Message}";
            await DisposeClientAsync();
            return false;
        }
        catch (TimeoutException timeEx)
        {
            _logger.LogError(timeEx, "Connection timed out during ConnectAsync.");
            Status = ConnectionStatus.Error;
            StatusMessage = "Connection Timed Out.";
            await DisposeClientAsync();
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during ConnectAsync: {ErrorMessage}", ex.Message);
            Status = ConnectionStatus.Error;
            StatusMessage = $"Connection Failed: {ex.Message}";
            await DisposeClientAsync();
            return false;
        }
    }
    public async Task DisconnectAsync()
    {
        if (Status == ConnectionStatus.Disconnected && _client == null)
        {
            _logger.LogDebug("Disconnect requested but already disconnected.");
            return;
        }
        ConnectionStatus previousStatus = Status;
        _logger.LogInformation("Disconnecting from Streamlabs...");
        Status = ConnectionStatus.Disconnected;
        StatusMessage = "Disconnected.";
        await DisposeClientAsync();
        if (previousStatus != ConnectionStatus.Disconnected)
        {
            SystemMessageEvent systemEvent = new() { Platform = "Streamlabs", Message = "Disconnected from Streamlabs Events." };
            _messenger.Send(new NewEventMessage(systemEvent));
            _ = _pluginService.RouteEventToProcessorsAsync(systemEvent);
        }
        _logger.LogInformation("Disconnection process complete.");
    }
    private void RegisterClientEvents()
    {
        if (_client == null)
            return;
        _logger.LogDebug("Registering Socket.IO client events...");
        _client.OnConnected += Client_OnConnected;
        _client.OnDisconnected += Client_OnDisconnected;
        _client.OnError += Client_OnError;
        _client.On("event", HandleStreamlabsEvent);
        _client.OnAny(Client_OnAny);
        _client.OnReconnectAttempt += Client_OnReconnectAttempt;
        _client.OnReconnected += Client_OnReconnected;
        _client.OnReconnectError += Client_OnReconnectError;
        _client.OnReconnectFailed += Client_OnReconnectFailed;
        _client.OnPing += Client_OnPing;
        _client.OnPong += Client_OnPong;
    }
    private void UnregisterClientEvents()
    {
        if (_client == null)
            return;
        _logger.LogDebug("Unregistering Socket.IO client events...");
        try
        {
            _client.OnConnected -= Client_OnConnected;
            _client.OnDisconnected -= Client_OnDisconnected;
            _client.OnError -= Client_OnError;
            _client.Off("event");
            _client.OnAny(null);
            _client.OnReconnectAttempt -= Client_OnReconnectAttempt;
            _client.OnReconnected -= Client_OnReconnected;
            _client.OnReconnectError -= Client_OnReconnectError;
            _client.OnReconnectFailed -= Client_OnReconnectFailed;
            _client.OnPing -= Client_OnPing;
            _client.OnPong -= Client_OnPong;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Exception occurred during client event unregistration (ignoring).");
        }
    }
    private async Task DisposeClientAsync()
    {
        if (_client == null)
            return;
        _logger.LogDebug("Disposing client instance...");
        UnregisterClientEvents();
        if (_client.Connected)
        {
            _logger.LogDebug("Client is connected, attempting explicit disconnect...");
            try
            {
                Task disconnectTask = _client.DisconnectAsync();
                if (await Task.WhenAny(disconnectTask, Task.Delay(TimeSpan.FromSeconds(5))) != disconnectTask)
                {
                    _logger.LogWarning("Explicit disconnect timed out after 5 seconds.");
                }
                _logger.LogDebug("Explicit disconnect completed or timed out.");
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Error during explicit disconnect (ignoring): {ErrorMessage}", ex.Message);
            }
        }
        try
        {
            _logger.LogDebug("Calling client Dispose()...");
            _client.Dispose();
            _logger.LogDebug("Client Dispose() called.");
        }
        catch (ObjectDisposedException)
        {
            _logger.LogDebug("Client was already disposed.");
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error during client dispose (ignoring): {ErrorMessage}", ex.Message);
        }
        _client = null;
        _socketToken = null;
        _logger.LogDebug("Client instance has been disposed and set to null.");
    }
    private void Client_OnConnected(object? sender, EventArgs e)
    {
        _logger.LogInformation("Successfully connected to Streamlabs Socket API!");
        Status = ConnectionStatus.Connected;
        StatusMessage = "Connected";
        SystemMessageEvent systemEvent = new() { Platform = "Streamlabs", Message = "Connected to Streamlabs Events." };
        _ = _pluginService.RouteEventToProcessorsAsync(systemEvent);
        _messenger.Send(new NewEventMessage(systemEvent));
    }
    private void Client_OnDisconnected(object? sender, string reason)
    {
        if (Status != ConnectionStatus.Disconnected)
        {
            _logger.LogWarning("Disconnected from Streamlabs. Reason: {Reason}", reason);
            bool isError = reason != "io client disconnect";
            Status = isError ? ConnectionStatus.Error : ConnectionStatus.Disconnected;
            StatusMessage = isError ? $"Disconnected: {reason}" : "Disconnected.";
            SystemMessageEvent systemEvent = new()
            {
                Platform = "Streamlabs",
                Message = $"Disconnected: {reason}",
                Level = isError ? SystemMessageLevel.Warning : SystemMessageLevel.Info,
            };
            _ = _pluginService.RouteEventToProcessorsAsync(systemEvent);
            _messenger.Send(new NewEventMessage(systemEvent));
        }
        else
        {
            _logger.LogDebug("OnDisconnected fired, but status was already Disconnected (likely manual). Reason: {Reason}", reason);
        }
    }
    private void Client_OnError(object? sender, string error)
    {
        _logger.LogError("Streamlabs Socket Error: {Error}", error);
        if (Status != ConnectionStatus.Error)
        {
            Status = ConnectionStatus.Error;
            StatusMessage = $"Error: {error}";
            SystemMessageEvent systemEvent = new()
            {
                Platform = "Streamlabs",
                Message = $"Error: {error}",
                Level = SystemMessageLevel.Error,
            };
            _ = _pluginService.RouteEventToProcessorsAsync(systemEvent);
            _messenger.Send(new NewEventMessage(systemEvent));
        }
    }
    private void Client_OnAny(string eventName, SocketIOResponse response)
    {
        if (eventName != "event")
        {
            _logger.LogTrace("Received unhandled Socket.IO event. Name: '{EventName}', Response: {Response}", eventName, response.ToString());
        }
    }
    private void Client_OnReconnectAttempt(object? sender, int attempt)
    {
        _logger.LogInformation("Attempting to reconnect to Streamlabs (Attempt #{Attempt})...", attempt);
        if (Status != ConnectionStatus.Connecting)
        {
            Status = ConnectionStatus.Connecting;
            StatusMessage = $"Reconnecting (Attempt {attempt})...";
        }
    }
    private void Client_OnReconnected(object? sender, int attempt)
    {
        _logger.LogInformation("Successfully reconnected to Streamlabs on attempt #{Attempt}!", attempt);
        Status = ConnectionStatus.Connected;
        StatusMessage = "Reconnected";
        SystemMessageEvent systemEvent = new() { Platform = "Streamlabs", Message = "Reconnected to Streamlabs Events." };
        _ = _pluginService.RouteEventToProcessorsAsync(systemEvent);
        _messenger.Send(new NewEventMessage(systemEvent));
    }
    private void Client_OnReconnectError(object? sender, Exception ex)
    {
        _logger.LogError(ex, "Error occurred during reconnect attempt: {ErrorMessage}", ex.Message);
        Status = ConnectionStatus.Error;
        StatusMessage = $"Reconnect Error: {ex.Message}";
    }
    private void Client_OnReconnectFailed(object? sender, EventArgs e)
    {
        _logger.LogError("Failed to reconnect to Streamlabs after multiple attempts.");
        Status = ConnectionStatus.Error;
        StatusMessage = "Reconnect Failed.";
        SystemMessageEvent systemEvent = new()
        {
            Platform = "Streamlabs",
            Message = "Failed to reconnect to Streamlabs.",
            Level = SystemMessageLevel.Error,
        };
        _ = _pluginService.RouteEventToProcessorsAsync(systemEvent);
        _messenger.Send(new NewEventMessage(systemEvent));
    }
    private void Client_OnPing(object? sender, EventArgs e) => _logger.LogTrace("Ping sent");
    private void Client_OnPong(object? sender, TimeSpan span) => _logger.LogTrace("Pong received ({PongTime}ms)", span.TotalMilliseconds);
    private void HandleStreamlabsEvent(SocketIOResponse response)
    {
        _logger.LogTrace("Received 'event' message from Streamlabs.");
        try
        {
            JsonElement eventDataArray = response.GetValue<JsonElement>();
            if (eventDataArray.ValueKind != JsonValueKind.Array)
            {
                _logger.LogWarning(
                    "Received Streamlabs event payload that was not a JSON array. Kind: {PayloadKind}, Payload: {Payload}",
                    eventDataArray.ValueKind,
                    response.ToString()
                );
                return;
            }
            foreach (JsonElement element in eventDataArray.EnumerateArray())
            {
                if (element.ValueKind != JsonValueKind.Object)
                {
                    _logger.LogWarning("Skipping non-object element within Streamlabs event array. Kind: {ElementKind}", element.ValueKind);
                    continue;
                }
                if (!element.TryGetProperty("type", out JsonElement typeProp) || typeProp.ValueKind != JsonValueKind.String)
                {
                    _logger.LogWarning(
                        "Streamlabs event object missing 'type' property or it's not a string. Payload: {Payload}",
                        element.GetRawText()
                    );
                    continue;
                }
                string? eventType = typeProp.GetString();
                JsonElement? messagePayload = null;
                if (element.TryGetProperty("message", out JsonElement msgProp))
                {
                    if (msgProp.ValueKind == JsonValueKind.Array && msgProp.GetArrayLength() > 0)
                    {
                        if (msgProp[0].ValueKind == JsonValueKind.Object)
                        {
                            messagePayload = msgProp[0];
                        }
                        else
                        {
                            _logger.LogWarning(
                                "Streamlabs event type '{EventType}' message array element was not an object. Kind: {ElementKind}",
                                eventType,
                                msgProp[0].ValueKind
                            );
                        }
                    }
                    else if (msgProp.ValueKind == JsonValueKind.Object)
                    {
                        messagePayload = msgProp;
                    }
                    else
                    {
                        _logger.LogWarning(
                            "Streamlabs event type '{EventType}' had unexpected 'message' property kind: {PropertyKind}",
                            eventType,
                            msgProp.ValueKind
                        );
                    }
                }
                else if (element.TryGetProperty("data", out JsonElement dataProp) && dataProp.ValueKind == JsonValueKind.Object)
                {
                    messagePayload = dataProp;
                    _logger.LogDebug("Streamlabs event type '{EventType}' - using 'data' property for payload.", eventType);
                }
                if (messagePayload.HasValue && messagePayload.Value.ValueKind == JsonValueKind.Object)
                {
                    _logger.LogDebug(
                        "Processing Streamlabs event. Type: '{EventType}', Payload: {PayloadText}",
                        eventType,
                        messagePayload.Value.GetRawText()
                    );
                    BaseEvent? commonEvent = ConvertToCommonEvent(eventType, messagePayload.Value);
                    if (commonEvent != null)
                    {
                        _ = _pluginService.RouteEventToProcessorsAsync(commonEvent).ConfigureAwait(false);
                        _messenger.Send(new NewEventMessage(commonEvent));
                        _logger.LogInformation("Processed and dispatched Streamlabs event: {EventType}", commonEvent.GetType().Name);
                    }
                }
                else
                {
                    _logger.LogWarning(
                        "Streamlabs event type '{EventType}' received without a standard message/data object payload. Element: {ElementText}",
                        eventType,
                        element.GetRawText()
                    );
                }
            }
        }
        catch (JsonException jsonEx)
        {
            _logger.LogError(jsonEx, "Failed to parse Streamlabs event JSON. Payload: {Payload}", response.ToString());
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error handling Streamlabs event: {ErrorMessage}", ex.Message);
        }
    }
    private BaseEvent? ConvertToCommonEvent(string? type, JsonElement payload)
    {
        switch (type?.ToLowerInvariant())
        {
            case "donation":
                return ParseDonation(payload);
            case "follow":
                return ParseFollow(payload);
            case "subscription":
            case "resub":
                return ParseSubscription(payload);
            case "host":
                return ParseHost(payload);
            case "raid":
                return ParseRaid(payload);
            case "bits":
                return ParseBits(payload);
            default:
                _logger.LogDebug("Unhandled Streamlabs event type '{EventType}'. Payload: {PayloadText}", type, payload.GetRawText());
                return null;
        }
    }
    private static DonationEvent? ParseDonation(JsonElement payload)
    {
        try
        {
            string? name = payload.TryGetProperty("name", out JsonElement nameEl) ? nameEl.GetString() : "Anonymous";
            decimal amount =
                payload.TryGetProperty("amount", out JsonElement amountEl) && decimal.TryParse(amountEl.GetString(), out decimal parsedAmount)
                    ? parsedAmount
                    : 0M;
            string? currency = payload.TryGetProperty("currency", out JsonElement currEl) ? currEl.GetString() : "USD";
            string? message = payload.TryGetProperty("message", out JsonElement msgEl) ? msgEl.GetString() : null;
            string donationId =
                payload.TryGetProperty("donation_id", out JsonElement idEl) && idEl.ValueKind == JsonValueKind.Number ? idEl.GetInt64().ToString()
                : payload.TryGetProperty("_id", out JsonElement underscoreIdEl) ? underscoreIdEl.GetString() ?? Guid.NewGuid().ToString()
                : Guid.NewGuid().ToString();
            DateTime timestamp =
                payload.TryGetProperty("created_at", out JsonElement tsEl) && DateTime.TryParse(tsEl.GetString(), out DateTime ts)
                    ? ts.ToUniversalTime()
                    : DateTime.UtcNow;
            return new DonationEvent
            {
                Platform = "Streamlabs",
                Timestamp = timestamp,
                DonationId = donationId,
                UserId = null,
                Username = name ?? "Someone",
                Amount = amount,
                Currency = currency ?? "USD",
                RawMessage = message ?? string.Empty,
                ParsedMessage = string.IsNullOrWhiteSpace(message) ? [] : [new TextSegment { Text = message }],
                Type = DonationType.Streamlabs,
            };
        }
        catch (Exception ex)
        {
            App.GetService<ILogger<StreamlabsService>>()
                .LogError(ex, "Failed to parse Streamlabs donation payload. Payload: {PayloadText}", payload.GetRawText());
            return null;
        }
    }
    private static FollowEvent? ParseFollow(JsonElement payload)
    {
        try
        {
            string? name = payload.TryGetProperty("name", out JsonElement nameEl) ? nameEl.GetString() : "Someone";
            string? userId =
                payload.TryGetProperty("twitch_id", out JsonElement tIdEl) ? tIdEl.GetString()
                : payload.TryGetProperty("id", out JsonElement idEl) ? idEl.GetString()
                : null;
            DateTime timestamp =
                payload.TryGetProperty("created_at", out JsonElement tsEl) && DateTime.TryParse(tsEl.GetString(), out DateTime ts)
                    ? ts.ToUniversalTime()
                    : DateTime.UtcNow;
            return new FollowEvent
            {
                Platform = "Streamlabs",
                Timestamp = timestamp,
                UserId = userId,
                Username = name ?? "Someone",
            };
        }
        catch (Exception ex)
        {
            App.GetService<ILogger<StreamlabsService>>()
                .LogError(ex, "Failed to parse Streamlabs follow payload. Payload: {PayloadText}", payload.GetRawText());
            return null;
        }
    }
    private static SubscriptionEvent? ParseSubscription(JsonElement payload)
    {
        try
        {
            string? name = payload.TryGetProperty("name", out JsonElement nameEl) ? nameEl.GetString() : "Someone";
            bool isGift = payload.TryGetProperty("gifter", out JsonElement gifterEl) && !string.IsNullOrEmpty(gifterEl.GetString());
            string? gifterName = isGift ? gifterEl.GetString() : null;
            int months = payload.TryGetProperty("months", out JsonElement monthsEl) && monthsEl.TryGetInt32(out int m) ? m : 1;
            string? message = payload.TryGetProperty("message", out JsonElement msgEl) ? msgEl.GetString() : null;
            string plan = payload.TryGetProperty("sub_plan", out JsonElement planEl) ? planEl.GetString() ?? "Unknown" : "Unknown";
            string tier = MapSubPlan(plan);
            DateTime timestamp =
                payload.TryGetProperty("created_at", out JsonElement tsEl) && DateTime.TryParse(tsEl.GetString(), out DateTime ts)
                    ? ts.ToUniversalTime()
                    : DateTime.UtcNow;
            int? cumulativeMonths = payload.TryGetProperty("streak_months", out JsonElement streakEl) && streakEl.TryGetInt32(out int s) ? s : null;
            return new SubscriptionEvent
            {
                Platform = "Streamlabs",
                Timestamp = timestamp,
                UserId = null,
                Username = (isGift ? gifterName : name) ?? "Someone",
                IsGift = isGift,
                RecipientUsername = isGift ? name : null,
                Months = months,
                Tier = tier,
                CumulativeMonths = cumulativeMonths ?? 0,
                Message = message,
            };
        }
        catch (Exception ex)
        {
            App.GetService<ILogger<StreamlabsService>>()
                .LogError(ex, "Failed to parse Streamlabs subscription payload. Payload: {PayloadText}", payload.GetRawText());
            return null;
        }
    }
    private static DonationEvent? ParseBits(JsonElement payload)
    {
        try
        {
            string? name = payload.TryGetProperty("name", out JsonElement nameEl) ? nameEl.GetString() : "Anonymous";
            int bitsAmount = payload.TryGetProperty("amount", out JsonElement amountEl) && amountEl.TryGetInt32(out int b) ? b : 0;
            string? message = payload.TryGetProperty("message", out JsonElement msgEl) ? msgEl.GetString() : null;
            string eventId = payload.TryGetProperty("_id", out JsonElement idEl)
                ? idEl.GetString() ?? Guid.NewGuid().ToString()
                : Guid.NewGuid().ToString();
            DateTime timestamp =
                payload.TryGetProperty("created_at", out JsonElement tsEl) && DateTime.TryParse(tsEl.GetString(), out DateTime ts)
                    ? ts.ToUniversalTime()
                    : DateTime.UtcNow;
            return new DonationEvent
            {
                Platform = "Streamlabs",
                Timestamp = timestamp,
                DonationId = eventId,
                UserId = null,
                Username = name ?? "Someone",
                Amount = bitsAmount,
                Currency = "Bits",
                RawMessage = message ?? string.Empty,
                ParsedMessage = string.IsNullOrWhiteSpace(message) ? [] : [new TextSegment { Text = message }],
                Type = DonationType.Bits,
            };
        }
        catch (Exception ex)
        {
            App.GetService<ILogger<StreamlabsService>>()
                .LogError(ex, "Failed to parse Streamlabs bits payload. Payload: {PayloadText}", payload.GetRawText());
            return null;
        }
    }
    private static RaidEvent? ParseRaid(JsonElement payload)
    {
        try
        {
            string? name = payload.TryGetProperty("name", out JsonElement nameEl) ? nameEl.GetString() : "Someone";
            int viewerCount = payload.TryGetProperty("raiders", out JsonElement countEl) && countEl.TryGetInt32(out int c) ? c : 0;
            DateTime timestamp = DateTime.UtcNow;
            return new RaidEvent
            {
                Platform = "Streamlabs",
                Timestamp = timestamp,
                RaiderUsername = name ?? "Someone",
                RaiderUserId = null,
                ViewerCount = viewerCount,
            };
        }
        catch (Exception ex)
        {
            App.GetService<ILogger<StreamlabsService>>()
                .LogError(ex, "Failed to parse Streamlabs raid payload. Payload: {PayloadText}", payload.GetRawText());
            return null;
        }
    }
    private static HostEvent? ParseHost(JsonElement payload)
    {
        try
        {
            string? name = payload.TryGetProperty("name", out JsonElement nameEl) ? nameEl.GetString() : "Someone";
            int viewerCount = payload.TryGetProperty("viewers", out JsonElement countEl) && countEl.TryGetInt32(out int c) ? c : 0;
            DateTime timestamp = DateTime.UtcNow;
            return new HostEvent
            {
                Platform = "Streamlabs",
                Timestamp = timestamp,
                HosterUsername = name,
                ViewerCount = viewerCount,
                IsAutoHost = false,
            };
        }
        catch (Exception ex)
        {
            App.GetService<ILogger<StreamlabsService>>()
                .LogError(ex, "Failed to parse Streamlabs host payload. Payload: {PayloadText}", payload.GetRawText());
            return null;
        }
    }
    private static string MapSubPlan(string? plan) =>
        plan switch
        {
            "Prime" => "Twitch Prime",
            "1000" => "Tier 1",
            "2000" => "Tier 2",
            "3000" => "Tier 3",
            _ => !string.IsNullOrWhiteSpace(plan) ? $"Unknown ({plan})" : "Unknown Tier",
        };
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    protected virtual void Dispose(bool disposing)
    {
        if (_isDisposed)
            return;
        _logger.LogDebug("Dispose({Disposing}) called.", disposing);
        if (disposing)
        {
            try
            {
                _logger.LogDebug("Initiating async client disposal from Dispose method...");
                DisposeClientAsync().Wait(TimeSpan.FromSeconds(3));
                _logger.LogDebug("Async client disposal completed or timed out.");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Exception during sync-over-async disposal of client.");
            }
        }
        _isDisposed = true;
        _logger.LogInformation("Service disposed.");
    }
}
</file>

<file path="Core/Services/Platforms/TwitchChatService.cs">
using System.Collections.Concurrent;
using CommunityToolkit.Mvvm.Messaging;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Messaging;
using StreamWeaver.Core.Models.Events;
using StreamWeaver.Core.Models.Events.Messages;
using StreamWeaver.Core.Models.Settings;
using StreamWeaver.Core.Plugins;
using TwitchLib.Client;
using TwitchLib.Client.Enums;
using TwitchLib.Client.Events;
using TwitchLib.Client.Models;
using TwitchLib.Communication.Clients;
using TwitchLib.Communication.Events;
using TwitchLib.Communication.Models;
namespace StreamWeaver.Core.Services.Platforms;
internal sealed partial class TwitchClientWrapper(TwitchClient client, string accountId, string username, ILogger logger) : IDisposable
{
    public TwitchClient ClientInstance { get; } = client ?? throw new ArgumentNullException(nameof(client));
    public ConnectionStatus Status { get; set; } = ConnectionStatus.Disconnected;
    public string? StatusMessage { get; set; }
    public string Username { get; } = username ?? throw new ArgumentNullException(nameof(username));
    public string AccountId { get; } = accountId ?? throw new ArgumentNullException(nameof(accountId));
    private readonly ILogger _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    public EventHandler<OnConnectedArgs>? OnConnectedHandler { get; set; }
    public EventHandler<OnJoinedChannelArgs>? OnJoinedChannelHandler { get; set; }
    public EventHandler<OnMessageReceivedArgs>? OnMessageReceivedHandler { get; set; }
    public EventHandler<OnDisconnectedEventArgs>? OnDisconnectedHandler { get; set; }
    public EventHandler<OnConnectionErrorArgs>? OnConnectionErrorHandler { get; set; }
    public EventHandler<OnErrorEventArgs>? OnErrorHandler { get; set; }
    public EventHandler<OnNewSubscriberArgs>? OnNewSubscriberHandler { get; set; }
    public EventHandler<OnGiftedSubscriptionArgs>? OnGiftedSubscriptionHandler { get; set; }
    public EventHandler<OnRaidNotificationArgs>? OnRaidNotificationHandler { get; set; }
    private bool _disposed = false;
    public void UnhookEvents()
    {
        _logger.LogTrace("[{Username}] Unhooking events.", Username);
        try
        {
            if (OnConnectedHandler != null)
                ClientInstance.OnConnected -= OnConnectedHandler;
            if (OnJoinedChannelHandler != null)
                ClientInstance.OnJoinedChannel -= OnJoinedChannelHandler;
            if (OnMessageReceivedHandler != null)
                ClientInstance.OnMessageReceived -= OnMessageReceivedHandler;
            if (OnDisconnectedHandler != null)
                ClientInstance.OnDisconnected -= OnDisconnectedHandler;
            if (OnConnectionErrorHandler != null)
                ClientInstance.OnConnectionError -= OnConnectionErrorHandler;
            if (OnErrorHandler != null)
                ClientInstance.OnError -= OnErrorHandler;
            if (OnNewSubscriberHandler != null)
                ClientInstance.OnNewSubscriber -= OnNewSubscriberHandler;
            if (OnGiftedSubscriptionHandler != null)
                ClientInstance.OnGiftedSubscription -= OnGiftedSubscriptionHandler;
            if (OnRaidNotificationHandler != null)
                ClientInstance.OnRaidNotification -= OnRaidNotificationHandler;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "[{Username}] Exception during event unhooking (ignoring).", Username);
        }
    }
    public void Dispose()
    {
        if (_disposed)
            return;
        _disposed = true;
        _logger.LogDebug("[{Username}] Disposing wrapper...", Username);
        UnhookEvents();
        try
        {
            if (ClientInstance.IsConnected)
            {
                _logger.LogDebug("[{Username}] Client is connected, calling Disconnect().", Username);
                ClientInstance.Disconnect();
                _logger.LogInformation("[{Username}] Disconnected client instance via wrapper Dispose.", Username);
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "[{Username}] Error during client disconnect in wrapper Dispose (ignoring): {ErrorMessage}", Username, ex.Message);
        }
        _logger.LogDebug("[{Username}] Dispose finished.", Username);
        GC.SuppressFinalize(this);
    }
}
public partial class TwitchChatService : ITwitchClient, IDisposable
{
    private readonly IMessenger _messenger;
    private readonly IEmoteBadgeService _emoteBadgeService;
    private readonly PluginService _pluginService;
    private readonly ILogger<TwitchChatService> _logger;
    private readonly ConcurrentDictionary<string, TwitchClientWrapper> _activeClients = new();
    private static readonly Dictionary<string, (int Priority, string Color)> s_twitchBadgeColorPriority = new(StringComparer.OrdinalIgnoreCase)
    {
        { "broadcaster", (10, "#E91916") },
        { "admin", (9, "#FAAF19") },
        { "staff", (9, "#FAAF19") },
        { "global_mod", (8, "#0AD57F") },
        { "moderator", (7, "#0AD57F") },
        { "vip", (6, "#E005B9") },
        { "partner", (5, "#7533FF") },
        { "subscriber", (4, "#7533FF") },
        { "founder", (3, "#7533FF") },
    };
    private bool _isDisposed = false;
    public TwitchChatService(
        IMessenger messenger,
        IEmoteBadgeService emoteBadgeService,
        PluginService pluginService,
        ILogger<TwitchChatService> logger
    )
    {
        _messenger = messenger ?? throw new ArgumentNullException(nameof(messenger));
        _emoteBadgeService = emoteBadgeService ?? throw new ArgumentNullException(nameof(emoteBadgeService));
        _pluginService = pluginService ?? throw new ArgumentNullException(nameof(pluginService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _logger.LogInformation("Initialized.");
    }
    private static string? CalculateTwitchUsernameColor(List<BadgeInfo> badges)
    {
        if (badges == null || badges.Count == 0)
            return null;
        string? highestPriorityColor = null;
        int highestPriority = -1;
        foreach (BadgeInfo badge in badges)
        {
            string[] parts = badge.Identifier.Split('/');
            if (parts.Length >= 2 && parts[0].Equals("twitch", StringComparison.OrdinalIgnoreCase))
            {
                string badgeName = parts[1];
                if (s_twitchBadgeColorPriority.TryGetValue(badgeName, out (int Priority, string Color) priorityInfo))
                {
                    if (priorityInfo.Priority > highestPriority)
                    {
                        highestPriority = priorityInfo.Priority;
                        highestPriorityColor = priorityInfo.Color;
                    }
                }
            }
        }
        return highestPriorityColor;
    }
    public Task<bool> ConnectAsync(string accountId, string username, string accessToken)
    {
        string logUsername = username ?? accountId ?? "N/A";
        if (_isDisposed)
        {
            _logger.LogWarning("[{LogUsername}] Connect failed: Service is disposed.", logUsername);
            return Task.FromResult(false);
        }
        if (string.IsNullOrWhiteSpace(accountId) || string.IsNullOrWhiteSpace(username) || string.IsNullOrWhiteSpace(accessToken))
        {
            _logger.LogError("[{LogUsername}] Connect failed: Invalid parameters (AccountId, Username, or AccessToken missing/empty).", logUsername);
            return Task.FromResult(false);
        }
        if (
            _activeClients.TryGetValue(accountId, out TwitchClientWrapper? existingWrapper)
            && (existingWrapper.Status is ConnectionStatus.Connected or ConnectionStatus.Connecting)
        )
        {
            _logger.LogInformation(
                "[{Username}] Connect requested but already {ConnectionStatus}.",
                existingWrapper.Username,
                existingWrapper.Status
            );
            return Task.FromResult(existingWrapper.Status == ConnectionStatus.Connected);
        }
        if (existingWrapper != null)
        {
            _logger.LogInformation(
                "[{Username}] Removing previous client wrapper (State: {ConnectionStatus}) before reconnecting.",
                existingWrapper.Username,
                existingWrapper.Status
            );
            if (_activeClients.TryRemove(accountId, out TwitchClientWrapper? removedWrapper))
            {
                removedWrapper?.Dispose();
            }
        }
        _logger.LogInformation("[{Username}] Creating new client instance for Account ID: {AccountId}", username, accountId);
        ConnectionCredentials credentials = new(username, $"oauth:{accessToken}");
        ClientOptions clientOptions = new() { MessagesAllowedInPeriod = 750, ThrottlingPeriod = TimeSpan.FromSeconds(30) };
        WebSocketClient customClient = new(clientOptions);
        TwitchClient newClient = new(customClient);
        newClient.Initialize(credentials, username);
        var wrapper = new TwitchClientWrapper(newClient, accountId, username, _logger)
        {
            Status = ConnectionStatus.Connecting,
            StatusMessage = "Connecting...",
            OnConnectedHandler = (s, e) => Client_OnConnected(accountId, s, e),
        };
        newClient.OnConnected += wrapper.OnConnectedHandler;
        wrapper.OnJoinedChannelHandler = (s, e) => Client_OnJoinedChannel(accountId, s, e);
        newClient.OnJoinedChannel += wrapper.OnJoinedChannelHandler;
        wrapper.OnMessageReceivedHandler = (s, e) => _ = Client_OnMessageReceived(accountId, s, e);
        newClient.OnMessageReceived += wrapper.OnMessageReceivedHandler;
        wrapper.OnDisconnectedHandler = (s, e) => Client_OnDisconnected(accountId, s, e);
        newClient.OnDisconnected += wrapper.OnDisconnectedHandler;
        wrapper.OnConnectionErrorHandler = (s, e) => Client_OnConnectionError(accountId, s, e);
        newClient.OnConnectionError += wrapper.OnConnectionErrorHandler;
        wrapper.OnErrorHandler = (s, e) => Client_OnError(accountId, s, e);
        newClient.OnError += wrapper.OnErrorHandler;
        wrapper.OnNewSubscriberHandler = (s, e) => Client_OnNewSubscriber(accountId, s, e);
        newClient.OnNewSubscriber += wrapper.OnNewSubscriberHandler;
        wrapper.OnGiftedSubscriptionHandler = (s, e) => Client_OnGiftedSubscription(accountId, s, e);
        newClient.OnGiftedSubscription += wrapper.OnGiftedSubscriptionHandler;
        wrapper.OnRaidNotificationHandler = (s, e) => Client_OnRaidNotification(accountId, s, e);
        newClient.OnRaidNotification += wrapper.OnRaidNotificationHandler;
        if (!_activeClients.TryAdd(accountId, wrapper))
        {
            _logger.LogCritical(
                "[{Username}] Failed to add client wrapper to dictionary (race condition?). Aborting connection for Account ID {AccountId}.",
                username,
                accountId
            );
            wrapper.Dispose();
            return Task.FromResult(false);
        }
        try
        {
            newClient.Connect();
            _logger.LogInformation(
                "[{Username}] Connection process initiated for Account ID: {AccountId}. Waiting for OnConnected event.",
                username,
                accountId
            );
            return Task.FromResult(true);
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex,
                "[{Username}] Exception during initial client.Connect() call for Account ID {AccountId}: {ErrorMessage}",
                username,
                accountId,
                ex.Message
            );
            wrapper.Status = ConnectionStatus.Error;
            wrapper.StatusMessage = $"Failed to initiate connection: {ex.Message}";
            if (_activeClients.TryRemove(accountId, out _))
            {
                _logger.LogDebug(
                    "[{Username}] Removed failed client wrapper for Account ID {AccountId} after connection exception.",
                    username,
                    accountId
                );
            }
            wrapper.Dispose();
            return Task.FromResult(false);
        }
    }
    public Task DisconnectAsync(string accountId)
    {
        if (_isDisposed)
        {
            _logger.LogDebug("[{AccountId}] Disconnect skipped: Service is disposed.", accountId);
            return Task.CompletedTask;
        }
        _logger.LogInformation("[{AccountId}] Disconnect requested.", accountId);
        if (_activeClients.TryRemove(accountId, out TwitchClientWrapper? wrapper))
        {
            string username = wrapper.Username;
            _logger.LogInformation("[{Username}] Disposing client wrapper for Account ID: {AccountId}", username, accountId);
            wrapper.Dispose();
            _logger.LogInformation("[{Username}] Client wrapper removed and disposed for Account ID: {AccountId}", username, accountId);
            SystemMessageEvent systemEvent = new()
            {
                Platform = "Twitch",
                OriginatingAccountId = accountId,
                Message = $"Disconnected Twitch account: {username}",
            };
            _messenger.Send(new NewEventMessage(systemEvent));
            _ = _pluginService.RouteEventToProcessorsAsync(systemEvent);
        }
        else
        {
            _logger.LogWarning("[{AccountId}] Client wrapper not found during disconnect request.", accountId);
        }
        _messenger.Send(new ConnectionsUpdatedMessage());
        return Task.CompletedTask;
    }
    public Task JoinChannelAsync(string accountId, string channelName)
    {
        if (_activeClients.TryGetValue(accountId, out TwitchClientWrapper? wrapper))
        {
            if (wrapper.Status == ConnectionStatus.Connected)
            {
                string channel = channelName.ToLowerInvariant();
                _logger.LogInformation("[{Username}] Joining channel: #{ChannelName}", wrapper.Username, channel);
                wrapper.ClientInstance.JoinChannel(channel);
            }
            else
            {
                _logger.LogWarning(
                    "[{Username}] Cannot join channel #{ChannelName}, client not connected (Status: {ConnectionStatus}).",
                    wrapper.Username,
                    channelName,
                    wrapper.Status
                );
            }
        }
        else
        {
            _logger.LogWarning("[{AccountId}] Cannot join channel #{ChannelName}, client wrapper not found.", accountId, channelName);
        }
        return Task.CompletedTask;
    }
    public Task LeaveChannelAsync(string accountId, string channelName)
    {
        if (_activeClients.TryGetValue(accountId, out TwitchClientWrapper? wrapper))
        {
            if (wrapper.Status == ConnectionStatus.Connected)
            {
                string channel = channelName.ToLowerInvariant();
                _logger.LogInformation("[{Username}] Leaving channel: #{ChannelName}", wrapper.Username, channel);
                wrapper.ClientInstance.LeaveChannel(channel);
            }
            else
            {
                _logger.LogWarning(
                    "[{Username}] Cannot leave channel #{ChannelName}, client not connected (Status: {ConnectionStatus}).",
                    wrapper.Username,
                    channelName,
                    wrapper.Status
                );
            }
        }
        else
        {
            _logger.LogWarning("[{AccountId}] Cannot leave channel #{ChannelName}, client wrapper not found.", accountId, channelName);
        }
        return Task.CompletedTask;
    }
    public Task SendMessageAsync(string accountId, string channelName, string message)
    {
        if (string.IsNullOrWhiteSpace(message))
        {
            _logger.LogWarning("[{AccountId}] Cannot send empty or whitespace message to channel #{ChannelName}.", accountId, channelName);
            return Task.CompletedTask;
        }
        if (_activeClients.TryGetValue(accountId, out TwitchClientWrapper? wrapper))
        {
            if (wrapper.Status == ConnectionStatus.Connected)
            {
                string channel = channelName.ToLowerInvariant();
                if (wrapper.ClientInstance.JoinedChannels.Any(jc => jc.Channel.Equals(channel, StringComparison.OrdinalIgnoreCase)))
                {
                    _logger.LogDebug("[{Username}] Sending to #{ChannelName}: {Message}", wrapper.Username, channel, message);
                    wrapper.ClientInstance.SendMessage(channel, message);
                    var localEchoEvent = new ChatMessageEvent
                    {
                        Platform = "Twitch",
                        Timestamp = DateTime.UtcNow,
                        OriginatingAccountId = accountId,
                        UserId = wrapper.AccountId,
                        Username = wrapper.Username,
                        RawMessage = message,
                        ParsedMessage = [new TextSegment { Text = message }],
                        IsActionMessage = message.StartsWith("/me ", StringComparison.OrdinalIgnoreCase),
                        Badges = [],
                    };
                    _messenger.Send(new NewEventMessage(localEchoEvent));
                    _ = _pluginService.RouteEventToProcessorsAsync(localEchoEvent);
                }
                else
                {
                    _logger.LogWarning(
                        "[{Username}] Cannot send message to #{ChannelName}, client is not joined to that channel.",
                        wrapper.Username,
                        channel
                    );
                }
            }
            else
            {
                _logger.LogWarning(
                    "[{Username}] Cannot send message to #{ChannelName}, client not connected (Status: {ConnectionStatus}).",
                    wrapper.Username,
                    channelName,
                    wrapper.Status
                );
            }
        }
        else
        {
            _logger.LogWarning("[{AccountId}] Cannot send message to #{ChannelName}, client wrapper not found.", accountId, channelName);
        }
        return Task.CompletedTask;
    }
    public ConnectionStatus GetStatus(string accountId) => _activeClients.TryGetValue(accountId, out TwitchClientWrapper? wrapper) ? wrapper.Status : ConnectionStatus.Disconnected;
    public string? GetStatusMessage(string accountId) => _activeClients.TryGetValue(accountId, out TwitchClientWrapper? wrapper) ? wrapper.StatusMessage : "Account not connected";
    private void UpdateWrapperStatus(string accountId, ConnectionStatus status, string? message = null)
    {
        if (_activeClients.TryGetValue(accountId, out TwitchClientWrapper? wrapper))
        {
            wrapper.Status = status;
            wrapper.StatusMessage = message ?? wrapper.StatusMessage;
            _logger.LogInformation(
                "[{Username}] Status updated: {ConnectionStatus} | Message: {StatusMessage}",
                wrapper.Username,
                status,
                wrapper.StatusMessage
            );
        }
        else
        {
            _logger.LogWarning("[{AccountId}] UpdateWrapperStatus called but wrapper not found (possibly already removed).", accountId);
        }
    }
    private void Client_OnConnected(string accountId, object? sender, OnConnectedArgs e)
    {
        if (_activeClients.TryGetValue(accountId, out TwitchClientWrapper? wrapper))
        {
            _logger.LogInformation("[{Username}] Connected successfully as {BotUsername}.", wrapper.Username, e.BotUsername);
            UpdateWrapperStatus(accountId, ConnectionStatus.Connected, $"Connected as {e.BotUsername}");
            SystemMessageEvent systemEvent = new()
            {
                Platform = "Twitch",
                OriginatingAccountId = accountId,
                Message = $"Connected Twitch account: {wrapper.Username}",
            };
            _ = _pluginService.RouteEventToProcessorsAsync(systemEvent);
            _messenger.Send(new NewEventMessage(systemEvent));
            _messenger.Send(new ConnectionsUpdatedMessage());
            if (!string.IsNullOrWhiteSpace(wrapper.Username))
            {
                _logger.LogDebug("[{Username}] Triggering initial data load and joining own channel.", wrapper.Username);
                _ = _emoteBadgeService.LoadChannelTwitchDataAsync(accountId, accountId);
                JoinChannelAsync(accountId, wrapper.Username);
            }
        }
        else
        {
            _logger.LogWarning("[{AccountId}] OnConnected event received for a non-existent client wrapper.", accountId);
        }
    }
    private void Client_OnDisconnected(string accountId, object? sender, OnDisconnectedEventArgs e)
    {
        if (_activeClients.TryGetValue(accountId, out TwitchClientWrapper? wrapper))
        {
            _logger.LogWarning("[{Username}] Disconnected event received.", wrapper.Username);
            if (wrapper.Status != ConnectionStatus.Disconnected)
            {
                UpdateWrapperStatus(accountId, ConnectionStatus.Disconnected, "Connection closed.");
            }
            SystemMessageEvent systemEvent = new()
            {
                Platform = "Twitch",
                OriginatingAccountId = accountId,
                Message = $"Twitch account {wrapper.Username} disconnected.",
                Level = SystemMessageLevel.Warning,
            };
            _ = _pluginService.RouteEventToProcessorsAsync(systemEvent);
            _messenger.Send(new NewEventMessage(systemEvent));
            _messenger.Send(new ConnectionsUpdatedMessage());
        }
        else
        {
            _logger.LogDebug("[{AccountId}] OnDisconnected event received for a non-existent/removed wrapper.", accountId);
        }
    }
    private void Client_OnConnectionError(string accountId, object? sender, OnConnectionErrorArgs e)
    {
        if (_activeClients.TryGetValue(accountId, out TwitchClientWrapper? wrapper))
        {
            _logger.LogError("[{Username}] Connection Error: {ErrorMessage}", wrapper.Username, e.Error.Message);
            UpdateWrapperStatus(accountId, ConnectionStatus.Error, $"Connection Error: {e.Error.Message}");
            SystemMessageEvent systemEvent = new()
            {
                Platform = "Twitch",
                OriginatingAccountId = accountId,
                Message = $"Twitch connection error ({wrapper.Username}): {e.Error.Message}",
                Level = SystemMessageLevel.Error,
            };
            _ = _pluginService.RouteEventToProcessorsAsync(systemEvent);
            _messenger.Send(new NewEventMessage(systemEvent));
            _messenger.Send(new ConnectionsUpdatedMessage());
        }
        else
        {
            _logger.LogWarning("[{AccountId}] OnConnectionError event received for a non-existent client wrapper.", accountId);
        }
    }
    private void Client_OnError(string accountId, object? sender, OnErrorEventArgs e)
    {
        if (_activeClients.TryGetValue(accountId, out TwitchClientWrapper? wrapper))
        {
            _logger.LogError(e.Exception, "[{Username}] Communication Error: {ErrorMessage}", wrapper.Username, e.Exception.Message);
            SystemMessageEvent systemEvent = new()
            {
                Platform = "Twitch",
                OriginatingAccountId = accountId,
                Message = $"Twitch communication error ({wrapper.Username}): {e.Exception.Message}",
                Level = SystemMessageLevel.Error,
            };
            _ = _pluginService.RouteEventToProcessorsAsync(systemEvent);
            _messenger.Send(new NewEventMessage(systemEvent));
        }
        else
        {
            _logger.LogWarning("[{AccountId}] OnError event received for a non-existent client wrapper.", accountId);
        }
    }
    private void Client_OnJoinedChannel(string accountId, object? sender, OnJoinedChannelArgs e)
    {
        if (_activeClients.TryGetValue(accountId, out TwitchClientWrapper? wrapper))
        {
            _logger.LogInformation("[{Username}] Joined channel: #{ChannelName}", wrapper.Username, e.Channel);
            string channelIdToLoad = accountId;
            bool isOwnChannel = e.Channel.Equals(wrapper.Username, StringComparison.OrdinalIgnoreCase);
            if (!isOwnChannel)
            {
                _logger.LogWarning(
                    "[{Username}] Joined external channel #{ChannelName}. Channel-specific data loading may require Channel ID lookup implementation.",
                    wrapper.Username,
                    e.Channel
                );
            }
            _logger.LogDebug(
                "[{Username}] Triggering data load for channel #{ChannelName} (Channel ID: {ChannelId}, Context Account ID: {ContextAccountId})",
                wrapper.Username,
                e.Channel,
                channelIdToLoad,
                accountId
            );
            _ = _emoteBadgeService.LoadChannelTwitchDataAsync(channelIdToLoad, accountId);
            SystemMessageEvent systemEvent = new()
            {
                Platform = "Twitch",
                OriginatingAccountId = accountId,
                Message = $"Joined channel: #{e.Channel} (as {wrapper.Username})",
            };
            _ = _pluginService.RouteEventToProcessorsAsync(systemEvent);
            _messenger.Send(new NewEventMessage(systemEvent));
        }
        else
        {
            _logger.LogWarning("[{AccountId}] OnJoinedChannel event received for non-existent wrapper. Channel: {ChannelName}", accountId, e.Channel);
        }
    }
    private async Task Client_OnMessageReceived(string accountId, object? sender, OnMessageReceivedArgs e)
    {
        if (!_activeClients.ContainsKey(accountId))
        {
            _logger.LogDebug("[{AccountId}] OnMessageReceived skipped: Wrapper no longer active.", accountId);
            return;
        }
        _logger.LogTrace(
            "[{Username}] Received message in #{Channel}: {Message}",
            e.ChatMessage.DisplayName,
            e.ChatMessage.Channel,
            e.ChatMessage.Message
        );
        var baseDetails = new
        {
            Platform = "Twitch",
            Timestamp = DateTime.TryParse(e.ChatMessage.TmiSentTs, out DateTime tmiTime) ? tmiTime.ToUniversalTime() : DateTime.UtcNow,
            OriginatingAccountId = accountId,
        };
        string rawMessage = e.ChatMessage.Message;
        List<MessageSegment> parsedSegments = [];
        if (e.ChatMessage.EmoteSet?.Emotes != null && e.ChatMessage.EmoteSet.Emotes.Count > 0)
        {
            try
            {
                var sortedEmotes = e.ChatMessage.EmoteSet.Emotes.OrderBy(em => em.StartIndex).ToList();
                int currentPosition = 0;
                foreach (Emote? emote in sortedEmotes)
                {
                    if (emote.StartIndex > currentPosition)
                    {
                        parsedSegments.Add(new TextSegment { Text = rawMessage[currentPosition..emote.StartIndex] });
                    }
                    parsedSegments.Add(
                        new EmoteSegment
                        {
                            Id = emote.Id,
                            Name = emote.Name,
                            ImageUrl = emote.ImageUrl,
                            Platform = "Twitch",
                        }
                    );
                    currentPosition = emote.EndIndex + 1;
                }
                if (currentPosition < rawMessage.Length)
                {
                    parsedSegments.Add(new TextSegment { Text = rawMessage[currentPosition..] });
                }
                _logger.LogTrace("[{Username}] Parsed {EmoteCount} emotes for message.", e.ChatMessage.DisplayName, sortedEmotes.Count);
            }
            catch (Exception ex)
            {
                _logger.LogError(
                    ex,
                    "[{Username}] Error parsing emotes for message in #{Channel}. Raw Message: {RawMessage}",
                    e.ChatMessage.DisplayName,
                    e.ChatMessage.Channel,
                    rawMessage
                );
                parsedSegments = [new TextSegment { Text = rawMessage }];
            }
        }
        else
        {
            if (!string.IsNullOrEmpty(rawMessage))
            {
                parsedSegments.Add(new TextSegment { Text = rawMessage });
            }
        }
        List<BadgeInfo> badgeInfoList = [];
        bool isOwner = false;
        if (e.ChatMessage.Badges != null)
        {
            foreach (KeyValuePair<string, string> badge in e.ChatMessage.Badges)
            {
                badgeInfoList.Add(new BadgeInfo($"twitch/{badge.Key}/{badge.Value}", null));
                if (badge.Key.Equals("broadcaster", StringComparison.OrdinalIgnoreCase))
                {
                    isOwner = true;
                }
            }
        }
        string? usernameColor = CalculateTwitchUsernameColor(badgeInfoList) ?? e.ChatMessage.ColorHex;
        if (e.ChatMessage.Bits > 0)
        {
            var bitsEvent = new DonationEvent
            {
                Platform = baseDetails.Platform,
                Timestamp = baseDetails.Timestamp,
                OriginatingAccountId = baseDetails.OriginatingAccountId,
                DonationId = e.ChatMessage.Id,
                UserId = e.ChatMessage.UserId,
                Username = e.ChatMessage.DisplayName,
                Amount = e.ChatMessage.Bits,
                Currency = "Bits",
                RawMessage = rawMessage,
                ParsedMessage = parsedSegments,
                Type = DonationType.Bits,
                Badges = badgeInfoList,
                UsernameColor = usernameColor,
                ProfileImageUrl = null,
                IsOwner = isOwner,
            };
            _logger.LogInformation(
                "[{Username}] Processed bits donation: {BitsAmount} bits from {DonatorUsername}",
                e.ChatMessage.DisplayName,
                bitsEvent.Amount,
                bitsEvent.Username
            );
            _ = _pluginService.RouteEventToProcessorsAsync(bitsEvent);
            _messenger.Send(new NewEventMessage(bitsEvent));
            return;
        }
        var chatEvent = new ChatMessageEvent
        {
            Platform = baseDetails.Platform,
            Timestamp = baseDetails.Timestamp,
            OriginatingAccountId = baseDetails.OriginatingAccountId,
            UserId = e.ChatMessage.UserId,
            Username = e.ChatMessage.DisplayName,
            RawMessage = rawMessage,
            ParsedMessage = parsedSegments,
            UsernameColor = usernameColor,
            Badges = badgeInfoList,
            IsHighlight = e.ChatMessage.IsHighlighted,
            BitsDonated = e.ChatMessage.Bits,
            ProfileImageUrl = null,
            IsOwner = isOwner,
        };
        bool supressMessage = await _pluginService.TryHandleChatCommandAsync(chatEvent);
        if (!supressMessage)
        {
            _logger.LogTrace("[{AccountId}] Chat message not suppressed as command. Processing normally.", accountId);
            _ = _pluginService.RouteEventToProcessorsAsync(chatEvent);
            _messenger.Send(new NewEventMessage(chatEvent));
        }
        else
        {
            _logger.LogDebug(
                "[{AccountId}] Chat message in #{Channel} handled and suppressed by command processor.",
                accountId,
                chatEvent.OriginatingAccountId
            );
        }
    }
    private void Client_OnNewSubscriber(string accountId, object? sender, OnNewSubscriberArgs e)
    {
        if (!_activeClients.ContainsKey(accountId))
            return;
        _logger.LogInformation(
            "[{AccountId}] Subscription Event [#{Channel}] User: {Username}, Plan: {Plan}",
            accountId,
            e.Channel,
            e.Subscriber.DisplayName,
            e.Subscriber.SubscriptionPlan.ToString()
        );
        List<BadgeInfo> badgeInfoList = e.Subscriber.Badges?.Select(b => new BadgeInfo($"twitch/{b.Key}/{b.Value}", null)).ToList() ?? [];
        bool isOwner = badgeInfoList.Any(b => b.Identifier.StartsWith("twitch/broadcaster/"));
        string? usernameColor = CalculateTwitchUsernameColor(badgeInfoList) ?? e.Subscriber.ColorHex;
        var subEvent = new SubscriptionEvent
        {
            Platform = "Twitch",
            OriginatingAccountId = accountId,
            Timestamp = DateTime.UtcNow,
            UserId = e.Subscriber.UserId,
            Username = e.Subscriber.DisplayName,
            IsGift = false,
            Months = 1,
            CumulativeMonths = int.TryParse(e.Subscriber.MsgParamCumulativeMonths, out int cm) ? cm : (e.Subscriber.MsgId == "resub" ? 1 : 0),
            Tier = MapTwitchSubPlan(e.Subscriber.SubscriptionPlan),
            Message = e.Subscriber.ResubMessage,
            Badges = badgeInfoList,
            UsernameColor = usernameColor,
            ProfileImageUrl = null,
            IsOwner = isOwner,
        };
        _ = _pluginService.RouteEventToProcessorsAsync(subEvent);
        _messenger.Send(new NewEventMessage(subEvent));
    }
    private void Client_OnGiftedSubscription(string accountId, object? sender, OnGiftedSubscriptionArgs e)
    {
        if (!_activeClients.ContainsKey(accountId))
            return;
        _logger.LogInformation(
            "[{AccountId}] Gift Subscription Event [#{Channel}] Gifter: {GifterUsername} -> Recipient: {RecipientUsername}, Months: {Months}, Plan: {Plan}",
            accountId,
            e.Channel,
            e.GiftedSubscription.DisplayName,
            e.GiftedSubscription.MsgParamRecipientDisplayName,
            e.GiftedSubscription.MsgParamMultiMonthGiftDuration ?? "1",
            e.GiftedSubscription.MsgParamSubPlan.ToString()
        );
        List<BadgeInfo> badgeInfoList = e.GiftedSubscription.Badges?.Select(b => new BadgeInfo($"twitch/{b.Key}/{b.Value}", null)).ToList() ?? [];
        bool isOwner = badgeInfoList.Any(b => b.Identifier.StartsWith("twitch/broadcaster/"));
        string? usernameColor = CalculateTwitchUsernameColor(badgeInfoList) ?? e.GiftedSubscription.Color;
        var giftEvent = new SubscriptionEvent
        {
            Platform = "Twitch",
            OriginatingAccountId = accountId,
            Timestamp = DateTime.UtcNow,
            UserId = e.GiftedSubscription.UserId,
            Username = e.GiftedSubscription.DisplayName,
            RecipientUsername = e.GiftedSubscription.MsgParamRecipientDisplayName,
            RecipientUserId = e.GiftedSubscription.MsgParamRecipientId,
            IsGift = true,
            Months = int.TryParse(e.GiftedSubscription.MsgParamMultiMonthGiftDuration, out int dur) ? dur : 1,
            Tier = MapTwitchSubPlan(e.GiftedSubscription.MsgParamSubPlan),
            Badges = badgeInfoList,
            UsernameColor = usernameColor,
            ProfileImageUrl = null,
            IsOwner = isOwner,
        };
        _ = _pluginService.RouteEventToProcessorsAsync(giftEvent);
        _messenger.Send(new NewEventMessage(giftEvent));
    }
    private void Client_OnRaidNotification(string accountId, object? sender, OnRaidNotificationArgs e)
    {
        if (!_activeClients.ContainsKey(accountId))
            return;
        _logger.LogInformation(
            "[{AccountId}] Raid Notification [#{Channel}] Raider: {RaiderUsername}, Viewers: {ViewerCount}",
            accountId,
            e.Channel,
            e.RaidNotification.DisplayName,
            e.RaidNotification.MsgParamViewerCount ?? "0"
        );
        var raidEvent = new RaidEvent
        {
            Platform = "Twitch",
            OriginatingAccountId = accountId,
            Timestamp = DateTime.UtcNow,
            RaiderUsername = e.RaidNotification.DisplayName,
            RaiderUserId = e.RaidNotification.UserId,
            ViewerCount = int.TryParse(e.RaidNotification.MsgParamViewerCount, out int count) ? count : 0,
        };
        _ = _pluginService.RouteEventToProcessorsAsync(raidEvent);
        _messenger.Send(new NewEventMessage(raidEvent));
    }
    private static string MapTwitchSubPlan(SubscriptionPlan plan) =>
        plan switch
        {
            SubscriptionPlan.Prime => "Twitch Prime",
            SubscriptionPlan.Tier1 => "Tier 1",
            SubscriptionPlan.Tier2 => "Tier 2",
            SubscriptionPlan.Tier3 => "Tier 3",
            SubscriptionPlan.NotSet => "Tier 1",
            _ => "Unknown Tier",
        };
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    protected virtual void Dispose(bool disposing)
    {
        if (_isDisposed)
            return;
        _logger.LogDebug("Dispose({Disposing}) called.", disposing);
        if (disposing)
        {
            _logger.LogInformation("Disposing TwitchChatService...");
            var accountIds = _activeClients.Keys.ToList();
            var disconnectTasks = new List<Task>();
            _logger.LogDebug("Initiating disconnection for {ClientCount} active clients...", accountIds.Count);
            foreach (string accountId in accountIds)
            {
                disconnectTasks.Add(DisconnectAsync(accountId));
            }
            try
            {
                if (!Task.WhenAll(disconnectTasks).Wait(TimeSpan.FromSeconds(5)))
                {
                    _logger.LogWarning("Timeout occurred while waiting for disconnect tasks during dispose.");
                }
                _logger.LogDebug("Finished waiting for disconnect tasks.");
            }
            catch (AggregateException agEx) when (agEx.InnerExceptions.All(ex => ex is TaskCanceledException))
            {
                _logger.LogWarning("One or more disconnect tasks timed out or were cancelled during dispose.");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error occurred while waiting for disconnect tasks during dispose: {ErrorMessage}", ex.Message);
            }
            _activeClients.Clear();
            _logger.LogInformation("TwitchChatService Dispose finished.");
        }
        _isDisposed = true;
    }
}
</file>

<file path="Core/Services/Settings/SettingsService.cs">
using System;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Models.Settings;
namespace StreamWeaver.Core.Services.Settings;
public class SettingsService : ISettingsService
{
    private readonly string _settingsFilePath;
    private AppSettings _currentSettingsInstance;
    private string? _lastSavedSettingsJson;
    private readonly ILogger<SettingsService> _logger;
    private readonly IConfigurationRoot _configurationRoot;
    private static readonly JsonSerializerOptions s_jsonSerializerOptions = new()
    {
        WriteIndented = true,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
    };
    private static readonly SemaphoreSlim s_fileLock = new(1, 1);
    public event EventHandler? SettingsUpdated;
    public AppSettings CurrentSettings => _currentSettingsInstance;
    public SettingsService(ILogger<SettingsService> logger, IConfigurationRoot configurationRoot)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _configurationRoot = configurationRoot ?? throw new ArgumentNullException(nameof(configurationRoot));
        string appDataFolder = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        string appFolder = Path.Combine(appDataFolder, "StreamWeaver");
        _settingsFilePath = Path.Combine(appFolder, "user_settings.json");
        _logger.LogInformation("SettingsService initialized. User settings file path: {SettingsFilePath}", _settingsFilePath);
        try
        {
            Directory.CreateDirectory(appFolder);
        }
        catch (Exception ex)
        {
            _logger.LogCritical(ex, "Failed to create settings directory: {DirectoryPath}", appFolder);
        }
        _currentSettingsInstance = LoadSettingsInternal();
    }
    private AppSettings LoadSettingsInternal()
    {
        _logger.LogDebug("Acquiring lock for loading settings from {FilePath}...", _settingsFilePath);
        s_fileLock.Wait();
        _logger.LogTrace("Lock acquired for loading settings.");
        try
        {
            AppSettings loadedSettings;
            if (!File.Exists(_settingsFilePath))
            {
                _logger.LogInformation("User settings file not found at {SettingsFilePath}. Creating default settings.", _settingsFilePath);
                loadedSettings = new AppSettings();
                _lastSavedSettingsJson = JsonSerializer.Serialize(loadedSettings, s_jsonSerializerOptions);
                try
                {
                    File.WriteAllText(_settingsFilePath, _lastSavedSettingsJson);
                    _logger.LogInformation("Saved default user settings to file.");
                }
                catch (Exception writeEx)
                {
                    _logger.LogError(writeEx, "Failed to write initial default user settings file.");
                }
            }
            else
            {
                _logger.LogInformation("Loading user settings from {SettingsFilePath}...", _settingsFilePath);
                string json = File.ReadAllText(_settingsFilePath);
                try
                {
                    loadedSettings = JsonSerializer.Deserialize<AppSettings>(json, s_jsonSerializerOptions) ?? new AppSettings();
                    _lastSavedSettingsJson = json;
                    _logger.LogInformation("User settings deserialized successfully.");
                }
                catch (JsonException jsonEx)
                {
                    _logger.LogError(
                        jsonEx,
                        "Error deserializing user settings JSON from {SettingsFilePath}. Backing up old file and using default settings.",
                        _settingsFilePath
                    );
                    BackupCorruptedSettings(json);
                    loadedSettings = new AppSettings();
                    _lastSavedSettingsJson = JsonSerializer.Serialize(loadedSettings, s_jsonSerializerOptions);
                }
            }
            return loadedSettings;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Critical error loading user settings. Returning default settings.");
            var defaultSettings = new AppSettings();
            _lastSavedSettingsJson = JsonSerializer.Serialize(defaultSettings, s_jsonSerializerOptions);
            return defaultSettings;
        }
        finally
        {
            s_fileLock.Release();
            _logger.LogTrace("Lock released after loading settings.");
        }
    }
    public Task<AppSettings> LoadSettingsAsync()
    {
        _logger.LogDebug("LoadSettingsAsync called, returning current instance.");
        return Task.FromResult(CurrentSettings);
    }
    public async Task SaveSettingsAsync(AppSettings settings)
    {
        ArgumentNullException.ThrowIfNull(settings);
        if (!ReferenceEquals(settings, _currentSettingsInstance))
        {
            _logger.LogDebug("SaveSettingsAsync called with a different AppSettings instance. Updating internal _currentSettingsInstance to match.");
            _currentSettingsInstance = settings;
        }
        string currentSettingsJson;
        try
        {
            currentSettingsJson = JsonSerializer.Serialize(_currentSettingsInstance, s_jsonSerializerOptions);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to serialize settings for saving. Aborting save.");
            return;
        }
        if (string.Equals(currentSettingsJson, _lastSavedSettingsJson, StringComparison.Ordinal))
        {
            _logger.LogInformation("SaveSettingsAsync skipped: No changes detected since last save/load.");
            return;
        }
        _logger.LogDebug("Changes detected. Acquiring lock for saving user settings to {FilePath}...", _settingsFilePath);
        await s_fileLock.WaitAsync();
        _logger.LogTrace("Lock acquired for saving user settings.");
        try
        {
            _logger.LogInformation("Saving user settings changes to {SettingsFilePath}...", _settingsFilePath);
            await File.WriteAllTextAsync(_settingsFilePath, currentSettingsJson);
            _lastSavedSettingsJson = currentSettingsJson;
            _logger.LogInformation("User settings saved successfully.");
            _logger.LogDebug("Reloading IConfigurationRoot to apply changes and trigger IOptionsMonitor updates...");
            _configurationRoot.Reload();
            _logger.LogInformation("IConfigurationRoot reloaded.");
            OnSettingsUpdated();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error saving user settings to {SettingsFilePath}", _settingsFilePath);
        }
        finally
        {
            s_fileLock.Release();
            _logger.LogTrace("Lock released after saving user settings.");
        }
    }
    private void BackupCorruptedSettings(string corruptedJson)
    {
        try
        {
            string backupFileName = $"user_settings.corrupted.{DateTime.Now:yyyyMMddHHmmss}.json";
            string backupFilePath = Path.Combine(Path.GetDirectoryName(_settingsFilePath)!, backupFileName);
            File.WriteAllText(backupFilePath, corruptedJson);
            _logger.LogInformation("Backed up corrupted user settings file to: {BackupFilePath}", backupFilePath);
        }
        catch (Exception backupEx)
        {
            _logger.LogError(backupEx, "Failed to back up corrupted user settings file.");
        }
    }
    protected virtual void OnSettingsUpdated()
    {
        SettingsUpdated?.Invoke(this, EventArgs.Empty);
        _logger.LogDebug("SettingsUpdated event invoked by SettingsService.");
    }
}
</file>

<file path="Core/Services/Tts/CompositeTtsService.cs">
using System.Collections.Concurrent;
using CommunityToolkit.Mvvm.Messaging;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Messaging;
using StreamWeaver.Core.Models.Events;
using StreamWeaver.Core.Models.Settings;
using StreamWeaver.Core.Services.Settings;
namespace StreamWeaver.Core.Services.Tts;
public sealed partial class CompositeTtsService : ITtsService, IRecipient<NewEventMessage>, IDisposable
{
    private readonly ILogger<CompositeTtsService> _logger;
    private readonly ISettingsService _settingsService;
    private readonly IMessenger _messenger;
    private readonly TtsFormattingService _formattingService;
    private readonly Dictionary<string, IEngineSpecificTtsService> _ttsEngines;
    private readonly ConcurrentQueue<string> _speechQueue = new();
    private readonly SemaphoreSlim _speakLock = new(1, 1);
    private Task? _processingTask;
    private CancellationTokenSource? _cts;
    private bool _isDisposed = false;
    public CompositeTtsService(
        ILogger<CompositeTtsService> logger,
        ISettingsService settingsService,
        IMessenger messenger,
        TtsFormattingService formattingService,
        IEnumerable<IEngineSpecificTtsService> ttsEngines
    )
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        _messenger = messenger ?? throw new ArgumentNullException(nameof(messenger));
        _formattingService = formattingService ?? throw new ArgumentNullException(nameof(formattingService));
        _ttsEngines = ttsEngines?.ToDictionary(e => e.EngineId, e => e)
                      ?? throw new ArgumentNullException(nameof(ttsEngines));
        _logger.LogInformation("CompositeTtsService Initialized with {EngineCount} engines.", _ttsEngines.Count);
        _ = InitializeEnginesAsync();
        _messenger.Register<NewEventMessage>(this);
        _settingsService.SettingsUpdated += OnSettingsUpdated;
        _cts = new CancellationTokenSource();
        _processingTask = ProcessSpeechQueueAsync(_cts.Token);
    }
    private async Task InitializeEnginesAsync()
    {
        _logger.LogInformation("Starting asynchronous initialization of TTS engines...");
        var initTasks = _ttsEngines.Values.Select(engine => engine.InitializeAsync()).ToList();
        try
        {
            await Task.WhenAll(initTasks);
            _logger.LogInformation("All TTS engines initialized.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during asynchronous initialization of one or more TTS engines.");
        }
    }
    private void OnSettingsUpdated(object? sender, EventArgs e) =>
        _logger.LogDebug("Settings updated event received by CompositeTtsService.");
    public async Task<IEnumerable<string>> GetInstalledWindowsVoicesAsync()
    {
        if (_ttsEngines.TryGetValue(TtsSettings.WindowsEngine, out IEngineSpecificTtsService? engine))
        {
            return await engine.GetInstalledVoicesAsync();
        }
        _logger.LogWarning("Windows TTS engine not found.");
        return [];
    }
    public async Task<IEnumerable<string>> GetInstalledKokoroVoicesAsync()
    {
        if (_ttsEngines.TryGetValue(TtsSettings.KokoroEngine, out IEngineSpecificTtsService? engine))
        {
            return await engine.GetInstalledVoicesAsync();
        }
        _logger.LogWarning("Kokoro TTS engine not found.");
        return [];
    }
    public void SetWindowsVoice(string voiceName)
    {
        if (_settingsService.CurrentSettings.TextToSpeech.SelectedEngine == TtsSettings.WindowsEngine)
        {
            if (_ttsEngines.TryGetValue(TtsSettings.WindowsEngine, out IEngineSpecificTtsService? engine))
            {
                engine.SetVoice(voiceName);
            }
        }
    }
    public void SetKokoroVoice(string voiceName)
    {
        if (_settingsService.CurrentSettings.TextToSpeech.SelectedEngine == TtsSettings.KokoroEngine)
        {
            if (_ttsEngines.TryGetValue(TtsSettings.KokoroEngine, out IEngineSpecificTtsService? engine))
            {
                engine.SetVoice(voiceName);
            }
        }
    }
    public void SetVolume(int volume)
    {
        string selectedEngineId = _settingsService.CurrentSettings.TextToSpeech.SelectedEngine;
        if (_ttsEngines.TryGetValue(selectedEngineId, out IEngineSpecificTtsService? engine))
        {
            engine.SetVolume(volume);
        }
    }
    public void SetRate(int rate)
    {
        string selectedEngineId = _settingsService.CurrentSettings.TextToSpeech.SelectedEngine;
        if (_ttsEngines.TryGetValue(selectedEngineId, out IEngineSpecificTtsService? engine))
        {
            engine.SetRate(rate);
        }
    }
    public Task SpeakAsync(string textToSpeak)
    {
        if (!_settingsService.CurrentSettings.TextToSpeech.Enabled)
        {
            _logger.LogTrace("SpeakAsync skipped: TTS is disabled.");
            return Task.CompletedTask;
        }
        if (string.IsNullOrWhiteSpace(textToSpeak))
        {
            _logger.LogTrace("SpeakAsync skipped: Text is null or whitespace.");
            return Task.CompletedTask;
        }
        if (string.IsNullOrWhiteSpace(textToSpeak))
        {
            _logger.LogDebug("SpeakAsync skipped: Text became empty after normalization. Original: '{Original}'", textToSpeak);
            return Task.CompletedTask;
        }
        _logger.LogDebug("Adding text to speech queue: \"{TextToSpeak}\"", textToSpeak);
        _speechQueue.Enqueue(textToSpeak);
        return Task.CompletedTask;
    }
    public void Receive(NewEventMessage message)
    {
        if (!_settingsService.CurrentSettings.TextToSpeech.Enabled)
        {
            _logger.LogTrace("Receive(NewEventMessage) skipped: TTS is disabled.");
            return;
        }
        string? textToSpeak = _formattingService.FormatAndNormalizeEvent(
            message.Value,
            _settingsService.CurrentSettings.TextToSpeech
        );
        if (!string.IsNullOrWhiteSpace(textToSpeak))
        {
            _speechQueue.Enqueue(textToSpeak);
            _logger.LogDebug("Enqueued formatted event text: \"{TextToSpeak}\"", textToSpeak);
        }
        else
        {
            _logger.LogTrace("Event type {EventType} resulted in empty text after formatting/normalization, not queued.", message.Value.GetType().Name);
        }
    }
    private async Task ProcessSpeechQueueAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Speech queue processing task started.");
        while (!cancellationToken.IsCancellationRequested)
        {
            if (_speechQueue.TryDequeue(out string? textToSpeak))
            {
                if (!_settingsService.CurrentSettings.TextToSpeech.Enabled)
                {
                    _logger.LogTrace("Skipping dequeued item as TTS is now disabled.");
                    continue;
                }
                await _speakLock.WaitAsync(cancellationToken);
                try
                {
                    if (cancellationToken.IsCancellationRequested) break;
                    string selectedEngineId = _settingsService.CurrentSettings.TextToSpeech.SelectedEngine;
                    if (_ttsEngines.TryGetValue(selectedEngineId, out IEngineSpecificTtsService? engine))
                    {
                        _logger.LogDebug("Processing queued speech item using engine '{EngineId}': \"{TextToSpeak}\"", selectedEngineId, textToSpeak);
                        TtsSettings currentSettings = _settingsService.CurrentSettings.TextToSpeech;
                        engine.SetRate(currentSettings.Rate);
                        engine.SetVolume(currentSettings.Volume);
                        string? voice = selectedEngineId == TtsSettings.WindowsEngine
                                        ? currentSettings.SelectedWindowsVoice
                                        : currentSettings.SelectedKokoroVoice;
                        if (!string.IsNullOrEmpty(voice))
                        {
                            engine.SetVoice(voice);
                        }
                        else
                        {
                            _logger.LogDebug("No specific voice selected for engine {EngineId}, using engine default.", selectedEngineId);
                        }
                        await engine.SpeakAsync(textToSpeak);
                        await Task.Delay(TimeSpan.FromMilliseconds(200), cancellationToken);
                    }
                    else
                    {
                        _logger.LogWarning("Cannot speak queued item: Selected engine '{EngineId}' not found.", selectedEngineId);
                    }
                }
                catch (OperationCanceledException)
                {
                    _logger.LogInformation("Speech queue processing cancelled while speaking.");
                    break;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error speaking item from queue: \"{TextToSpeak}\"", textToSpeak);
                }
                finally
                {
                    _speakLock.Release();
                }
            }
            else
            {
                await Task.Delay(TimeSpan.FromMilliseconds(100), cancellationToken);
            }
        }
        _logger.LogInformation("Speech queue processing task finished.");
    }
    private void ClearQueue()
    {
        _logger.LogInformation("Clearing speech queue...");
        while (_speechQueue.TryDequeue(out _)) { }
        _logger.LogInformation("Speech queue cleared.");
    }
    public void ProcessEventForTts(BaseEvent eventData) => Receive(new NewEventMessage(eventData));
    public void Dispose()
    {
        if (_isDisposed) return;
        _isDisposed = true;
        _logger.LogInformation("Disposing CompositeTtsService...");
        _messenger.UnregisterAll(this);
        _settingsService.SettingsUpdated -= OnSettingsUpdated;
        if (_cts != null)
        {
            _logger.LogDebug("Cancelling speech queue processing task...");
            _cts.Cancel();
            try
            {
                if (_processingTask != null && !_processingTask.Wait(TimeSpan.FromSeconds(3)))
                {
                    _logger.LogWarning("Speech queue processing task did not finish within the timeout period.");
                }
                else
                {
                    _logger.LogDebug("Speech queue processing task finished.");
                }
            }
            catch (AggregateException ae) when (ae.InnerExceptions.All(e => e is TaskCanceledException))
            {
                _logger.LogDebug("Speech queue processing task cancelled as expected.");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error waiting for speech queue task during dispose.");
            }
            _cts.Dispose();
            _cts = null;
            _processingTask = null;
        }
        _logger.LogDebug("Disposing engine-specific TTS services...");
        foreach (IEngineSpecificTtsService engine in _ttsEngines.Values)
        {
            try
            {
                engine.Dispose();
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Error disposing engine {EngineId}.", engine.EngineId);
            }
        }
        _ttsEngines.Clear();
        _speakLock.Dispose();
        _logger.LogInformation("CompositeTtsService disposed.");
        GC.SuppressFinalize(this);
    }
}
</file>

<file path="Core/Services/Tts/ITtsService.cs">
using StreamWeaver.Core.Models.Events;
namespace StreamWeaver.Core.Services.Tts;
public interface ITtsService
{
    Task SpeakAsync(string textToSpeak);
    Task<IEnumerable<string>> GetInstalledWindowsVoicesAsync();
    Task<IEnumerable<string>> GetInstalledKokoroVoicesAsync();
    void SetWindowsVoice(string voiceName);
    void SetKokoroVoice(string voiceName);
    void SetVolume(int volume);
    void SetRate(int rate);
    void ProcessEventForTts(BaseEvent eventData);
}
</file>

<file path="Core/Services/Tts/KokoroTtsService.cs">
using System.Collections.Concurrent;
using KokoroSharp;
using KokoroSharp.Core;
using KokoroSharp.Processing;
using Microsoft.Extensions.Logging;
using Microsoft.ML.OnnxRuntime;
using StreamWeaver.Core.Models.Settings;
using StreamWeaver.Core.Services.Settings;
namespace StreamWeaver.Core.Services.Tts;
public sealed partial class KokoroTtsService(
    ISettingsService settingsService,
    ILogger<KokoroTtsService> logger
    ) : IEngineSpecificTtsService
{
    private readonly ILogger<KokoroTtsService> _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    private readonly ISettingsService _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
    private KokoroEngine? _engine;
    private KokoroPlayback? _playback;
    private bool _isDisposed = false;
    private string? _selectedVoiceName;
    private static readonly KokoroTTSPipelineConfig s_defaultPipelineConfig = new();
    private static Dictionary<KModel, string> ModelNamesMap { get; } = new Dictionary<KModel, string>
    {
        {
            KModel.float32,
            "kokoro.onnx"
        },
        {
            KModel.float16,
            "kokoro-quant.onnx"
        },
        {
            KModel.int8,
            "kokoro-quant-convinteger.onnx"
        }
    };
    public string EngineId => TtsSettings.KokoroEngine;
    public async Task InitializeAsync()
    {
        if (_engine != null && _playback != null)
        {
            _logger.LogInformation("Kokoro TTS Engine and Playback already initialized.");
            return;
        }
        _logger.LogInformation("Initializing Kokoro TTS Engine and Playback...");
        try
        {
            string modelFileName = ModelNamesMap[KModel.float16];
            if (!KokoroTTS.IsDownloaded(KModel.float16))
            {
                _logger.LogInformation("Kokoro model '{ModelName}' not found. Attempting download...", modelFileName);
                await KokoroTTS.LoadModelAsync(KModel.float16, progress =>
                {
                });
                if (!KokoroTTS.IsDownloaded(KModel.float16))
                {
                    throw new FileNotFoundException($"Failed to download or locate Kokoro model: {modelFileName}");
                }
                _logger.LogInformation("Kokoro model '{ModelName}' downloaded.", modelFileName);
            }
            _logger.LogDebug("Creating KokoroEngine instance with model: {ModelName}", modelFileName);
            _engine = new KokoroEngine(modelFileName);
            _logger.LogInformation("KokoroEngine initialized successfully.");
            _logger.LogDebug("Creating KokoroPlayback instance...");
            _playback = new KokoroPlayback
            {
                NicifySamples = true
            };
            _logger.LogInformation("KokoroPlayback initialized.");
            try
            {
                _logger.LogDebug("Loading Kokoro voices from default path...");
                KokoroVoiceManager.LoadVoicesFromPath();
                _logger.LogInformation("Kokoro voices loaded. Count: {VoiceCount}", KokoroVoiceManager.Voices.Count);
            }
            catch (DirectoryNotFoundException)
            {
                _logger.LogError("Kokoro voices directory not found at the default path ('voices'). Ensure voices are deployed correctly.");
            }
            catch (Exception voiceEx)
            {
                _logger.LogError(voiceEx, "Error loading Kokoro voices.");
            }
        }
        catch (Exception ex)
        {
            _logger.LogCritical(ex, "Failed to initialize Kokoro TTS Engine/Playback. Kokoro TTS will be unavailable.");
            _engine?.Dispose();
            _playback?.Dispose();
            _engine = null;
            _playback = null;
        }
    }
    public Task<IEnumerable<string>> GetInstalledVoicesAsync()
    {
        if (_engine == null)
        {
            _logger.LogWarning("Cannot get Kokoro voices: Engine not initialized.");
            return Task.FromResult(Enumerable.Empty<string>());
        }
        try
        {
            var voiceNames = KokoroVoiceManager.Voices.Select(v => v.Name).ToList();
            if (voiceNames.Count == 0)
            {
                _logger.LogWarning("GetInstalledVoicesAsync called, but KokoroVoiceManager.Voices is empty. Voices might not have loaded correctly.");
            }
            else
            {
                _logger.LogDebug("Returning {VoiceCount} installed Kokoro voices.", voiceNames.Count);
            }
            return Task.FromResult(voiceNames.AsEnumerable());
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving Kokoro voices from KokoroVoiceManager.");
            return Task.FromResult(Enumerable.Empty<string>());
        }
    }
    public void SetVoice(string voiceName)
    {
        if (_engine == null)
        {
            _logger.LogWarning("SetVoice skipped: Kokoro engine not available.");
            return;
        }
        if (string.IsNullOrWhiteSpace(voiceName))
        {
            _logger.LogWarning("SetVoice called with null or empty voice name.");
            return;
        }
        if (KokoroVoiceManager.Voices.Any(v => v.Name.Equals(voiceName, StringComparison.OrdinalIgnoreCase)))
        {
            _selectedVoiceName = voiceName;
            _logger.LogInformation("Kokoro voice '{VoiceName}' selected for next SpeakAsync call.", voiceName);
        }
        else
        {
            _logger.LogWarning("Kokoro voice '{VoiceName}' not found in loaded voices. Selection ignored.", voiceName);
            if (_selectedVoiceName != null && _selectedVoiceName.Equals(voiceName, StringComparison.OrdinalIgnoreCase))
            {
                _selectedVoiceName = null;
            }
        }
    }
    public void SetRate(int rate)
    {
        if (_engine == null) return;
        _logger.LogTrace("SetRate called ({Rate}), but speed is applied during SpeakAsync for Kokoro.", rate);
    }
    public void SetVolume(int volume)
    {
        if (_playback == null)
        {
            _logger.LogWarning("SetVolume skipped: Kokoro playback instance not available.");
            return;
        }
        try
        {
            int clampedVolumeInt = Math.Clamp(volume, 0, 100);
            float floatVolume = clampedVolumeInt / 100.0f;
            _playback.SetVolume(floatVolume);
            _logger.LogDebug("Kokoro Playback Volume set to: {VolumePercent}% ({FloatVolume})", clampedVolumeInt, floatVolume);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error setting Kokoro playback volume to {Volume}.", volume);
        }
    }
    public Task SpeakAsync(string textToSpeak)
    {
        if (_isDisposed)
        {
            _logger.LogWarning("SpeakAsync called after disposal.");
            return Task.CompletedTask;
        }
        if (_engine == null || _playback == null)
        {
            _logger.LogError("SpeakAsync failed: Kokoro engine or playback is not initialized.");
            return Task.CompletedTask;
        }
        if (string.IsNullOrWhiteSpace(textToSpeak))
        {
            _logger.LogTrace("SpeakAsync called with empty text, skipping.");
            return Task.CompletedTask;
        }
        if (string.IsNullOrWhiteSpace(_selectedVoiceName))
        {
            _logger.LogWarning("SpeakAsync called but no Kokoro voice selected. Attempting fallback...");
            _selectedVoiceName = KokoroVoiceManager.Voices.FirstOrDefault()?.Name;
            if (string.IsNullOrWhiteSpace(_selectedVoiceName))
            {
                _logger.LogError("SpeakAsync failed: No Kokoro voices available to select as default.");
                return Task.CompletedTask;
            }
            _logger.LogInformation("Using fallback voice: {FallbackVoice}", _selectedVoiceName);
        }
        KokoroVoice? selectedVoice = KokoroVoiceManager.GetVoice(_selectedVoiceName);
        if (selectedVoice == null)
        {
            _logger.LogError("SpeakAsync failed: Selected voice '{VoiceName}' not found in loaded voices.", _selectedVoiceName);
            return Task.CompletedTask;
        }
        int rate = _settingsService.CurrentSettings.TextToSpeech.Rate;
        float baseSpeed = 1.0f;
        float speedMultiplier = 0.05f;
        float calculatedSpeed = baseSpeed + (rate * speedMultiplier);
        float clampedSpeed = Math.Clamp(calculatedSpeed, 0.5f, 2.0f);
        _logger.LogInformation(
            "Queueing speech (Kokoro) - Voice: '{VoiceName}', Speed: {Speed}: \"{Text}\"",
             _selectedVoiceName, clampedSpeed, textToSpeak);
        try
        {
            int[] tokens = Tokenizer.Tokenize(textToSpeak.Trim(), selectedVoice.GetLangCode());
            List<int[]> segments = s_defaultPipelineConfig.SegmentationFunc(tokens);
            _logger.LogDebug("Segmented text into {SegmentCount} parts.", segments.Count);
            KokoroJob job = KokoroJob.Create(segments, selectedVoice, clampedSpeed, null);
            foreach (KokoroJob.KokoroJobStep? step in job.Steps)
            {
                step.OnStepComplete = (samples) =>
                {
                    if (_playback != null && !_isDisposed)
                    {
                        _logger.LogTrace("Step completed, queueing {SampleCount} samples to playback.", samples.Length);
                        _playback.Enqueue(samples);
                        bool endsWithPunctuation = Tokenizer.PunctuationTokens.Contains(step.Tokens[^1]);
                        if (endsWithPunctuation && _playback.NicifySamples)
                        {
                            char endingChar = Tokenizer.TokenToChar[step.Tokens[^1]];
                            float pauseSeconds = s_defaultPipelineConfig.SecondsOfPauseBetweenProperSegments[endingChar];
                            if (pauseSeconds > 0)
                            {
                                int pauseSamples = (int)(pauseSeconds * KokoroPlayback.waveFormat.SampleRate);
                                _logger.LogTrace("Adding {PauseSeconds}s pause ({PauseSamples} samples) after segment ending with '{EndingChar}'.", pauseSeconds, pauseSamples, endingChar);
                                _playback.Enqueue(new float[pauseSamples]);
                            }
                        }
                    }
                    else
                    {
                        _logger.LogWarning("Step completed, but playback instance is null or service disposed. Samples discarded.");
                    }
                };
            }
            _engine.EnqueueJob(job);
            _logger.LogDebug("Kokoro job enqueued for processing.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during Kokoro SpeakAsync preparation/enqueue for voice '{VoiceName}'.", _selectedVoiceName);
        }
        return Task.CompletedTask;
    }
    private void Dispose(bool disposing)
    {
        if (!_isDisposed)
        {
            if (disposing)
            {
                _logger.LogInformation("Disposing Kokoro TTS Engine Service...");
                _playback?.Dispose();
                _engine?.Dispose();
                _playback = null;
                _engine = null;
                _logger.LogInformation("Kokoro TTS Engine Service disposed.");
            }
            _isDisposed = true;
        }
    }
    public void Dispose()
    {
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }
}
</file>

<file path="Core/Services/UnifiedEventService.cs">
using System.Collections.Concurrent;
using System.Collections.Specialized;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Messaging;
using Microsoft.Extensions.Logging;
using Microsoft.UI.Dispatching;
using StreamWeaver.Core.Messaging;
using StreamWeaver.Core.Models.Events;
using StreamWeaver.Core.Models.Events.Messages;
using StreamWeaver.Core.Models.Settings;
using StreamWeaver.Core.Plugins;
using StreamWeaver.Core.Services.Authentication;
using StreamWeaver.Core.Services.Platforms;
using StreamWeaver.Core.Services.Settings;
namespace StreamWeaver.Core.Services;
public partial class UnifiedEventService(
    ILogger<UnifiedEventService> logger,
    ISettingsService settingsService,
    IMessenger messenger,
    ITokenStorageService tokenStorage,
    ITwitchClient twitchClient,
    TwitchAuthService twitchAuthService,
    TwitchApiService twitchApiService,
    IYouTubeClient youTubeClient,
    YouTubeAuthService youTubeAuthService,
    IStreamlabsClient streamlabsClient,
    IEmoteBadgeService emoteBadgeService,
    PluginService pluginService,
    DispatcherQueue dispatcherQueue
) : IDisposable
{
    private readonly ILogger<UnifiedEventService> _logger = logger;
    private readonly ISettingsService _settingsService = settingsService;
    private readonly IMessenger _messenger = messenger;
    private readonly ITokenStorageService _tokenStorage = tokenStorage;
    private readonly ITwitchClient _twitchClient = twitchClient;
    private readonly TwitchAuthService _twitchAuthService = twitchAuthService;
    private readonly TwitchApiService _twitchApiService = twitchApiService;
    private readonly IYouTubeClient _youTubeClient = youTubeClient;
    private readonly YouTubeAuthService _youTubeAuthService = youTubeAuthService;
    private readonly IStreamlabsClient _streamlabsClient = streamlabsClient;
    private readonly IEmoteBadgeService _emoteBadgeService = emoteBadgeService;
    private readonly PluginService _pluginService = pluginService;
    private readonly DispatcherQueue _dispatcherQueue = dispatcherQueue;
    private readonly ConcurrentDictionary<string, object> _accountMap = new();
    private AppSettings _currentSettings = new();
    private bool _isDisposed = false;
    public async Task InitializeAsync()
    {
        _logger.LogInformation("Initializing UnifiedEventService...");
        await LoadAndProcessInitialSettingsAsync();
        try
        {
            await _emoteBadgeService.LoadGlobalTwitchDataAsync();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error loading global emote/badge data on init");
        }
        await ConnectAllConfiguredAsync(true);
        _messenger.Send(new ConnectionsUpdatedMessage());
        _logger.LogInformation("UnifiedEventService Initialization complete.");
    }
    private async Task LoadAndProcessInitialSettingsAsync()
    {
        _currentSettings = await _settingsService.LoadSettingsAsync();
        _settingsService.SettingsUpdated += OnSettingsUpdated;
        BuildAccountMap();
        HookCollectionChangedHandlers(_currentSettings.Connections);
    }
    private void BuildAccountMap()
    {
        _accountMap.Clear();
        if (_currentSettings.Connections?.TwitchAccounts != null)
        {
            foreach (TwitchAccount acc in _currentSettings.Connections.TwitchAccounts)
            {
                if (!string.IsNullOrEmpty(acc.UserId))
                {
                    _accountMap[$"twitch_{acc.UserId}"] = acc;
                }
            }
        }
        if (_currentSettings.Connections?.YouTubeAccounts != null)
        {
            foreach (YouTubeAccount acc in _currentSettings.Connections.YouTubeAccounts)
            {
                if (!string.IsNullOrEmpty(acc.ChannelId))
                {
                    _accountMap[$"youtube_{acc.ChannelId}"] = acc;
                }
            }
        }
        _logger.LogDebug("Account map rebuilt. Count: {Count}", _accountMap.Count);
    }
    private void HookCollectionChangedHandlers(ConnectionSettings? connections)
    {
        if (connections?.TwitchAccounts != null)
        {
            connections.TwitchAccounts.CollectionChanged -= TwitchAccounts_CollectionChanged;
            connections.TwitchAccounts.CollectionChanged += TwitchAccounts_CollectionChanged;
        }
        if (connections?.YouTubeAccounts != null)
        {
            connections.YouTubeAccounts.CollectionChanged -= YouTubeAccounts_CollectionChanged;
            connections.YouTubeAccounts.CollectionChanged += YouTubeAccounts_CollectionChanged;
        }
    }
    private void UnhookCollectionChangedHandlers(ConnectionSettings? connections)
    {
        if (connections?.TwitchAccounts != null)
        {
            connections.TwitchAccounts.CollectionChanged -= TwitchAccounts_CollectionChanged;
        }
        if (connections?.YouTubeAccounts != null)
        {
            connections.YouTubeAccounts.CollectionChanged -= YouTubeAccounts_CollectionChanged;
        }
    }
    private async void TwitchAccounts_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        _logger.LogInformation("TwitchAccounts collection changed (Action: {Action})", e.Action);
        if (_isDisposed)
            return;
        await ProcessAccountCollectionChangesAsync<TwitchAccount>(
            e,
            _twitchClient,
            ConnectTwitchAccountAsync,
            LogoutTwitchAccountAsync,
            a => a?.UserId
        );
        _messenger.Send(new ConnectionsUpdatedMessage());
    }
    private async void YouTubeAccounts_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        _logger.LogInformation("YouTubeAccounts collection changed (Action: {Action})", e.Action);
        if (_isDisposed)
            return;
        await ProcessAccountCollectionChangesAsync<YouTubeAccount>(
            e,
            _youTubeClient,
            ConnectYouTubeAccountAsync,
            LogoutYouTubeAccountAsync,
            a => a?.ChannelId
        );
        _messenger.Send(new ConnectionsUpdatedMessage());
    }
    private async Task ProcessAccountCollectionChangesAsync<T>(
        NotifyCollectionChangedEventArgs e,
        object platformClient,
        Func<T, Task> connectFunc,
        Func<string, Task> logoutFunc,
        Func<T?, string?> idSelector
    )
        where T : ObservableObject
    {
        if (e.Action == NotifyCollectionChangedAction.Add && e.NewItems != null)
        {
            foreach (T? account in e.NewItems.OfType<T>())
            {
                if (account == null)
                    continue;
                string? accountId = idSelector(account);
                if (accountId == null)
                    continue;
                string mapKey = $"{GetPlatformPrefix(account)}_{accountId}";
                if (account is YouTubeAccount ytAcc)
                {
                    _accountMap[mapKey] = ytAcc;
                }
                else if (account is TwitchAccount twitchAcc)
                {
                    _accountMap[mapKey] = twitchAcc;
                }
                _logger.LogInformation("Account added via collection change ({MapKey}). Checking AutoConnect...", mapKey);
                if (GetAutoConnect(account))
                {
                    await connectFunc(account);
                }
                else
                {
                    UpdateAccountModelStatus(accountId, ConnectionStatus.Disconnected, "Manual connection required.");
                }
            }
        }
        else if (e.Action == NotifyCollectionChangedAction.Remove && e.OldItems != null)
        {
            List<Task> logoutTasks = [];
            foreach (T? account in e.OldItems.OfType<T>())
            {
                if (account == null)
                    continue;
                string? accountId = idSelector(account);
                if (accountId == null)
                    continue;
                string mapKey = $"{GetPlatformPrefix(account)}_{accountId}";
                _accountMap.TryRemove(mapKey, out _);
                _logger.LogInformation("Account removed via collection change ({MapKey}). Logging out...", mapKey);
                logoutTasks.Add(logoutFunc(accountId));
            }
            await Task.WhenAll(logoutTasks);
            _logger.LogInformation("Completed {Count} account removal/logout tasks.", logoutTasks.Count);
        }
        else if (e.Action == NotifyCollectionChangedAction.Reset)
        {
            _logger.LogWarning("Account list reset detected for {AccountType}. Rebuilding connections.", typeof(T).Name);
            await DisconnectAllAsync();
            BuildAccountMap();
            await ConnectAllConfiguredAsync();
        }
    }
    private static string GetPlatformPrefix(object account) =>
        account switch
        {
            TwitchAccount _ => "twitch",
            YouTubeAccount _ => "youtube",
            _ => "unknown",
        };
    private async void OnSettingsUpdated(object? sender, EventArgs e)
    {
        if (_isDisposed)
            return;
        _logger.LogInformation("Settings updated event received. Processing changes...");
        AppSettings newSettings = _settingsService.CurrentSettings;
        ConnectionSettings? oldConnections = _currentSettings?.Connections;
        ConnectionSettings? newConnections = newSettings.Connections;
        if (newConnections == null)
        {
            _logger.LogWarning("Received settings update but new ConnectionSettings are null. Aborting processing.");
            return;
        }
        UnhookCollectionChangedHandlers(oldConnections);
        bool twitchCredsChanged =
            _currentSettings?.Credentials?.TwitchApiClientId != newSettings.Credentials?.TwitchApiClientId
            || _currentSettings?.Credentials?.TwitchApiClientSecret != newSettings.Credentials?.TwitchApiClientSecret;
        bool youtubeCredsChanged =
            _currentSettings?.Credentials?.YouTubeApiClientId != newSettings.Credentials?.YouTubeApiClientId
            || _currentSettings?.Credentials?.YouTubeApiClientSecret != newSettings.Credentials?.YouTubeApiClientSecret;
        bool youtubeDebugIdChanged = oldConnections?.DebugYouTubeLiveChatId != newConnections.DebugYouTubeLiveChatId;
        if (twitchCredsChanged)
            _logger.LogInformation("Twitch credentials changed detected.");
        if (youtubeCredsChanged)
            _logger.LogInformation("YouTube credentials changed detected.");
        if (youtubeDebugIdChanged)
            _logger.LogInformation("YouTube Debug LiveChatId changed detected.");
        await CompareAndProcessAccountsAsync(
            oldConnections?.TwitchAccounts,
            newConnections.TwitchAccounts,
            _twitchClient,
            ConnectTwitchAccountAsync,
            LogoutTwitchAccountAsync,
            a => a?.UserId,
            twitchCredsChanged,
            (a1, a2) => a1.AutoConnect == a2.AutoConnect
        );
        await CompareAndProcessAccountsAsync(
            oldConnections?.YouTubeAccounts,
            newConnections.YouTubeAccounts,
            _youTubeClient,
            ConnectYouTubeAccountAsync,
            LogoutYouTubeAccountAsync,
            a => a?.ChannelId,
            youtubeCredsChanged || youtubeDebugIdChanged,
            (a1, a2) => a1.AutoConnect == a2.AutoConnect && a1.OverrideVideoId == a2.OverrideVideoId
        );
        bool streamlabsEnableChanged = oldConnections?.EnableStreamlabs != newConnections.EnableStreamlabs;
        bool streamlabsTokenChanged = oldConnections?.StreamlabsTokenId != newConnections.StreamlabsTokenId;
        bool streamlabsActionNeeded = streamlabsEnableChanged || (newConnections.EnableStreamlabs && streamlabsTokenChanged);
        if (streamlabsActionNeeded)
        {
            _logger.LogInformation(
                "Streamlabs settings changed (Enabled: {Enabled}, Token Changed: {TokenChanged})",
                newConnections.EnableStreamlabs,
                streamlabsTokenChanged
            );
            if (_streamlabsClient.Status != ConnectionStatus.Disconnected)
                await _streamlabsClient.DisconnectAsync();
            if (newConnections.EnableStreamlabs)
                await ConnectStreamlabsAsync();
        }
        else if (newConnections.EnableStreamlabs && _streamlabsClient.Status == ConnectionStatus.Disconnected)
        {
            _logger.LogInformation("Streamlabs enabled but disconnected, attempting reconnect on settings update...");
            await ConnectStreamlabsAsync();
        }
        _currentSettings = newSettings;
        HookCollectionChangedHandlers(newConnections);
        BuildAccountMap();
        _messenger.Send(new ConnectionsUpdatedMessage());
        _logger.LogInformation("Finished processing settings changes.");
    }
    private async Task CompareAndProcessAccountsAsync<T>(
        ICollection<T>? oldAccounts,
        ICollection<T>? newAccounts,
        object platformClient,
        Func<T, Task> connectFunc,
        Func<string, Task> logoutFunc,
        Func<T?, string?> idSelector,
        bool forceReconnect,
        Func<T, T, bool> areConnectionSettingsSame
    )
        where T : ObservableObject
    {
        Dictionary<string, T> oldDict = oldAccounts?.Where(a => idSelector(a) != null).ToDictionary(a => idSelector(a)!, a => a) ?? [];
        Dictionary<string, T> newDict = newAccounts?.Where(a => idSelector(a) != null).ToDictionary(a => idSelector(a)!, a => a) ?? [];
        List<Task> logoutTasks = [];
        foreach (KeyValuePair<string, T> oldPair in oldDict)
        {
            if (!newDict.ContainsKey(oldPair.Key))
            {
                string accountId = oldPair.Key;
                string mapKey = $"{GetPlatformPrefix(oldPair.Value)}_{accountId}";
                _logger.LogInformation("Account removed or ID missing ({MapKey}), logging out...", mapKey);
                logoutTasks.Add(logoutFunc(accountId));
                _accountMap.TryRemove(mapKey, out _);
            }
        }
        if (logoutTasks.Count > 0)
        {
            await Task.WhenAll(logoutTasks);
            _logger.LogInformation("Completed {Count} account removal/logout tasks.", logoutTasks.Count);
        }
        List<Task> connectTasks = [];
        List<Task> modifyTasks = [];
        foreach (KeyValuePair<string, T> newPair in newDict)
        {
            string accountId = newPair.Key;
            T newAccount = newPair.Value;
            string mapKey = $"{GetPlatformPrefix(newAccount)}_{accountId}";
            if (newAccount is YouTubeAccount ytAccMod)
                _accountMap[mapKey] = ytAccMod;
            else if (newAccount is TwitchAccount twitchAccMod)
                _accountMap[mapKey] = twitchAccMod;
            if (!oldDict.TryGetValue(accountId, out T? oldAccount))
            {
                _logger.LogInformation("New account added ({MapKey}). Checking AutoConnect...", mapKey);
                if (GetAutoConnect(newAccount))
                {
                    connectTasks.Add(connectFunc(newAccount));
                }
                else
                {
                    UpdateAccountModelStatus(accountId, ConnectionStatus.Disconnected, "Manual connection required.");
                }
            }
            else if (
                forceReconnect
                || GetAutoConnect(newAccount) != GetAutoConnect(oldAccount!)
                || !areConnectionSettingsSame(oldAccount!, newAccount)
            )
            {
                _logger.LogInformation("Account modified or reconnect forced ({MapKey}). Processing...", mapKey);
                bool shouldBeConnected = GetAutoConnect(newAccount);
                ConnectionStatus currentStatus = ConnectionStatus.Disconnected;
                if (platformClient is ITwitchClient tc)
                {
                    currentStatus = tc.GetStatus(accountId);
                }
                else if (platformClient is IYouTubeClient yc)
                {
                    currentStatus = yc.GetStatus(accountId);
                }
                modifyTasks.Add(
                    Task.Run(async () =>
                    {
                        if (forceReconnect || currentStatus != ConnectionStatus.Disconnected)
                        {
                            _logger.LogDebug(
                                "--> [{MapKey}] Modification/force detected (Current: {CurrentStatus}). Logging out/disconnecting first...",
                                mapKey,
                                currentStatus
                            );
                            await logoutFunc(accountId);
                        }
                        else
                        {
                            _logger.LogDebug("--> [{MapKey}] Modification detected but already disconnected. Will only connect if needed.", mapKey);
                        }
                        if (shouldBeConnected)
                        {
                            _logger.LogDebug("--> [{MapKey}] Reconnecting...", mapKey);
                            await connectFunc(newAccount);
                        }
                        else
                        {
                            UpdateAccountModelStatus(accountId, ConnectionStatus.Disconnected, "Auto-connect disabled.");
                        }
                    })
                );
            }
        }
        if (connectTasks.Count > 0)
        {
            await Task.WhenAll(connectTasks);
            _logger.LogInformation("Completed {Count} new account connection tasks.", connectTasks.Count);
        }
        if (modifyTasks.Count > 0)
        {
            await Task.WhenAll(modifyTasks);
            _logger.LogInformation("Completed {Count} account modification tasks.", modifyTasks.Count);
        }
    }
    private bool GetAutoConnect<T>(T account)
        where T : ObservableObject
    {
        System.Reflection.PropertyInfo? propInfo = typeof(T).GetProperty("AutoConnect");
        if (propInfo != null && propInfo.PropertyType == typeof(bool))
        {
            return (bool)(propInfo.GetValue(account) ?? false);
        }
        _logger.LogWarning("Could not find 'AutoConnect' property on type {AccountType}. Assuming false.", typeof(T).Name);
        return false;
    }
    public async Task ConnectAllConfiguredAsync(bool isInitialConnect = false)
    {
        if (!isInitialConnect)
        {
            _currentSettings = await _settingsService.LoadSettingsAsync();
            BuildAccountMap();
        }
        _logger.LogInformation("Connecting all configured accounts... (Initial: {IsInitial})", isInitialConnect);
        List<Task> tasks = [];
        if (_currentSettings.Connections?.TwitchAccounts != null)
        {
            foreach (TwitchAccount twitchAccount in _currentSettings.Connections.TwitchAccounts.ToList())
            {
                if (twitchAccount.AutoConnect && !string.IsNullOrEmpty(twitchAccount.UserId))
                {
                    tasks.Add(ConnectTwitchAccountAsync(twitchAccount));
                }
                else if (!string.IsNullOrEmpty(twitchAccount.UserId))
                {
                    UpdateAccountModelStatus(twitchAccount.UserId!, ConnectionStatus.Disconnected, "Auto-connect disabled.");
                }
            }
        }
        if (_currentSettings.Connections?.YouTubeAccounts != null)
        {
            foreach (YouTubeAccount ytAccount in _currentSettings.Connections.YouTubeAccounts.ToList())
            {
                if (ytAccount.AutoConnect && !string.IsNullOrEmpty(ytAccount.ChannelId))
                {
                    tasks.Add(ConnectYouTubeAccountAsync(ytAccount));
                }
                else if (!string.IsNullOrEmpty(ytAccount.ChannelId))
                {
                    UpdateAccountModelStatus(ytAccount.ChannelId!, ConnectionStatus.Disconnected, "Auto-connect disabled.");
                }
            }
        }
        if (_currentSettings.Connections?.EnableStreamlabs ?? false)
        {
            tasks.Add(ConnectStreamlabsAsync());
        }
        else if (_streamlabsClient.Status != ConnectionStatus.Disconnected)
        {
            tasks.Add(_streamlabsClient.DisconnectAsync());
        }
        await Task.WhenAll(tasks);
        _logger.LogInformation("Finished ConnectAllConfiguredAsync. Initiated {Count} connection tasks.", tasks.Count);
    }
    public async Task ConnectTwitchAccountAsync(TwitchAccount account)
    {
        if (_isDisposed || account?.UserId == null)
            return;
        ConnectionStatus currentStatus = _twitchClient.GetStatus(account.UserId);
        if (currentStatus is ConnectionStatus.Connected or ConnectionStatus.Connecting)
        {
            UpdateAccountModelStatus(account.UserId, currentStatus, _twitchClient.GetStatusMessage(account.UserId) ?? currentStatus.ToString());
            return;
        }
        UpdateAccountModelStatus(account.UserId, ConnectionStatus.Connecting, "Validating token...");
        _logger.LogInformation("Attempting Twitch connect for {Username} (ID: {UserId})", account.Username, account.UserId);
        bool tokenIsValidOrRefreshed = await _twitchAuthService.ValidateAndRefreshAccessTokenAsync(account.UserId);
        if (!tokenIsValidOrRefreshed)
        {
            UpdateAccountModelStatus(account.UserId, ConnectionStatus.Error, "Token invalid/expired. Please reconnect.");
            _logger.LogWarning("Token validation/refresh failed for Twitch user {Username} (ID: {UserId})", account.Username, account.UserId);
            _messenger.Send(new ConnectionsUpdatedMessage());
            return;
        }
        string storageKey = $"twitch_{account.UserId}";
        (string? AccessToken, _) = await _tokenStorage.GetTokensAsync(storageKey);
        if (!string.IsNullOrEmpty(AccessToken))
        {
            UpdateAccountModelStatus(account.UserId, ConnectionStatus.Connecting, "Connecting to chat...");
            bool connectInitiated = await _twitchClient.ConnectAsync(account.UserId, account.Username!, AccessToken);
            if (connectInitiated)
            {
                ConnectionStatus statusAfterInit = _twitchClient.GetStatus(account.UserId);
                string? msgAfterInit = _twitchClient.GetStatusMessage(account.UserId);
                UpdateAccountModelStatus(account.UserId, statusAfterInit, msgAfterInit ?? statusAfterInit.ToString());
                _logger.LogInformation("Twitch connect initiated for {Username}. Current status: {Status}", account.Username, statusAfterInit);
            }
            else
            {
                UpdateAccountModelStatus(account.UserId, ConnectionStatus.Error, "Failed to initiate connection.");
                _logger.LogError("Twitch connect initiation failed for {Username} (ID: {UserId})", account.Username, account.UserId);
            }
        }
        else
        {
            UpdateAccountModelStatus(account.UserId, ConnectionStatus.Error, "Token missing after validation.");
            _logger.LogError("No valid token found after validation for Twitch user {Username} (ID: {UserId})", account.Username, account.UserId);
        }
        _messenger.Send(new ConnectionsUpdatedMessage());
    }
    public async Task ConnectYouTubeAccountAsync(YouTubeAccount account)
    {
        if (_isDisposed || account?.ChannelId == null)
            return;
        ConnectionStatus currentStatus = _youTubeClient.GetStatus(account.ChannelId);
        if (currentStatus is ConnectionStatus.Connected or ConnectionStatus.Limited or ConnectionStatus.Connecting)
        {
            string? currentlyMonitoredId = _youTubeClient.GetActiveVideoId(account.ChannelId);
            string? desiredMonitorId = GetEffectiveLiveIdToMonitor(account);
            if (currentlyMonitoredId == desiredMonitorId && desiredMonitorId != null)
            {
                _logger.LogDebug(
                    "ConnectYouTubeAccountAsync for {ChannelName} skipped: Already {Status} and monitoring correct Live ID ({LiveId}).",
                    account.ChannelName,
                    currentStatus,
                    desiredMonitorId
                );
                UpdateAccountModelStatus(
                    account.ChannelId,
                    currentStatus,
                    _youTubeClient.GetStatusMessage(account.ChannelId) ?? currentStatus.ToString()
                );
                return;
            }
            _logger.LogInformation(
                "ConnectYouTubeAccountAsync for {ChannelName}: Status is {Status}, but monitored Live ID ('{CurrentId}') needs update to ('{DesiredId}'). Proceeding...",
                account.ChannelName,
                currentStatus,
                currentlyMonitoredId ?? "None",
                desiredMonitorId ?? "None"
            );
        }
        UpdateAccountModelStatus(account.ChannelId, ConnectionStatus.Connecting, "Validating token...");
        _logger.LogInformation("Attempting YouTube connect/monitor for {ChannelName} (ID: {ChannelId})", account.ChannelName, account.ChannelId);
        bool tokenIsValidOrRefreshed = await _youTubeAuthService.ValidateAndRefreshAccessTokenAsync(account.ChannelId);
        if (!tokenIsValidOrRefreshed)
        {
            UpdateAccountModelStatus(account.ChannelId, ConnectionStatus.Error, "Token invalid/expired. Please reconnect.");
            _logger.LogWarning(
                "Token validation/refresh failed for YouTube channel {ChannelName} (ID: {ChannelId})",
                account.ChannelName,
                account.ChannelId
            );
            _messenger.Send(new ConnectionsUpdatedMessage());
            return;
        }
        string storageKey = $"youtube_{account.ChannelId}";
        (string? AccessToken, _) = await _tokenStorage.GetTokensAsync(storageKey);
        if (string.IsNullOrEmpty(AccessToken))
        {
            UpdateAccountModelStatus(account.ChannelId, ConnectionStatus.Error, "Token missing after validation.");
            _logger.LogError(
                "No valid token found after validation for YouTube channel {ChannelName} (ID: {ChannelId})",
                account.ChannelName,
                account.ChannelId
            );
            _messenger.Send(new ConnectionsUpdatedMessage());
            return;
        }
        UpdateAccountModelStatus(account.ChannelId, ConnectionStatus.Connecting, "Connecting API...");
        bool apiConnectSuccessOrLimited = await _youTubeClient.ConnectAsync(account.ChannelId, AccessToken);
        ConnectionStatus statusAfterApiConnect = _youTubeClient.GetStatus(account.ChannelId);
        if (!apiConnectSuccessOrLimited && statusAfterApiConnect != ConnectionStatus.Limited)
        {
            UpdateAccountModelStatus(
                account.ChannelId,
                ConnectionStatus.Error,
                _youTubeClient.GetStatusMessage(account.ChannelId) ?? "API connection failed."
            );
            _logger.LogError("YouTube API connection failed (non-quota) for {ChannelName} (ID: {ChannelId})", account.ChannelName, account.ChannelId);
            _messenger.Send(new ConnectionsUpdatedMessage());
            return;
        }
        _logger.LogInformation("YouTube official API status after connect call: {Status}", statusAfterApiConnect);
        string? liveIdToMonitor = null;
        if (!string.IsNullOrWhiteSpace(account.OverrideVideoId))
        {
            _logger.LogInformation("[{ChannelId}] Using account-specific OverrideVideoId: {LiveId}", account.ChannelId, account.OverrideVideoId);
            liveIdToMonitor = account.OverrideVideoId;
        }
        else
        {
            string? globalDebugId = _currentSettings.Connections?.DebugYouTubeLiveChatId;
            if (!string.IsNullOrWhiteSpace(globalDebugId))
            {
                _logger.LogInformation("[{ChannelId}] Using global DebugYouTubeLiveChatId: {LiveId}", account.ChannelId, globalDebugId);
                liveIdToMonitor = globalDebugId;
            }
            else
            {
                if (statusAfterApiConnect != ConnectionStatus.Limited)
                {
                    UpdateAccountModelStatus(account.ChannelId, ConnectionStatus.Connecting, "Finding active stream...");
                    liveIdToMonitor = await _youTubeClient.FindActiveVideoIdAsync(account.ChannelId);
                    statusAfterApiConnect = _youTubeClient.GetStatus(account.ChannelId);
                    if (
                        string.IsNullOrEmpty(liveIdToMonitor)
                        && statusAfterApiConnect != ConnectionStatus.Limited
                        && statusAfterApiConnect != ConnectionStatus.Error
                    )
                    {
                        UpdateAccountModelStatus(account.ChannelId, ConnectionStatus.Connected, "Ready (No Stream Active)");
                        _logger.LogInformation(
                            "Could not find active YouTube Live ID for {ChannelName} (ID: {ChannelId}).",
                            account.ChannelName,
                            account.ChannelId
                        );
                    }
                }
                else
                {
                    _logger.LogWarning("[{ChannelId}] Cannot find Live ID: API is in Limited state and no override is set.", account.ChannelId);
                    UpdateAccountModelStatus(account.ChannelId, ConnectionStatus.Limited, "Read-Only (Manual Live ID Needed)");
                }
            }
        }
        if (!string.IsNullOrEmpty(liveIdToMonitor))
        {
            _logger.LogInformation("[{ChannelId}] Proceeding to start monitoring for Live ID: {LiveId}", account.ChannelId, liveIdToMonitor);
            await _youTubeClient.StartPollingAsync(account.ChannelId, liveIdToMonitor);
        }
        else
        {
            _logger.LogInformation("[{ChannelId}] No Live ID determined for monitoring. Stopping any existing monitoring.", account.ChannelId);
            await _youTubeClient.StopPollingAsync(account.ChannelId);
        }
        _messenger.Send(new ConnectionsUpdatedMessage());
    }
    public async Task LogoutTwitchAccountAsync(string userId)
    {
        if (string.IsNullOrEmpty(userId))
            return;
        _logger.LogInformation("Logging out Twitch User ID {UserId}", userId);
        await _twitchClient.DisconnectAsync(userId);
        await _twitchAuthService.LogoutAsync(userId);
        UpdateAccountModelStatus(userId, ConnectionStatus.Disconnected, "Logged out.");
        _logger.LogInformation("Logout steps complete for Twitch User ID {UserId}. Settings removal pending caller.", userId);
    }
    public async Task LogoutYouTubeAccountAsync(string channelId)
    {
        if (string.IsNullOrEmpty(channelId))
            return;
        _logger.LogInformation("Logging out YouTube Channel ID {ChannelId}", channelId);
        await _youTubeClient.DisconnectAsync(channelId);
        await _youTubeAuthService.LogoutAsync(channelId);
        UpdateAccountModelStatus(channelId, ConnectionStatus.Disconnected, "Logged out.");
        _logger.LogInformation("Logout steps complete for YouTube Channel ID {ChannelId}. Settings removal pending caller.", channelId);
    }
    public async Task DisconnectAllAsync()
    {
        _logger.LogInformation("Disconnecting all clients...");
        List<Task> tasks = [];
        List<string> twitchIds = [.. _accountMap.Keys.Where(k => k.StartsWith("twitch_")).Select(k => k[7..])];
        foreach (string? id in twitchIds)
        {
            if (!string.IsNullOrEmpty(id) && _twitchClient.GetStatus(id) != ConnectionStatus.Disconnected)
                tasks.Add(_twitchClient.DisconnectAsync(id));
        }
        List<string> youtubeIds = [.. _accountMap.Keys.Where(k => k.StartsWith("youtube_")).Select(k => k[8..])];
        foreach (string? id in youtubeIds)
        {
            if (!string.IsNullOrEmpty(id) && _youTubeClient.GetStatus(id) != ConnectionStatus.Disconnected)
                tasks.Add(_youTubeClient.DisconnectAsync(id));
        }
        if (_streamlabsClient.Status != ConnectionStatus.Disconnected)
            tasks.Add(_streamlabsClient.DisconnectAsync());
        await Task.WhenAll(tasks);
        foreach (string key in _accountMap.Keys.ToList())
        {
            string accountId = key.Contains('_') ? key.Split('_', 2)[1] : key;
            string platform = key.Contains('_') ? key.Split('_', 2)[0] : "unknown";
            UpdateAccountModelStatus(accountId, ConnectionStatus.Disconnected, "Disconnected.");
        }
        _logger.LogInformation("Disconnected all clients completed ({Count} tasks).", tasks.Count);
    }
    private void UpdateAccountModelStatus(string accountId, ConnectionStatus status, string? message)
    {
        string platformPrefix = "unknown";
        string twitchMapKey = $"twitch_{accountId}";
        string youtubeMapKey = $"youtube_{accountId}";
        if (_accountMap.TryGetValue(twitchMapKey, out object? accountModel) && accountModel is TwitchAccount)
        {
            platformPrefix = "twitch";
        }
        else if (_accountMap.TryGetValue(youtubeMapKey, out accountModel) && accountModel is YouTubeAccount)
        {
            platformPrefix = "youtube";
        }
        _dispatcherQueue.TryEnqueue(() =>
        {
            if (_isDisposed)
                return;
            string mapKey = $"{platformPrefix}_{accountId}";
            if (_accountMap.TryGetValue(mapKey, out object? model))
            {
                bool changed = false;
                if (model is TwitchAccount ta)
                {
                    if (ta.Status != status)
                    {
                        ta.Status = status;
                        changed = true;
                    }
                    if (ta.StatusMessage != message)
                    {
                        ta.StatusMessage = message;
                        changed = true;
                    }
                    if (changed)
                        _logger.LogTrace("Dispatched status update for Twitch {Username}: {Status} ('{Message}')", ta.Username, status, message);
                }
                else if (model is YouTubeAccount ya)
                {
                    if (ya.Status != status)
                    {
                        ya.Status = status;
                        changed = true;
                    }
                    if (ya.StatusMessage != message)
                    {
                        ya.StatusMessage = message;
                        changed = true;
                    }
                    if (changed)
                    {
                        _logger.LogTrace(
                            "Dispatched status update for YouTube {ChannelName}: {Status} ('{Message}')",
                            ya.ChannelName,
                            status,
                            message
                        );
                    }
                }
            }
            else
            {
                if (platformPrefix == "unknown")
                {
                    _logger.LogWarning("Could not find account model for ID {AccountId} with either prefix to update UI status.", accountId);
                }
                else
                {
                    _logger.LogWarning("Could not find account model for key {MapKey} to update UI status (likely removed).", mapKey);
                }
            }
        });
    }
    public async Task SendChatMessageAsync(string platform, string senderAccountId, string targetChannelOrChatId, string message)
    {
        if (string.IsNullOrWhiteSpace(message))
            return;
        if (string.IsNullOrWhiteSpace(senderAccountId))
        {
            _logger.LogWarning("Cannot send message to {Platform}/{Target}: senderAccountId is missing.", platform, targetChannelOrChatId);
            return;
        }
        string senderDisplayName = GetSenderDisplayName(platform, senderAccountId);
        ChatMessageEvent potentialCommandEvent = new()
        {
            Platform = platform,
            Timestamp = DateTime.UtcNow,
            OriginatingAccountId = senderAccountId,
            UserId = senderAccountId,
            Username = senderDisplayName,
            RawMessage = message,
            ParsedMessage = [new TextSegment { Text = message }],
        };
        if (PluginService.IsChatCommand(potentialCommandEvent))
        {
            bool suppressMessage = await _pluginService.TryHandleChatCommandAsync(potentialCommandEvent);
            _logger.LogDebug("Local message from {SenderAccountId} handled as command. Routing original command event.", senderAccountId);
            await _pluginService.RouteEventToProcessorsAsync(potentialCommandEvent).ConfigureAwait(false);
            _messenger.Send(new NewEventMessage(potentialCommandEvent));
            if (suppressMessage)
            {
                _logger.LogDebug("Command handler suppressed original message for {SenderAccountId}.", senderAccountId);
                return;
            }
            _logger.LogInformation(
                "Command from {SenderAccountId} was handled by plugin, but not suppressed. Original message will NOT be sent by default.",
                senderAccountId
            );
            return;
        }
        _logger.LogInformation(
            "Sending message '{MessageContent}' via account {SenderAccountId} to {Platform}/{Target}",
            message,
            senderAccountId,
            platform,
            targetChannelOrChatId
        );
        try
        {
            switch (platform.ToLowerInvariant())
            {
                case "twitch":
                    await _twitchClient.SendMessageAsync(senderAccountId, targetChannelOrChatId, message);
                    break;
                case "youtube":
                    await _youTubeClient.SendMessageAsync(senderAccountId, targetChannelOrChatId, message);
                    break;
                default:
                    _logger.LogWarning("Sending messages to platform '{Platform}' is not supported.", platform);
                    return;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending message via platform client {Platform}", platform);
            SystemMessageEvent errorEvent = new()
            {
                Level = SystemMessageLevel.Error,
                Message = $"Failed to send message via {platform}: {ex.Message}",
            };
            _messenger.Send(new NewEventMessage(errorEvent));
        }
    }
    private string GetSenderDisplayName(string platform, string accountId)
    {
        string mapKey = $"{platform.ToLowerInvariant()}_{accountId}";
        return _accountMap.TryGetValue(mapKey, out object? accountModel)
            ? (accountModel as TwitchAccount)?.Username
                ?? (accountModel as YouTubeAccount)?.ChannelName
                ?? $"Bot({accountId[..Math.Min(accountId.Length, 5)]}...)"
            : "StreamWeaver";
    }
    public Task TriggerTwitchLoginAsync()
    {
        _logger.LogInformation("Triggering Twitch Login Flow...");
        return _twitchAuthService.InitiateLoginAsync();
    }
    public async Task TriggerYouTubeLoginAsync()
    {
        _logger.LogInformation("Triggering YouTube Login Flow...");
        YouTubeAuthResult authResult = await _youTubeAuthService.AuthenticateAsync();
        if (authResult.Success && !string.IsNullOrEmpty(authResult.ChannelId))
        {
            _logger.LogInformation(
                "YouTube auth successful for {ChannelName} ({ChannelId}). Updating settings & connecting...",
                authResult.ChannelName,
                authResult.ChannelId
            );
            if (_currentSettings.Connections.YouTubeAccounts == null)
            {
                _currentSettings.Connections.YouTubeAccounts = [];
                HookCollectionChangedHandlers(_currentSettings.Connections);
            }
            YouTubeAccount? existingAccount = _currentSettings.Connections.YouTubeAccounts.FirstOrDefault(a => a.ChannelId == authResult.ChannelId);
            YouTubeAccount accountToConnect;
            bool settingsChanged = false;
            if (existingAccount == null)
            {
                accountToConnect = new YouTubeAccount
                {
                    ChannelId = authResult.ChannelId,
                    ChannelName = authResult.ChannelName ?? "YouTube User",
                    AutoConnect = true,
                    Status = ConnectionStatus.Disconnected,
                };
                _currentSettings.Connections.YouTubeAccounts.Add(accountToConnect);
                _accountMap[$"youtube_{accountToConnect.ChannelId}"] = accountToConnect;
                settingsChanged = true;
                _logger.LogInformation("--> Added new YouTube account: {ChannelName}", accountToConnect.ChannelName);
            }
            else
            {
                accountToConnect = existingAccount;
                if (accountToConnect.ChannelName != authResult.ChannelName && !string.IsNullOrEmpty(authResult.ChannelName))
                {
                    accountToConnect.ChannelName = authResult.ChannelName;
                    settingsChanged = true;
                }
                if (!accountToConnect.AutoConnect)
                {
                    accountToConnect.AutoConnect = true;
                    settingsChanged = true;
                }
                _logger.LogInformation("--> Found existing YouTube account: {ChannelName}", accountToConnect.ChannelName);
            }
            if (settingsChanged)
            {
                await _settingsService.SaveSettingsAsync(_currentSettings);
            }
            _logger.LogInformation("--> Initiating connection for {ChannelName}...", accountToConnect.ChannelName);
            await ConnectYouTubeAccountAsync(accountToConnect);
        }
        else
        {
            _logger.LogError("YouTube authentication failed or was cancelled. Error: {ErrorMessage}", authResult.ErrorMessage);
            SystemMessageEvent errorEvent = new()
            {
                Level = SystemMessageLevel.Error,
                Message = $"YouTube Login Failed: {authResult.ErrorMessage ?? "Authentication cancelled or failed."}",
            };
            _messenger.Send(new NewEventMessage(errorEvent));
        }
    }
    public async Task ConnectStreamlabsAsync()
    {
        if (_isDisposed)
            return;
        if (_streamlabsClient.Status is ConnectionStatus.Connected or ConnectionStatus.Connecting)
        {
            _logger.LogDebug("ConnectStreamlabsAsync skipped: Already {Status}.", _streamlabsClient.Status);
            return;
        }
        string? tokenId = _currentSettings.Connections?.StreamlabsTokenId;
        if (string.IsNullOrWhiteSpace(tokenId))
        {
            _logger.LogWarning("Cannot connect Streamlabs, Token ID missing in settings.");
            return;
        }
        _logger.LogInformation("Attempting Streamlabs connect using Token ID: {TokenId}", tokenId);
        (string? AccessToken, _) = await _tokenStorage.GetTokensAsync(tokenId);
        if (!string.IsNullOrEmpty(AccessToken))
        {
            await _streamlabsClient.ConnectAsync(AccessToken);
        }
        else
        {
            _logger.LogError("Streamlabs Socket Token not found in secure storage for ID: {TokenId}.", tokenId);
        }
    }
    public async Task DisableStreamlabsAsync()
    {
        if (_isDisposed)
            return;
        _logger.LogInformation("Disabling Streamlabs...");
        if (_streamlabsClient.Status != ConnectionStatus.Disconnected)
            await _streamlabsClient.DisconnectAsync();
        bool changed = false;
        if (_currentSettings.Connections.EnableStreamlabs)
        {
            _currentSettings.Connections.EnableStreamlabs = false;
            changed = true;
        }
        string? tokenId = _currentSettings.Connections.StreamlabsTokenId;
        if (!string.IsNullOrEmpty(tokenId))
        {
            _currentSettings.Connections.StreamlabsTokenId = null;
            changed = true;
        }
        if (changed)
        {
            await _settingsService.SaveSettingsAsync(_currentSettings);
            _logger.LogDebug("Streamlabs settings updated (disabled/token removed).");
        }
        if (!string.IsNullOrEmpty(tokenId))
        {
            await _tokenStorage.DeleteTokensAsync(tokenId);
            _logger.LogInformation("Removed Streamlabs token from secure storage (ID: {TokenId}).", tokenId);
        }
        _logger.LogInformation("Streamlabs disabled.");
    }
    private string? GetEffectiveLiveIdToMonitor(YouTubeAccount account) =>
        !string.IsNullOrWhiteSpace(account.OverrideVideoId) ? account.OverrideVideoId
        : !string.IsNullOrWhiteSpace(_currentSettings?.Connections?.DebugYouTubeLiveChatId) ? _currentSettings.Connections.DebugYouTubeLiveChatId
        : _youTubeClient.GetActiveVideoId(account.ChannelId!);
    public void Dispose()
    {
        if (_isDisposed)
            return;
        _isDisposed = true;
        _logger.LogInformation("Disposing UnifiedEventService...");
        _settingsService.SettingsUpdated -= OnSettingsUpdated;
        UnhookCollectionChangedHandlers(_currentSettings?.Connections);
        try
        {
            Task.Run(DisconnectAllAsync).Wait(TimeSpan.FromSeconds(5));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during DisconnectAll on dispose.");
        }
        _accountMap.Clear();
        _logger.LogInformation("UnifiedEventService Dispose finished.");
        GC.SuppressFinalize(this);
    }
}
</file>

<file path="MainWindow.xaml">
<?xml version="1.0" encoding="utf-8"?>
<Window
    x:Class="StreamWeaver.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:StreamWeaver"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:viewmodels="using:StreamWeaver.UI.ViewModels"
    xmlns:views="using:StreamWeaver.UI.Views"
    mc:Ignorable="d"
    Title="StreamWeaver"
    Closed="MainWindow_Closed">
    <Window.SystemBackdrop>
        <MicaBackdrop Kind="Base"/>
    </Window.SystemBackdrop>

    <Grid x:Name="RootGrid">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <Grid x:Name="AppTitleBar"
              Grid.Row="0"
              Height="40"
              IsHitTestVisible="True"
              Canvas.ZIndex="1"
              Background="Transparent">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>

            <StackPanel Grid.Column="0"
                        Orientation="Horizontal"
                        VerticalAlignment="Center"
                        Margin="10,0,0,0">
                <FontIcon Glyph=""
                          FontSize="16"
                          Margin="0,0,10,0"
                          IsHitTestVisible="False"/>
                <TextBlock Text="StreamWeaver"
                           VerticalAlignment="Center"
                           Style="{StaticResource CaptionTextBlockStyle}"
                           IsHitTestVisible="False"/>
            </StackPanel>

            <Border Grid.Column="1"
                    IsHitTestVisible="True"/>

        </Grid>

        <NavigationView
            Grid.Row="1"
            d:DataContext="{d:DesignInstance Type=viewmodels:MainWindowViewModel, IsDesignTimeCreatable=False}"
            x:Name="NavView"
            PaneDisplayMode="Left"
            IsPaneOpen="False"
            IsBackButtonVisible="Collapsed"
            IsSettingsVisible="True"
            SelectionChanged="NavView_SelectionChanged"
            IsTitleBarAutoPaddingEnabled="False">

            <NavigationView.MenuItems>
                <NavigationViewItem Icon="Message"
                                    Content="Chat"
                                    Tag="Chat"/>
            </NavigationView.MenuItems>

            <NavigationView.FooterMenuItems>
                <NavigationViewItem Icon="List"
                                    Content="Logs"
                                    Tag="Logs"/>
            </NavigationView.FooterMenuItems>

            <Frame x:Name="ContentFrame">
                <Frame.ContentTransitions>
                    <TransitionCollection>
                        <NavigationThemeTransition/>
                    </TransitionCollection>
                </Frame.ContentTransitions>
            </Frame>
        </NavigationView>
    </Grid>
</Window>
</file>

<file path="UI/Converters/BoolInverterConverter.cs">
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class BoolInverterConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language) => value is bool b ? !b : (object)false;
    public object ConvertBack(object value, Type targetType, object parameter, string language) => value is bool b ? !b : (object)false;
}
</file>

<file path="UI/Converters/BoolToFontStyleConverter.cs">
using Microsoft.UI.Xaml.Data;
using Windows.UI.Text;
namespace StreamWeaver.UI.Converters;
public class BoolToFontStyleConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language) => value is bool b ? b ? FontStyle.Italic : FontStyle.Normal : (object)FontStyle.Normal;
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/ConnectionStatusToSymbolConverter.cs">
using Microsoft.UI.Xaml.Data;
using StreamWeaver.Core.Models.Settings;
namespace StreamWeaver.UI.Converters;
public class ConnectionStatusToSymbolConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language) => value is ConnectionStatus status
            ? status switch
            {
                ConnectionStatus.Connected => "\uE73E",
                ConnectionStatus.Connecting => "\uF16A",
                ConnectionStatus.Error => "\uEA39",
                ConnectionStatus.Disconnected => "\uE8C9",
                _ => "\uE9CE",
            }
            : (object)"\uE9CE";
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/HostEventTextConverter.cs">
using Microsoft.UI.Xaml.Data;
using StreamWeaver.Core.Models.Events;
namespace StreamWeaver.UI.Converters;
public class HostEventTextConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language) => value is HostEvent hostEvent
            ? hostEvent.IsHosting
                ? $"You are now hosting {hostEvent.HostedChannel ?? "Unknown"}"
                : !string.IsNullOrEmpty(hostEvent.HosterUsername)
                    ? $"{hostEvent.HosterUsername} is hosting you with {hostEvent.ViewerCount} viewer{(hostEvent.ViewerCount != 1 ? "s" : "")}"
                    : (object)"Host mode ended."
            : string.Empty;
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/LogLevelToSymbolConverter.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class LogLevelToSymbolConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is LogLevel level)
        {
            return level switch
            {
                LogLevel.Trace => "\uEBE8",
                LogLevel.Debug => "\uEBE8",
                LogLevel.Information => "\uE946",
                LogLevel.Warning => "\uE7BA",
                LogLevel.Error => "\uEA39",
                LogLevel.Critical => "\uE814",
                LogLevel.None => "\uE783",
                _ => "\uE9CE",
            };
        }
        return "\uE9CE";
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/MembershipDetailsConverter.cs">
using System.Text;
using Microsoft.UI.Xaml.Data;
using StreamWeaver.Core.Models.Events;
namespace StreamWeaver.UI.Converters;
public partial class MembershipDetailsConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is not MembershipEvent me)
        {
            return string.Empty;
        }
        StringBuilder details = new();
        if (!string.IsNullOrWhiteSpace(me.LevelName))
        {
            details.Append($"Level: {me.LevelName}");
        }
        if (me.MilestoneMonths is > 0)
        {
            if (details.Length > 0) details.Append(" | ");
            details.Append($"Months: {me.MilestoneMonths}");
        }
        if (!string.IsNullOrWhiteSpace(me.GifterUsername))
        {
            if (details.Length > 0) details.Append(" | ");
            details.Append($"Gifter: {me.GifterUsername}");
        }
        if (me.GiftCount is > 0)
        {
            if (details.Length > 0) details.Append(" | ");
            details.Append($"Count: {me.GiftCount}");
        }
        return details.ToString();
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) =>
        throw new NotImplementedException();
}
</file>

<file path="UI/Converters/NullToBoolConverter.cs">
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class NullToBoolConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        bool isNull = value == null;
        bool invert = parameter is string strParam && strParam.Equals("Invert", StringComparison.OrdinalIgnoreCase);
        return invert ? isNull : !isNull;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) =>
        throw new NotImplementedException();
}
</file>

<file path="UI/Converters/NullToVisibilityConverter.cs">
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class NullToVisibilityConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        bool isNull = value == null;
        bool invert = parameter is string strParam &&
                      (strParam.Equals("Invert", StringComparison.OrdinalIgnoreCase) ||
                       strParam.Equals("VisibleWhenNull", StringComparison.OrdinalIgnoreCase));
        bool shouldBeVisible = invert ? isNull : !isNull;
        return shouldBeVisible ? Visibility.Visible : Visibility.Collapsed;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/PlatformToIsEnabledConverter.cs">
using Microsoft.UI.Xaml.Data;
namespace StreamWeaver.UI.Converters;
public partial class PlatformToIsEnabledConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        bool invert = parameter is string s && s.Equals("Invert", StringComparison.OrdinalIgnoreCase);
        bool isYouTube = value is string platform && platform.Equals("YouTube", StringComparison.OrdinalIgnoreCase);
        if (invert)
        {
            isYouTube = !isYouTube;
        }
        return isYouTube;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/SubEventRecipientConverter.cs">
using Microsoft.UI.Xaml.Data;
using StreamWeaver.Core.Models.Events;
namespace StreamWeaver.UI.Converters;
public partial class SubEventRecipientConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, string language) => value is SubscriptionEvent subEvent && subEvent.IsGift && !string.IsNullOrEmpty(subEvent.RecipientUsername)
            ? $" to {subEvent.RecipientUsername}"
            : (object)string.Empty;
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/ViewModels/LogsViewModel.cs">
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using Microsoft.UI.Dispatching;
using StreamWeaver.Core.Models;
using StreamWeaver.Core.Services;
namespace StreamWeaver.UI.ViewModels;
public partial class LogsViewModel : ObservableObject, IDisposable
{
    private readonly ILogger<LogsViewModel> _logger;
    private readonly LogViewerService _logViewerService;
    private readonly DispatcherQueue _dispatcherQueue;
    private bool _disposed = false;
    public ObservableCollection<LogEntry> AllLogEntries => _logViewerService.LogEntries;
    [ObservableProperty]
    public partial ObservableCollection<LogEntry> FilteredLogEntries { get; set; } = [];
    [ObservableProperty]
    public partial bool ShowDebug { get; set; } = true;
    [ObservableProperty]
    public partial bool ShowInfo { get; set; } = true;
    [ObservableProperty]
    public partial bool ShowWarn { get; set; } = true;
    [ObservableProperty]
    public partial bool ShowError { get; set; } = true;
    public LogsViewModel(ILogger<LogsViewModel> logger, DispatcherQueue dispatcherQueue, LogViewerService logViewerService)
    {
        _logger = logger;
        _logViewerService = logViewerService;
        _dispatcherQueue = dispatcherQueue;
        _logger.LogInformation("Initializing LogsViewModel.");
        AllLogEntries.CollectionChanged += AllLogEntries_CollectionChanged;
        RebuildFilteredLogs();
        PropertyChanged += ViewModel_PropertyChanged;
    }
    private void ViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName is nameof(ShowDebug) or nameof(ShowInfo) or nameof(ShowWarn) or nameof(ShowError))
        {
            _logger.LogDebug("Filter property changed: {PropertyName}. Rebuilding filtered logs.", e.PropertyName);
            RebuildFilteredLogs();
        }
    }
    private void AllLogEntries_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        if (_disposed)
            return;
        _dispatcherQueue.TryEnqueue(() =>
        {
            if (_disposed)
                return;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    if (e.NewItems != null)
                    {
                        foreach (LogEntry? newItem in e.NewItems.OfType<LogEntry>())
                        {
                            if (newItem != null && ShouldDisplayLog(newItem))
                            {
                                FilteredLogEntries.Add(newItem);
                                _logger.LogTrace(
                                    "Added new log entry to filtered view: Level={Level}, Category={Category}",
                                    newItem.Level,
                                    newItem.Category
                                );
                            }
                        }
                    }
                    break;
                case NotifyCollectionChangedAction.Remove:
                    if (e.OldItems != null)
                    {
                        foreach (LogEntry? oldItem in e.OldItems.OfType<LogEntry>())
                        {
                            if (oldItem != null)
                            {
                                bool removed = FilteredLogEntries.Remove(oldItem);
                                if (removed)
                                    _logger.LogTrace("Removed log entry from filtered view due to source removal.");
                            }
                        }
                    }
                    break;
                case NotifyCollectionChangedAction.Reset:
                    _logger.LogInformation("Source log collection cleared. Clearing filtered view.");
                    FilteredLogEntries.Clear();
                    break;
                case NotifyCollectionChangedAction.Replace:
                case NotifyCollectionChangedAction.Move:
                default:
                    _logger.LogDebug("Unhandled collection action ({Action}) or complex change detected. Rebuilding filtered logs.", e.Action);
                    RebuildFilteredLogs();
                    break;
            }
        });
    }
    private bool ShouldDisplayLog(LogEntry entry) =>
        entry.Level switch
        {
            LogLevel.Trace => ShowDebug,
            LogLevel.Debug => ShowDebug,
            LogLevel.Information => ShowInfo,
            LogLevel.Warning => ShowWarn,
            LogLevel.Error => ShowError,
            LogLevel.Critical => ShowError,
            LogLevel.None => false,
            _ => true,
        };
    private void RebuildFilteredLogs() =>
        _dispatcherQueue.TryEnqueue(() =>
        {
            if (_disposed)
                return;
            _logger.LogDebug("Rebuilding filtered log entries...");
            try
            {
                var newFilteredList = AllLogEntries.Where(ShouldDisplayLog).ToList();
                FilteredLogEntries = [.. newFilteredList];
                _logger.LogInformation("Filtered log entries rebuilt (Collection Replaced). Count: {Count}", FilteredLogEntries.Count);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during filtered log rebuild.");
            }
        });
    [RelayCommand]
    private void ClearLogs()
    {
        _logger.LogInformation("ClearLogs command executed.");
        _logViewerService.ClearLogs();
    }
    public void Dispose()
    {
        if (_disposed)
            return;
        _disposed = true;
        _logger.LogInformation("Disposing LogsViewModel...");
        if (AllLogEntries != null)
        {
            try
            {
                AllLogEntries.CollectionChanged -= AllLogEntries_CollectionChanged;
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Exception unsubscribing from AllLogEntries.CollectionChanged.");
            }
        }
        PropertyChanged -= ViewModel_PropertyChanged;
        _dispatcherQueue?.TryEnqueue(() => FilteredLogEntries?.Clear());
        _logger.LogInformation("LogsViewModel Dispose finished.");
        GC.SuppressFinalize(this);
    }
}
</file>

<file path="UI/Views/LogsView.xaml">
<?xml version="1.0" encoding="utf-8"?>
<Page
    x:Class="StreamWeaver.UI.Views.LogsView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:viewmodels="using:StreamWeaver.UI.ViewModels"
    xmlns:models="using:StreamWeaver.Core.Models"
    xmlns:converters="using:StreamWeaver.UI.Converters"
    mc:Ignorable="d"
    d:DataContext="{d:DesignInstance Type=viewmodels:LogsViewModel, IsDesignTimeCreatable=False}"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"
    Loaded="Page_Loaded"
    Unloaded="Page_Unloaded">

    <Page.Resources>
        <!-- Converters -->
        <converters:LogLevelToSymbolConverter x:Key="LogLevelToSymbolConverter"/>
        <converters:LogLevelToBrushConverter x:Key="LogLevelToBrushConverter"/>
        <converters:DateTimeFormatConverter x:Key="DateTimeFormatConverter"/>
        <converters:NullToVisibilityConverter x:Key="NullToVisibilityConverter"/>

        <!-- Style to remove spacing and rounded corners between ListView items -->
        <Style x:Key="LogRowListViewItemStyle" TargetType="ListViewItem">
            <Setter Property="Padding" Value="0"/>
            <Setter Property="Margin" Value="0"/>
            <Setter Property="MinHeight" Value="0"/>
            <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
            <Setter Property="VerticalContentAlignment" Value="Stretch"/>
            <Setter Property="CornerRadius" Value="0"/>
        </Style>

    </Page.Resources>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Filter Controls -->
        <StackPanel Grid.Row="0" Orientation="Horizontal" Spacing="10" Padding="10">
            <TextBlock Text="Show Levels:" VerticalAlignment="Center"/>
            <CheckBox Content="Debug" IsChecked="{Binding ShowDebug, Mode=TwoWay}" VerticalAlignment="Center"/>
            <CheckBox Content="Info" IsChecked="{Binding ShowInfo, Mode=TwoWay}" VerticalAlignment="Center"/>
            <CheckBox Content="Warn" IsChecked="{Binding ShowWarn, Mode=TwoWay}" VerticalAlignment="Center"/>
            <CheckBox Content="Error" IsChecked="{Binding ShowError, Mode=TwoWay}" VerticalAlignment="Center"/>
            <Button Content="Clear Logs" Command="{Binding ClearLogsCommand}" Margin="20,0,0,0"/>
        </StackPanel>

        <!-- Log List -->
        <ListView
            x:Name="LogsListView"
            Grid.Row="1"
            ItemsSource="{Binding FilteredLogEntries}"
            SelectionMode="None"
            IsItemClickEnabled="False"
            HorizontalContentAlignment="Stretch"
            ScrollViewer.VerticalScrollBarVisibility="Auto"
            ScrollViewer.HorizontalScrollBarVisibility="Disabled"
            ItemContainerStyle="{StaticResource LogRowListViewItemStyle}">
            <ListView.ItemTemplate>
                <DataTemplate x:DataType="models:LogEntry">
                    <Grid Background="{Binding Level, Converter={StaticResource LogLevelToBrushConverter}, ConverterParameter=Background}"
                          BorderThickness="0,0,0,1"
                          BorderBrush="{ThemeResource CardStrokeColorDefaultBrush}"
                          CornerRadius="0">
                        <StackPanel Padding="4,6,4,6">
                            <Grid>
                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition Width="75"/>
                                    <ColumnDefinition Width="25"/>
                                    <ColumnDefinition Width="150"/>
                                    <ColumnDefinition Width="*"/>
                                </Grid.ColumnDefinitions>

                                <TextBlock Grid.Column="0" Text="{Binding Timestamp, Converter={StaticResource DateTimeFormatConverter}, ConverterParameter='HH:mm:ss.fff'}" FontSize="11" VerticalAlignment="Center" Margin="0,0,8,0" Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                                <FontIcon Grid.Column="1" Glyph="{Binding Level, Converter={StaticResource LogLevelToSymbolConverter}}" Foreground="{Binding Level, Converter={StaticResource LogLevelToBrushConverter}}" FontFamily="{StaticResource SymbolThemeFontFamily}" FontSize="14" VerticalAlignment="Center" Margin="0,0,6,0">
                                    <ToolTipService.ToolTip>
                                        <ToolTip Content="{Binding Level}"/>
                                    </ToolTipService.ToolTip>
                                </FontIcon>
                                <TextBlock Grid.Column="2" Text="{Binding Category}" FontSize="11" VerticalAlignment="Center" Margin="0,0,8,0" TextTrimming="CharacterEllipsis" Foreground="{ThemeResource TextFillColorTertiaryBrush}">
                                     <ToolTipService.ToolTip>
                                        <ToolTip Content="{Binding Category}"/>
                                    </ToolTipService.ToolTip>
                                </TextBlock>
                                <TextBlock Grid.Column="3" Text="{Binding Message}" TextWrapping="Wrap" VerticalAlignment="Center" IsTextSelectionEnabled="True" Foreground="{ThemeResource TextFillColorPrimaryBrush}"/>
                            </Grid>

                            <TextBlock Text="{Binding Exception}"
                                       Visibility="{Binding Exception, Converter={StaticResource NullToVisibilityConverter}}"
                                       TextWrapping="Wrap"
                                       IsTextSelectionEnabled="True"
                                       FontSize="10"
                                       FontFamily="Consolas, Courier New"
                                       Foreground="{ThemeResource TextFillColorTertiaryBrush}"
                                       Margin="250,4,0,0" />
                        </StackPanel>
                    </Grid>
                </DataTemplate>
            </ListView.ItemTemplate>
        </ListView>
    </Grid>
</Page>
</file>

<file path="UI/Views/SettingsPages/AccountsSettingsPage.xaml.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using StreamWeaver.Core.Models.Settings;
using StreamWeaver.UI.ViewModels;
namespace StreamWeaver.UI.Views.SettingsPages;
public sealed partial class AccountsSettingsPage : Page
{
    private readonly ILogger<AccountsSettingsPage> _logger;
    public SettingsViewModel? ViewModel => DataContext as SettingsViewModel;
    public AccountsSettingsPage()
    {
        InitializeComponent();
        try
        {
            _logger = App.GetService<ILogger<AccountsSettingsPage>>();
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"[AccountsSettingsPage] FATAL: Failed to resolve ILogger<AccountsSettingsPage>: {ex}");
            throw;
        }
        _logger.LogInformation("AccountsSettingsPage initialized.");
    }
    private async void AccountToggle_Toggled(object sender, RoutedEventArgs e)
    {
        if (sender is not ToggleSwitch toggleSwitch)
            return;
        if (ViewModel == null)
        {
            _logger.LogWarning("AccountToggle_Toggled fired but ViewModel is null.");
            return;
        }
        object? account = toggleSwitch.DataContext;
        bool connect = toggleSwitch.IsOn;
        if (account is TwitchAccount twitchAccount)
        {
            _logger.LogInformation("Twitch account toggle changed for {Username}. New state: {IsOn}", twitchAccount.Username, connect);
            await ViewModel.HandleAccountToggleAsync(twitchAccount, connect);
        }
        else if (account is YouTubeAccount youtubeAccount)
        {
            _logger.LogInformation("YouTube account toggle changed for {ChannelName}. New state: {IsOn}", youtubeAccount.ChannelName, connect);
            await ViewModel.HandleAccountToggleAsync(youtubeAccount, connect);
        }
        else
        {
            _logger.LogWarning(
                "AccountToggle_Toggled fired, but DataContext was not a recognized account type ({AccountType})",
                account?.GetType().Name ?? "null"
            );
        }
    }
    private async void StreamlabsEnableToggle_Toggled(object sender, RoutedEventArgs e)
    {
        if (sender is ToggleSwitch toggle && ViewModel != null)
        {
            bool isEnabled = toggle.IsOn;
            _logger.LogInformation("Streamlabs Enable ToggleSwitch toggled. New state: IsOn = {IsEnabled}", isEnabled);
            try
            {
                await ViewModel.ToggleStreamlabsEnableAsync(isEnabled);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error occurred while ViewModel handled Streamlabs toggle state change to {IsEnabled}", isEnabled);
            }
        }
        else
        {
            _logger.LogWarning("StreamlabsEnableToggle_Toggled event fired, but sender is not a ToggleSwitch or ViewModel is null.");
        }
    }
}
</file>

<file path="UI/Views/SettingsPages/TtsSettingsPage.xaml.cs">
using Microsoft.UI.Xaml.Controls;
namespace StreamWeaver.UI.Views.SettingsPages;
public sealed partial class TtsSettingsPage : Page
{
    public TtsSettingsPage() => InitializeComponent();
}
</file>

<file path="UI/Views/SettingsView.xaml.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using StreamWeaver.UI.ViewModels;
using StreamWeaver.UI.Views.SettingsPages;
namespace StreamWeaver.UI.Views;
public sealed partial class SettingsView : Page
{
    private readonly ILogger<SettingsView> _logger;
    public SettingsViewModel ViewModel { get; }
    public SettingsView()
    {
        InitializeComponent();
        try
        {
            ViewModel = App.GetService<SettingsViewModel>();
            _logger = App.GetService<ILogger<SettingsView>>();
            DataContext = ViewModel;
            _logger.LogInformation("DataContext set to SettingsViewModel.");
            Loaded += SettingsView_Loaded;
        }
        catch (Exception ex)
        {
            App.GetService<ILogger<SettingsView>>()
                ?.LogCritical(ex, "FATAL: Failed to resolve SettingsViewModel or ILogger. SettingsView cannot function.");
            throw;
        }
    }
    private void SettingsView_Loaded(object sender, RoutedEventArgs e)
    {
        Loaded -= SettingsView_Loaded;
        if (ViewModel.SelectedSection != null)
        {
            _logger.LogDebug("View loaded. Navigating to initial section from ViewModel: {SectionTag}", ViewModel.SelectedSection.Tag);
            NavigateToSection(ViewModel.SelectedSection.Tag);
        }
        else if (ViewModel.SettingsSections.Count > 0)
        {
            _logger.LogDebug(
                "View loaded. ViewModel had no selected section. Selecting first section programmatically: {SectionTag}",
                ViewModel.SettingsSections[0].Tag
            );
            SettingsNavView.SelectedItem = ViewModel.SettingsSections[0];
        }
        else
        {
            _logger.LogWarning("View loaded, but no settings sections are available in the ViewModel.");
        }
    }
    private void SettingsNavView_SelectionChanged(NavigationView sender, NavigationViewSelectionChangedEventArgs args)
    {
        if (args.SelectedItem is SettingsSection selectedSection)
        {
            _logger.LogInformation(
                "Settings navigation selection changed to: {SectionName} (Tag: {SectionTag})",
                selectedSection.Name,
                selectedSection.Tag
            );
            NavigateToSection(selectedSection.Tag);
        }
        else if (args.IsSettingsSelected)
        {
            _logger.LogInformation("Settings navigation selection changed to: Settings (IsSettingsSelected)");
        }
        else
        {
            _logger.LogWarning("SettingsNavView_SelectionChanged: SelectedItem is not a SettingsSection or null.");
        }
    }
    private void NavigateToSection(string sectionTag)
    {
        Type? pageType = sectionTag switch
        {
            "Credentials" => typeof(CredentialsSettingsPage),
            "Accounts" => typeof(AccountsSettingsPage),
            "Overlays" => typeof(OverlaysSettingsPage),
            "TTS" => typeof(TtsSettingsPage),
            "Modules" => typeof(ModulesSettingsPage),
            "Plugins" => typeof(PluginsSettingsPage),
            _ => null,
        };
        if (pageType != null && SettingsContentFrame.CurrentSourcePageType != pageType)
        {
            _logger.LogInformation("Navigating SettingsContentFrame to {PageTypeName}", pageType.Name);
            SettingsContentFrame.Navigate(pageType);
        }
        else if (pageType == null)
        {
            _logger.LogWarning("No settings page is defined for section tag: {SectionTag}", sectionTag);
        }
        else
        {
            _logger.LogDebug("Navigation to {PageTypeName} skipped as it is already the current page.", pageType.Name);
        }
    }
}
</file>

<file path="Core/Models/Settings/TtsSettings.cs">
using CommunityToolkit.Mvvm.ComponentModel;
namespace StreamWeaver.Core.Models.Settings;
public enum TtsEngine
{
    WindowsEngine,
    KokoroEngine,
    PiperEngine,
}
public partial class TtsSettings : ObservableObject
{
    public const string WindowsEngine = "Windows";
    public const string KokoroEngine = "Kokoro";
    [ObservableProperty]
    public partial bool Enabled { get; set; } = false;
    [ObservableProperty]
    public partial string SelectedEngine { get; set; } = WindowsEngine;
    [ObservableProperty]
    public partial string? SelectedWindowsVoice { get; set; }
    [ObservableProperty]
    public partial string? SelectedKokoroVoice { get; set; }
    [ObservableProperty]
    public partial int Volume { get; set; } = 80;
    [ObservableProperty]
    public partial int Rate { get; set; } = 0;
    [ObservableProperty]
    public partial bool ReadTwitchSubs { get; set; } = true;
    [ObservableProperty]
    public partial bool ReadTwitchBits { get; set; } = true;
    [ObservableProperty]
    public partial int MinimumBitAmountToRead { get; set; } = 100;
    [ObservableProperty]
    public partial bool ReadRaids { get; set; } = false;
    [ObservableProperty]
    public partial int MinimumRaidViewersToRead { get; set; } = 10;
    [ObservableProperty]
    public partial bool ReadYouTubeNewMembers { get; set; } = true;
    [ObservableProperty]
    public partial bool ReadYouTubeMilestones { get; set; } = true;
    [ObservableProperty]
    public partial int MinimumMilestoneMonthsToRead { get; set; } = 2;
    [ObservableProperty]
    public partial bool ReadYouTubeGiftPurchases { get; set; } = true;
    [ObservableProperty]
    public partial int MinimumGiftCountToRead { get; set; } = 1;
    [ObservableProperty]
    public partial bool ReadYouTubeGiftRedemptions { get; set; } = true;
    [ObservableProperty]
    public partial bool ReadSuperChats { get; set; } = true;
    [ObservableProperty]
    public partial double MinimumSuperChatAmountToRead { get; set; } = 1.00;
    [ObservableProperty]
    public partial bool ReadStreamlabsDonations { get; set; } = true;
    [ObservableProperty]
    public partial double MinimumDonationAmountToRead { get; set; } = 1.00;
    [ObservableProperty]
    public partial bool ReadFollows { get; set; } = false;
    [ObservableProperty]
    public partial string DonationMessageFormat { get; set; } = "{username} donated {amount}! {message}";
    [ObservableProperty]
    public partial string BitsMessageFormat { get; set; } = "{username} cheered {amount}! {message}";
    [ObservableProperty]
    public partial string SuperChatMessageFormat { get; set; } = "{username} sent a Super Chat for {amount}! {message}";
    [ObservableProperty]
    public partial string NewSubMessageFormat { get; set; } = "{username} just subscribed!";
    [ObservableProperty]
    public partial string ResubMessageFormat { get; set; } = "{username} subscribed for {months} months! {message}";
    [ObservableProperty]
    public partial string GiftSubMessageFormat { get; set; } = "{username} gifted a sub to {recipient}!";
    [ObservableProperty]
    public partial string GiftBombMessageFormat { get; set; } = "{username} gifted {amount} subs!";
    [ObservableProperty]
    public partial string NewMemberMessageFormat { get; set; } = "{username} just became a member!";
    [ObservableProperty]
    public partial string MemberMilestoneFormat { get; set; } = "{username} has been a member for {months} months! {message}";
    [ObservableProperty]
    public partial string GiftedMemberPurchaseFormat { get; set; } = "{gifter} just gifted {amount} memberships!";
    [ObservableProperty]
    public partial string GiftedMemberRedemptionFormat { get; set; } = "Welcome {username}, you received a gifted membership!";
    [ObservableProperty]
    public partial string FollowMessageFormat { get; set; } = "{username} just followed!";
    [ObservableProperty]
    public partial string RaidMessageFormat { get; set; } = "{username} is raiding with {amount} viewers!";
}
</file>

<file path="Core/Services/Platforms/YouTubeService.cs">
using System.Collections.Concurrent;
using System.Globalization;
using System.Net;
using CommunityToolkit.Mvvm.Messaging;
using Google;
using Google.Apis.Auth.OAuth2;
using Google.Apis.Services;
using Google.Apis.YouTube.v3;
using Google.Apis.YouTube.v3.Data;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Messaging;
using StreamWeaver.Core.Models.Events;
using StreamWeaver.Core.Models.Events.Messages;
using StreamWeaver.Core.Models.Settings;
using StreamWeaver.Core.Plugins;
using StreamWeaver.Core.Services.Settings;
using YTLiveChat.Contracts.Services;
using YTLiveChatChatItem = YTLiveChat.Contracts.Models.ChatItem;
using YTLiveChatMembershipDetails = YTLiveChat.Contracts.Models.MembershipDetails;
using YTLiveChatMessagePart = YTLiveChat.Contracts.Models.MessagePart;
using YTLiveChatSuperchat = YTLiveChat.Contracts.Models.Superchat;
namespace StreamWeaver.Core.Services.Platforms;
internal sealed partial class YouTubeClientWrapper(string accountId, Google.Apis.YouTube.v3.YouTubeService officialApiService, ILogger logger)
    : IDisposable
{
    public string AccountId { get; } = accountId ?? throw new ArgumentNullException(nameof(accountId));
    public Google.Apis.YouTube.v3.YouTubeService OfficialApiService { get; } =
        officialApiService ?? throw new ArgumentNullException(nameof(officialApiService));
    public ConnectionStatus Status { get; set; } = ConnectionStatus.Disconnected;
    public string? StatusMessage { get; set; }
    public IYTLiveChat? YtChatReaderClient { get; set; }
    public string? ActiveVideoId { get; set; }
    public string? AssociatedLiveChatId { get; set; }
    public bool IsMonitoring => YtChatReaderClient != null;
    private bool _disposed = false;
    private readonly ILogger _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    public EventHandler<ChatReceivedEventArgs>? ChatReceivedHandler { get; set; }
    public EventHandler<ErrorOccurredEventArgs>? ErrorOccurredHandler { get; set; }
    public EventHandler<ChatStoppedEventArgs>? ChatStoppedHandler { get; set; }
    public void Dispose()
    {
        if (_disposed)
            return;
        _disposed = true;
        _logger.LogDebug("[{AccountId}] Disposing YouTubeClientWrapper...", AccountId);
        try
        {
            if (YtChatReaderClient != null)
            {
                if (ChatReceivedHandler != null)
                    YtChatReaderClient.ChatReceived -= ChatReceivedHandler;
                if (ErrorOccurredHandler != null)
                    YtChatReaderClient.ErrorOccurred -= ErrorOccurredHandler;
                if (ChatStoppedHandler != null)
                    YtChatReaderClient.ChatStopped -= ChatStoppedHandler;
            }
            YtChatReaderClient?.Dispose();
            YtChatReaderClient = null;
            ActiveVideoId = null;
            AssociatedLiveChatId = null;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "[{AccountId}] Exception during YtChatReaderClient disposal.", AccountId);
        }
        try
        {
            OfficialApiService.Dispose();
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "[{AccountId}] Exception during OfficialApiService disposal.", AccountId);
        }
        _logger.LogDebug("[{AccountId}] YouTubeClientWrapper disposed.", AccountId);
        GC.SuppressFinalize(this);
    }
}
public partial class YouTubeService : IYouTubeClient, IDisposable
{
    private readonly IMessenger _messenger;
    private readonly IEmoteBadgeService _emoteBadgeService;
    private readonly PluginService _pluginService;
    private readonly IServiceProvider _serviceProvider;
    private readonly ISettingsService _settingsService;
    private readonly ILogger<YouTubeService> _logger;
    private readonly ConcurrentDictionary<string, YouTubeClientWrapper> _activeClients = new();
    private static readonly Dictionary<string, (int Priority, string Color)> s_youTubeBadgeColorPriority = new(StringComparer.OrdinalIgnoreCase)
    {
        { "owner", (10, "#FFD700") },
        { "moderator", (7, "#5E84F1") },
        { "member", (5, "#0F9D58") },
        { "verified", (3, "#AAAAAA") },
    };
    private bool _isDisposed = false;
    public YouTubeService(
        IMessenger messenger,
        IEmoteBadgeService emoteBadgeService,
        PluginService pluginService,
        IServiceProvider serviceProvider,
        ISettingsService settingsService,
        ILogger<YouTubeService> logger
    )
    {
        _messenger = messenger ?? throw new ArgumentNullException(nameof(messenger));
        _emoteBadgeService = emoteBadgeService ?? throw new ArgumentNullException(nameof(emoteBadgeService));
        _pluginService = pluginService ?? throw new ArgumentNullException(nameof(pluginService));
        _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _logger.LogInformation("Initialized.");
    }
    public async Task<bool> ConnectAsync(string accountId, string accessToken)
    {
        string logAccountId = accountId ?? "N/A";
        if (_isDisposed)
        {
            _logger.LogWarning("[{AccountId}] Connect failed: Service is disposed.", logAccountId);
            return false;
        }
        if (string.IsNullOrWhiteSpace(accountId) || string.IsNullOrWhiteSpace(accessToken))
        {
            _logger.LogError("[{AccountId}] Connect failed: Invalid parameters (AccountId or AccessToken missing/empty).", logAccountId);
            return false;
        }
        if (
            _activeClients.TryGetValue(accountId, out YouTubeClientWrapper? existingWrapper)
            && (
                existingWrapper.Status == ConnectionStatus.Connected
                || existingWrapper.Status == ConnectionStatus.Limited
                || existingWrapper.Status == ConnectionStatus.Connecting
            )
        )
        {
            _logger.LogInformation("[{AccountId}] Connect requested but already {ConnectionStatus}.", accountId, existingWrapper.Status);
            return existingWrapper.Status is ConnectionStatus.Connected or ConnectionStatus.Limited;
        }
        if (existingWrapper != null)
        {
            _logger.LogInformation(
                "[{AccountId}] Removing previous client wrapper (State: {ConnectionStatus}) before reconnecting.",
                accountId,
                existingWrapper.Status
            );
            if (_activeClients.TryRemove(accountId, out YouTubeClientWrapper? removed))
                removed?.Dispose();
        }
        _logger.LogInformation("[{AccountId}] Creating/Validating official YouTube API service instance.", accountId);
        UpdateAccountModelStatus(accountId, ConnectionStatus.Connecting, "Initializing API...");
        try
        {
            var credential = GoogleCredential.FromAccessToken(accessToken);
            var officialApiService = new Google.Apis.YouTube.v3.YouTubeService(
                new BaseClientService.Initializer() { HttpClientInitializer = credential, ApplicationName = "StreamWeaver" }
            );
            _logger.LogDebug("[{AccountId}] Performing test API call (Channels.List(mine=true, part=id)) to check token/quota...", accountId);
            ChannelsResource.ListRequest testRequest = officialApiService.Channels.List("id");
            testRequest.Mine = true;
            await testRequest.ExecuteAsync();
            _logger.LogDebug("[{AccountId}] Test API call successful.", accountId);
            var wrapper = new YouTubeClientWrapper(accountId, officialApiService, _logger)
            {
                Status = ConnectionStatus.Connected,
                StatusMessage = "Ready (No Stream Active)",
            };
            if (!_activeClients.TryAdd(accountId, wrapper))
            {
                _logger.LogCritical("[{AccountId}] Failed to add client wrapper to dictionary (race condition?). Aborting connection.", accountId);
                wrapper.Dispose();
                UpdateAccountModelStatus(accountId, ConnectionStatus.Error, "Failed to store connection state.");
                _messenger.Send(new ConnectionsUpdatedMessage());
                return false;
            }
            _logger.LogInformation("[{AccountId}] YouTube official API Service initialized successfully.", accountId);
            UpdateAccountModelStatus(accountId, ConnectionStatus.Connected, "Ready (No Stream Active)");
            _messenger.Send(new ConnectionsUpdatedMessage());
            return true;
        }
        catch (GoogleApiException apiEx) when (IsQuotaError(apiEx))
        {
            _logger.LogWarning(
                apiEx,
                "[{AccountId}] Quota error during API initialization/test call. Entering Limited (Read-Only) state.",
                accountId
            );
            var credential = GoogleCredential.FromAccessToken(accessToken);
            var officialApiService = new Google.Apis.YouTube.v3.YouTubeService(
                new BaseClientService.Initializer() { HttpClientInitializer = credential, ApplicationName = "StreamWeaver" }
            );
            var wrapper = new YouTubeClientWrapper(accountId, officialApiService, _logger)
            {
                Status = ConnectionStatus.Limited,
                StatusMessage = "Read-Only (API Quota Reached)",
            };
            if (!_activeClients.TryAdd(accountId, wrapper))
            {
                _logger.LogCritical(
                    "[{AccountId}] Failed to add client wrapper to dictionary (race condition?) after quota error. Aborting connection.",
                    accountId
                );
                wrapper.Dispose();
                UpdateAccountModelStatus(accountId, ConnectionStatus.Error, "Failed to store limited connection state.");
                _messenger.Send(new ConnectionsUpdatedMessage());
                return false;
            }
            _logger.LogInformation("[{AccountId}] YouTube API Service initialized in LIMITED state due to quota.", accountId);
            UpdateAccountModelStatus(accountId, ConnectionStatus.Limited, "Read-Only (API Quota Reached)");
            _messenger.Send(new ConnectionsUpdatedMessage());
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "[{AccountId}] Failed to initialize YouTube official API Service: {ErrorMessage}", accountId, ex.Message);
            if (_activeClients.TryRemove(accountId, out YouTubeClientWrapper? failed))
                failed?.Dispose();
            UpdateAccountModelStatus(accountId, ConnectionStatus.Error, $"API Init Failed: {ex.Message}");
            _messenger.Send(new ConnectionsUpdatedMessage());
            return false;
        }
    }
    public Task DisconnectAsync(string accountId)
    {
        if (_isDisposed)
        {
            _logger.LogDebug("[{AccountId}] Disconnect skipped: Service is disposed.", accountId);
            return Task.CompletedTask;
        }
        _logger.LogInformation("[{AccountId}] Disconnect requested.", accountId);
        if (_activeClients.TryRemove(accountId, out YouTubeClientWrapper? wrapper))
        {
            _logger.LogInformation("[{AccountId}] Disposing client wrapper.", accountId);
            wrapper.Dispose();
            _logger.LogInformation("[{AccountId}] Client wrapper removed and disposed.", accountId);
        }
        else
        {
            _logger.LogWarning("[{AccountId}] Client wrapper not found during disconnect request.", accountId);
        }
        UpdateAccountModelStatus(accountId, ConnectionStatus.Disconnected, "Disconnected.");
        _messenger.Send(new ConnectionsUpdatedMessage());
        return Task.CompletedTask;
    }
    public async Task<string?> FindActiveVideoIdAsync(string accountId)
    {
        if (!_activeClients.TryGetValue(accountId, out YouTubeClientWrapper? wrapper))
        {
            _logger.LogWarning("[{AccountId}] Cannot find active video ID, client wrapper not found.", accountId);
            return null;
        }
        if (wrapper.OfficialApiService == null)
        {
            _logger.LogError("[{AccountId}] Cannot find active video ID, internal official API service instance is null.", accountId);
            return null;
        }
        if (wrapper.Status == ConnectionStatus.Limited)
        {
            _logger.LogWarning("[{AccountId}] Cannot find active stream via API: Currently in Limited (Quota) state.", accountId);
            return null;
        }
        _logger.LogInformation("[{AccountId}] Searching for USER'S active broadcast Video ID using official API...", accountId);
        try
        {
            LiveBroadcastsResource.ListRequest request = wrapper.OfficialApiService.LiveBroadcasts.List("id,status");
            request.Mine = true;
            LiveBroadcastListResponse response = await request.ExecuteAsync();
            LiveBroadcast? activeBroadcast = response.Items?.Where(b => b.Status.LifeCycleStatus == "live").FirstOrDefault();
            activeBroadcast ??= response.Items?.Where(b => b.Status.LifeCycleStatus == "liveStarting").FirstOrDefault();
            activeBroadcast ??= response.Items?.Where(b => b.Status.LifeCycleStatus == "ready").FirstOrDefault();
            if (activeBroadcast != null && !string.IsNullOrEmpty(activeBroadcast.Id))
            {
                _logger.LogInformation("[{AccountId}] Found user's active broadcast VideoID={VideoId}", accountId, activeBroadcast.Id);
                return activeBroadcast.Id;
            }
            else
            {
                _logger.LogInformation("[{AccountId}] No active broadcast found for user using official API.", accountId);
                return null;
            }
        }
        catch (GoogleApiException apiEx) when (IsQuotaError(apiEx))
        {
            _logger.LogWarning(apiEx, "[{AccountId}] Quota error during active stream Video ID lookup. Entering Limited state.", accountId);
            UpdateWrapperStatus(wrapper, ConnectionStatus.Limited, "Read-Only (API Quota Reached)");
            _messenger.Send(new ConnectionsUpdatedMessage());
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "[{AccountId}] Error finding active broadcast Video ID: {ErrorMessage}", accountId, ex.Message);
            UpdateWrapperStatus(wrapper, ConnectionStatus.Error, $"API Error: {ex.Message}");
            _messenger.Send(new ConnectionsUpdatedMessage());
            return null;
        }
    }
    private async Task<bool> GetAndStoreLiveChatIdForVideoAsync(string accountId, string videoId)
    {
        if (!_activeClients.TryGetValue(accountId, out YouTubeClientWrapper? wrapper))
        {
            _logger.LogWarning("[{AccountId}] Cannot get LiveChatId for Video {VideoId}, client wrapper not found.", accountId, videoId);
            return false;
        }
        if (wrapper.OfficialApiService == null)
        {
            _logger.LogError(
                "[{AccountId}] Cannot get LiveChatId for Video {VideoId}, internal official API service instance is null.",
                accountId,
                videoId
            );
            return false;
        }
        if (wrapper.Status == ConnectionStatus.Limited)
        {
            _logger.LogWarning(
                "[{AccountId}] Cannot get LiveChatId for Video {VideoId} via API: Currently in Limited (Quota) state.",
                accountId,
                videoId
            );
            return false;
        }
        _logger.LogInformation("[{AccountId}] Looking up LiveChatId for specific VideoID: {VideoId}...", accountId, videoId);
        try
        {
            VideosResource.ListRequest request = wrapper.OfficialApiService.Videos.List("liveStreamingDetails");
            request.Id = videoId;
            VideoListResponse response = await request.ExecuteAsync();
            Video? video = response.Items?.FirstOrDefault();
            string? foundLiveChatId = video?.LiveStreamingDetails?.ActiveLiveChatId;
            if (!string.IsNullOrEmpty(foundLiveChatId))
            {
                wrapper.AssociatedLiveChatId = foundLiveChatId;
                _logger.LogInformation("[{AccountId}] Found LiveChatId '{LiveChatId}' for VideoID {VideoId}.", accountId, foundLiveChatId, videoId);
                return true;
            }
            else
            {
                _logger.LogWarning(
                    "[{AccountId}] Could not find LiveChatId for VideoID {VideoId}. Video might not be live, have chat enabled, or exist.",
                    accountId,
                    videoId
                );
                wrapper.AssociatedLiveChatId = null;
                return false;
            }
        }
        catch (GoogleApiException apiEx) when (IsQuotaError(apiEx))
        {
            _logger.LogWarning(
                apiEx,
                "[{AccountId}] Quota error during LiveChatId lookup for VideoID {VideoId}. Entering Limited state.",
                accountId,
                videoId
            );
            UpdateWrapperStatus(wrapper, ConnectionStatus.Limited, "Read-Only (API Quota Reached)");
            _messenger.Send(new ConnectionsUpdatedMessage());
            wrapper.AssociatedLiveChatId = null;
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "[{AccountId}] Error looking up LiveChatId for VideoID {VideoId}: {ErrorMessage}", accountId, videoId, ex.Message);
            wrapper.AssociatedLiveChatId = null;
            UpdateWrapperStatus(wrapper, ConnectionStatus.Error, $"API Error: {ex.Message}");
            _messenger.Send(new ConnectionsUpdatedMessage());
            return false;
        }
    }
    public async Task<string?> LookupAndStoreLiveChatIdAsync(string accountId, string videoId)
    {
        _ = await GetAndStoreLiveChatIdForVideoAsync(accountId, videoId);
        return _activeClients.TryGetValue(accountId, out YouTubeClientWrapper? wrapper) ? wrapper.AssociatedLiveChatId : null;
    }
    public async Task StartPollingAsync(string accountId, string videoId)
    {
        if (!_activeClients.TryGetValue(accountId, out YouTubeClientWrapper? wrapper))
        {
            _logger.LogWarning("[{AccountId}] Cannot start monitoring, client wrapper not found.", accountId);
            return;
        }
        if (string.IsNullOrWhiteSpace(videoId))
        {
            _logger.LogError("[{AccountId}] Cannot start monitoring, Video ID is null or empty.", accountId);
            return;
        }
        if (wrapper.IsMonitoring && wrapper.ActiveVideoId == videoId)
        {
            _logger.LogInformation("[{AccountId}] Already monitoring Video ID: {VideoId}", accountId, videoId);
            return;
        }
        if (wrapper.IsMonitoring)
        {
            _logger.LogInformation("[{AccountId}] Stopping previous monitoring before starting new one for Video ID: {VideoId}", accountId, videoId);
            await StopPollingAsync(accountId);
        }
        if (string.IsNullOrEmpty(wrapper.AssociatedLiveChatId))
        {
            await GetAndStoreLiveChatIdForVideoAsync(accountId, videoId);
        }
        _logger.LogInformation("[{AccountId}] Starting chat monitoring for Video ID: {VideoId}", accountId, videoId);
        ConnectionStatus connectingStatus = wrapper.Status == ConnectionStatus.Limited ? ConnectionStatus.Limited : ConnectionStatus.Connecting;
        UpdateWrapperStatus(wrapper, connectingStatus, $"Monitoring chat for: {videoId}");
        _messenger.Send(new ConnectionsUpdatedMessage());
        try
        {
            wrapper.YtChatReaderClient = _serviceProvider.GetRequiredService<IYTLiveChat>();
            wrapper.ActiveVideoId = videoId;
            wrapper.ChatReceivedHandler = (sender, args) => HandleYtChatReceived(accountId, sender, args);
            wrapper.YtChatReaderClient.ChatReceived += wrapper.ChatReceivedHandler;
            wrapper.ErrorOccurredHandler = (sender, args) => HandleYtChatError(accountId, sender, args);
            wrapper.YtChatReaderClient.ErrorOccurred += wrapper.ErrorOccurredHandler;
            wrapper.ChatStoppedHandler = (sender, args) => HandleYtChatStopped(accountId, sender, args);
            wrapper.YtChatReaderClient.ChatStopped += wrapper.ChatStoppedHandler;
            wrapper.YtChatReaderClient.Start(liveId: videoId);
            ConnectionStatus finalStatus = wrapper.Status == ConnectionStatus.Limited ? ConnectionStatus.Limited : ConnectionStatus.Connected;
            string finalStatusMsg = finalStatus == ConnectionStatus.Limited ? $"Read-Only Monitoring: {videoId}" : $"Monitoring chat: {videoId}";
            UpdateWrapperStatus(wrapper, finalStatus, finalStatusMsg);
            _messenger.Send(new ConnectionsUpdatedMessage());
            SystemMessageEvent systemEvent = new()
            {
                Platform = "YouTube",
                OriginatingAccountId = accountId,
                Message = $"Started monitoring YouTube chat for Video ID: {videoId}",
            };
            _ = _pluginService.RouteEventToProcessorsAsync(systemEvent);
            _messenger.Send(new NewEventMessage(systemEvent));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "[{AccountId}] Failed to create or start YTLiveChat reader for Video ID: {VideoId}", accountId, videoId);
            UpdateWrapperStatus(wrapper, ConnectionStatus.Error, "Failed to start chat reader.");
            wrapper.YtChatReaderClient?.Dispose();
            wrapper.YtChatReaderClient = null;
            wrapper.ActiveVideoId = null;
            wrapper.AssociatedLiveChatId = null;
            _messenger.Send(new ConnectionsUpdatedMessage());
        }
    }
    public Task StopPollingAsync(string accountId)
    {
        if (!_activeClients.TryGetValue(accountId, out YouTubeClientWrapper? wrapper))
        {
            _logger.LogWarning("[{AccountId}] Cannot stop monitoring, client wrapper not found.", accountId);
            return Task.CompletedTask;
        }
        if (!wrapper.IsMonitoring || wrapper.YtChatReaderClient == null)
        {
            _logger.LogDebug("[{AccountId}] Chat monitoring not active, stop request ignored.", accountId);
            return Task.CompletedTask;
        }
        _logger.LogInformation("[{AccountId}] Stopping chat monitoring for Video ID: {VideoId}...", accountId, wrapper.ActiveVideoId);
        bool statusChanged = false;
        try
        {
            if (wrapper.ChatReceivedHandler != null)
                wrapper.YtChatReaderClient.ChatReceived -= wrapper.ChatReceivedHandler;
            if (wrapper.ErrorOccurredHandler != null)
                wrapper.YtChatReaderClient.ErrorOccurred -= wrapper.ErrorOccurredHandler;
            if (wrapper.ChatStoppedHandler != null)
                wrapper.YtChatReaderClient.ChatStopped -= wrapper.ChatStoppedHandler;
            wrapper.YtChatReaderClient.Stop();
            wrapper.YtChatReaderClient.Dispose();
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex,
                "[{AccountId}] Exception occurred while stopping/disposing YTLiveChat reader: {ErrorMessage}",
                accountId,
                ex.Message
            );
        }
        finally
        {
            wrapper.YtChatReaderClient = null;
            wrapper.ActiveVideoId = null;
            wrapper.AssociatedLiveChatId = null;
            ConnectionStatus finalStatus = wrapper.Status == ConnectionStatus.Limited ? ConnectionStatus.Limited : ConnectionStatus.Connected;
            string finalStatusMsg = finalStatus == ConnectionStatus.Limited ? "Read-Only (Monitoring Stopped)" : "Ready (No Stream Active)";
            if (wrapper.Status != finalStatus || wrapper.StatusMessage != finalStatusMsg)
            {
                UpdateWrapperStatus(wrapper, finalStatus, finalStatusMsg);
                statusChanged = true;
            }
            _logger.LogInformation("[{AccountId}] Chat monitoring stopped.", accountId);
            if (statusChanged)
            {
                _messenger.Send(new ConnectionsUpdatedMessage());
            }
        }
        return Task.CompletedTask;
    }
    public async Task SendMessageAsync(string accountId, string liveChatId, string message)
    {
        if (string.IsNullOrWhiteSpace(message))
        {
            _logger.LogWarning("[{AccountId}] Cannot send empty or whitespace message.", accountId);
            return;
        }
        if (!_activeClients.TryGetValue(accountId, out YouTubeClientWrapper? wrapper))
        {
            _logger.LogWarning("[{AccountId}] Cannot send message, client wrapper not found.", accountId);
            return;
        }
        string? targetLiveChatId = liveChatId;
        if (string.IsNullOrWhiteSpace(targetLiveChatId))
        {
            _logger.LogInformation(
                "[{AccountId}] SendMessageAsync: LiveChatId not provided. Attempting lookup using ActiveVideoId '{ActiveVideoId}'...",
                accountId,
                wrapper.ActiveVideoId ?? "N/A"
            );
            if (!string.IsNullOrEmpty(wrapper.ActiveVideoId))
            {
                targetLiveChatId = await LookupAndStoreLiveChatIdAsync(accountId, wrapper.ActiveVideoId);
            }
            if (string.IsNullOrWhiteSpace(targetLiveChatId))
            {
                _logger.LogError(
                    "[{AccountId}] Cannot send message: Failed to determine target LiveChatId (lookup failed or no active Video ID).",
                    accountId
                );
                SystemMessageEvent errorLookupEvent = new()
                {
                    Level = SystemMessageLevel.Error,
                    Message = $"Cannot send YouTube message from {accountId}: Could not find active chat ID.",
                };
                _messenger.Send(new NewEventMessage(errorLookupEvent));
                return;
            }
            _logger.LogInformation("[{AccountId}] SendMessageAsync: Using looked-up LiveChatId '{LiveChatId}'.", accountId, targetLiveChatId);
        }
        if (wrapper.Status == ConnectionStatus.Limited)
        {
            _logger.LogWarning("[{AccountId}] Cannot send message: Client is in Limited (Read-Only) state due to API quota.", accountId);
            SystemMessageEvent errorEvent = new()
            {
                Level = SystemMessageLevel.Warning,
                Message = $"Cannot send YouTube message from {accountId}: API quota reached.",
            };
            _messenger.Send(new NewEventMessage(errorEvent));
            return;
        }
        if (wrapper.OfficialApiService == null)
        {
            _logger.LogError("[{AccountId}] Cannot send message, official API service instance is null.", accountId);
            SystemMessageEvent errorEvent = new()
            {
                Level = SystemMessageLevel.Error,
                Message = $"Cannot send YouTube message from {accountId}: API Client not ready.",
            };
            _messenger.Send(new NewEventMessage(errorEvent));
            return;
        }
        if (wrapper.Status != ConnectionStatus.Connected)
        {
            _logger.LogWarning(
                "[{AccountId}] Cannot send message, client not in Connected state (Current Status: {ConnectionStatus}).",
                accountId,
                wrapper.Status
            );
            SystemMessageEvent errorEvent = new()
            {
                Level = SystemMessageLevel.Warning,
                Message = $"Cannot send YouTube message from {accountId}: Not connected.",
            };
            _messenger.Send(new NewEventMessage(errorEvent));
            return;
        }
        var liveChatMessage = new LiveChatMessage
        {
            Snippet = new LiveChatMessageSnippet
            {
                LiveChatId = targetLiveChatId,
                Type = "textMessageEvent",
                TextMessageDetails = new LiveChatTextMessageDetails { MessageText = message },
            },
        };
        _logger.LogInformation(
            "[{AccountId}] Sending message via official API to LiveChatId {LiveChatId}: {Message}",
            accountId,
            targetLiveChatId,
            message
        );
        try
        {
            LiveChatMessagesResource.InsertRequest request = wrapper.OfficialApiService.LiveChatMessages.Insert(liveChatMessage, "snippet");
            LiveChatMessage responseMessage = await request.ExecuteAsync();
            _logger.LogDebug("[{AccountId}] Message sent successfully via official API. Message ID: {MessageId}", accountId, responseMessage.Id);
        }
        catch (GoogleApiException apiEx) when (IsQuotaError(apiEx))
        {
            _logger.LogWarning(apiEx, "[{AccountId}] Quota error during message send. Entering Limited (Read-Only) state.", accountId);
            UpdateWrapperStatus(wrapper, ConnectionStatus.Limited, "Read-Only (API Quota Reached)");
            SystemMessageEvent sysErr = new()
            {
                Platform = "YouTube",
                OriginatingAccountId = accountId,
                Message = "Failed to send message: API Quota reached.",
                Level = SystemMessageLevel.Warning,
            };
            _messenger.Send(new NewEventMessage(sysErr));
            _messenger.Send(new ConnectionsUpdatedMessage());
        }
        catch (GoogleApiException apiEx)
        {
            string errorDetail = apiEx.Error?.Message ?? apiEx.Message;
            _logger.LogError(
                apiEx,
                "[{AccountId}] API Error sending message to LiveChatId {LiveChatId}. Status: {StatusCode}, Message: {ErrorDetail}",
                accountId,
                targetLiveChatId,
                apiEx.HttpStatusCode,
                errorDetail
            );
            SystemMessageEvent systemEvent = new()
            {
                Platform = "YouTube",
                OriginatingAccountId = accountId,
                Message = $"Error sending message: {errorDetail}",
                Level = SystemMessageLevel.Error,
            };
            _messenger.Send(new NewEventMessage(systemEvent));
            if (apiEx.HttpStatusCode is HttpStatusCode.Unauthorized or HttpStatusCode.Forbidden)
            {
                _logger.LogWarning("[{AccountId}] Access token likely expired or forbidden during send. Disconnecting instance.", accountId);
                await DisconnectAsync(accountId);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex,
                "[{AccountId}] Unexpected error sending message to LiveChatId {LiveChatId}: {ErrorMessage}",
                accountId,
                targetLiveChatId,
                ex.Message
            );
            SystemMessageEvent systemEvent = new()
            {
                Platform = "YouTube",
                OriginatingAccountId = accountId,
                Message = $"Error sending message: {ex.Message}",
                Level = SystemMessageLevel.Error,
            };
            _messenger.Send(new NewEventMessage(systemEvent));
        }
    }
    private async void HandleYtChatReceived(string accountId, object? _, ChatReceivedEventArgs args)
    {
        if (!_activeClients.ContainsKey(accountId))
        {
            _logger.LogWarning("[{AccountId}] HandleYtChatReceived skipped: Wrapper not found.", accountId);
            return;
        }
        _logger.LogTrace(
            "[{AccountId}] Received ChatItem from YTLiveChat reader. ID: {ItemId}, Author: {AuthorName}",
            accountId,
            args.ChatItem.Id,
            args.ChatItem.Author.Name
        );
        BaseEvent? commonEvent = MapYtChatItemToCommonEvent(args.ChatItem, accountId);
        if (commonEvent != null)
        {
            if (commonEvent is ChatMessageEvent chatEvent && PluginService.IsChatCommand(chatEvent))
            {
                _logger.LogDebug("[{AccountId}] Checking YouTube message (ID: {YtItemId}) as potential command.", accountId, args.ChatItem.Id);
                bool eventSuppressedOrReplaced = await _pluginService.TryHandleChatCommandAsync(chatEvent);
                await _pluginService.RouteEventToProcessorsAsync(chatEvent).ConfigureAwait(false);
                _messenger.Send(new NewEventMessage(chatEvent));
                if (eventSuppressedOrReplaced)
                {
                    _logger.LogDebug(
                        "[{AccountId}] YouTube chat message (ID: {YtItemId}) was processed by a command handler and potentially suppressed/replaced.",
                        accountId,
                        args.ChatItem.Id
                    );
                }
            }
            else
            {
                _logger.LogTrace("Routing non-command event {EventType} ({EventId})", commonEvent.GetType().Name, commonEvent.Id);
                await _pluginService.RouteEventToProcessorsAsync(commonEvent).ConfigureAwait(false);
                _messenger.Send(new NewEventMessage(commonEvent));
            }
        }
        else
        {
            _logger.LogWarning("[{AccountId}] Failed to map YTLiveChat ChatItem (ID: {ItemId}) to a common event.", accountId, args.ChatItem.Id);
        }
    }
    private void HandleYtChatError(string accountId, object? _, ErrorOccurredEventArgs args)
    {
        if (!_activeClients.TryGetValue(accountId, out YouTubeClientWrapper? wrapper))
        {
            _logger.LogWarning("[{AccountId}] HandleYtChatError skipped: Wrapper not found.", accountId);
            return;
        }
        _logger.LogError(args.GetException(), "[{AccountId}] Error received from YTLiveChat reader.", accountId);
        UpdateWrapperStatus(wrapper, ConnectionStatus.Error, $"Chat Reader Error: {args.GetException().Message}");
        SystemMessageEvent sysErr = new()
        {
            Platform = "YouTube",
            OriginatingAccountId = accountId,
            Message = $"YouTube chat reader error: {args.GetException().Message}",
            Level = SystemMessageLevel.Error,
        };
        _messenger.Send(new NewEventMessage(sysErr));
        _messenger.Send(new ConnectionsUpdatedMessage());
    }
    private void HandleYtChatStopped(string accountId, object? _, ChatStoppedEventArgs args)
    {
        if (!_activeClients.TryGetValue(accountId, out YouTubeClientWrapper? wrapper))
        {
            _logger.LogWarning("[{AccountId}] HandleYtChatStopped skipped: Wrapper not found.", accountId);
            return;
        }
        _logger.LogWarning("[{AccountId}] YTLiveChat reader stopped unexpectedly. Reason: {Reason}", accountId, args.Reason ?? "Unknown");
        if (wrapper.Status is ConnectionStatus.Connected or ConnectionStatus.Connecting or ConnectionStatus.Limited)
        {
            UpdateWrapperStatus(wrapper, ConnectionStatus.Error, $"Chat Reader Stopped: {args.Reason ?? "Unknown"}");
            SystemMessageEvent sysErr = new()
            {
                Platform = "YouTube",
                OriginatingAccountId = accountId,
                Message = $"YouTube chat reader stopped: {args.Reason}",
                Level = SystemMessageLevel.Warning,
            };
            _messenger.Send(new NewEventMessage(sysErr));
            _messenger.Send(new ConnectionsUpdatedMessage());
        }
        wrapper.ActiveVideoId = null;
        wrapper.AssociatedLiveChatId = null;
        wrapper.YtChatReaderClient = null;
    }
    private BaseEvent? MapYtChatItemToCommonEvent(YTLiveChatChatItem ytChatItem, string originatingAccountId)
    {
        _logger.LogTrace("Mapping YTLiveChat Item ID {YtItemId} for Account {AccountId}", ytChatItem.Id, originatingAccountId);
        string authorId = ytChatItem.Author?.ChannelId ?? "UnknownChannelID";
        string authorName = ytChatItem.Author?.Name ?? "Unknown User";
        DateTime utcTimestamp = ytChatItem.Timestamp.UtcDateTime;
        string? profileImageUrl = ytChatItem.Author?.Thumbnail?.Url;
        List<BadgeInfo> badgeInfoList = MapYtAuthorToBadges(ytChatItem);
        bool isOwner = ytChatItem.IsOwner;
        string? usernameColor = CalculateYouTubeUsernameColor(badgeInfoList);
        try
        {
            if (ytChatItem.MembershipDetails != null)
            {
                return MapMembershipEvent(
                    ytChatItem,
                    originatingAccountId,
                    utcTimestamp,
                    authorId,
                    authorName,
                    profileImageUrl,
                    badgeInfoList,
                    isOwner,
                    usernameColor
                );
            }
            else if (ytChatItem.Superchat != null)
            {
                return MapDonationEvent(
                    ytChatItem,
                    originatingAccountId,
                    utcTimestamp,
                    authorId,
                    authorName,
                    profileImageUrl,
                    badgeInfoList,
                    isOwner,
                    usernameColor
                );
            }
            else
            {
                string rawMessage = string.Join("", ytChatItem.Message?.Select(p => p.ToString()) ?? []);
                List<MessageSegment> parsedMessage = MapYtMessageParts(ytChatItem.Message);
                return new ChatMessageEvent
                {
                    Id = ytChatItem.Id,
                    Platform = "YouTube",
                    Timestamp = utcTimestamp,
                    OriginatingAccountId = originatingAccountId,
                    UserId = authorId,
                    Username = authorName,
                    RawMessage = rawMessage,
                    ParsedMessage = parsedMessage,
                    UsernameColor = usernameColor,
                    Badges = badgeInfoList,
                    ProfileImageUrl = profileImageUrl,
                    IsOwner = isOwner,
                };
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex,
                "[{AccountId}] Failed to map YTLiveChat item (ID: {YtItemId}) to common event.",
                originatingAccountId,
                ytChatItem.Id
            );
            return null;
        }
    }
    private static MembershipEvent MapMembershipEvent(
        YTLiveChatChatItem ytChatItem,
        string originatingAccountId,
        DateTime timestamp,
        string authorId,
        string authorName,
        string? profileImageUrl,
        List<BadgeInfo> badges,
        bool isOwner,
        string? usernameColor
    )
    {
        YTLiveChatMembershipDetails details = ytChatItem.MembershipDetails!;
        MembershipEventType type = details.EventType switch
        {
            YTLiveChat.Contracts.Models.MembershipEventType.New => MembershipEventType.New,
            YTLiveChat.Contracts.Models.MembershipEventType.Milestone => MembershipEventType.Milestone,
            YTLiveChat.Contracts.Models.MembershipEventType.GiftPurchase => MembershipEventType.GiftPurchase,
            YTLiveChat.Contracts.Models.MembershipEventType.GiftRedemption => MembershipEventType.GiftRedemption,
            _ => MembershipEventType.Unknown,
        };
        List<MessageSegment> parsedUserComment = MapYtMessageParts(ytChatItem.Message);
        return new MembershipEvent
        {
            Id = ytChatItem.Id,
            Platform = "YouTube",
            Timestamp = timestamp,
            OriginatingAccountId = originatingAccountId,
            UserId = authorId,
            Username = authorName,
            MembershipType = type,
            LevelName = details.LevelName,
            MilestoneMonths = details.MilestoneMonths,
            GifterUsername = details.GifterUsername,
            GiftCount = details.GiftCount,
            HeaderText = details.HeaderPrimaryText,
            ParsedMessage = parsedUserComment,
            Badges = badges,
            UsernameColor = usernameColor,
            ProfileImageUrl = profileImageUrl,
            IsOwner = isOwner,
        };
    }
    private DonationEvent MapDonationEvent(
        YTLiveChatChatItem ytChatItem,
        string originatingAccountId,
        DateTime timestamp,
        string authorId,
        string authorName,
        string? profileImageUrl,
        List<BadgeInfo> badges,
        bool isOwner,
        string? usernameColor
    )
    {
        YTLiveChatSuperchat superchat = ytChatItem.Superchat!;
        DonationType donationType = (superchat.Sticker != null) ? DonationType.SuperSticker : DonationType.SuperChat;
        string rawUserComment = string.Join("", ytChatItem.Message?.Select(p => p.ToString()) ?? []);
        List<MessageSegment> parsedUserComment = MapYtMessageParts(ytChatItem.Message);
        decimal amount = 0M;
        string cleanAmount =
            superchat.AmountString?.Replace(",", "").Replace("€", "").Replace("$", "").Replace("£", "").Replace("¥", "").Trim() ?? "0";
        if (decimal.TryParse(cleanAmount, NumberStyles.Any, CultureInfo.InvariantCulture, out decimal parsedAmount))
        {
            amount = parsedAmount;
        }
        else
        {
            _logger.LogWarning("Could not parse SuperChat amount '{Amount}' after cleaning.", superchat.AmountString);
        }
        string currency = ParseCurrencyFromAmountString(superchat.AmountString);
        return new DonationEvent
        {
            Id = ytChatItem.Id,
            Platform = "YouTube",
            Timestamp = timestamp,
            OriginatingAccountId = originatingAccountId,
            DonationId = ytChatItem.Id,
            UserId = authorId,
            Username = authorName,
            Amount = amount,
            Currency = currency,
            RawMessage = rawUserComment,
            ParsedMessage = parsedUserComment,
            Type = donationType,
            Badges = badges,
            UsernameColor = usernameColor,
            ProfileImageUrl = profileImageUrl,
            IsOwner = isOwner,
            BodyBackgroundColor = FormatColor(superchat.BodyBackgroundColor),
            HeaderBackgroundColor = FormatColor(superchat.HeaderBackgroundColor),
            HeaderTextColor = FormatColor(superchat.HeaderTextColor),
            BodyTextColor = FormatColor(superchat.BodyTextColor),
            AuthorNameTextColor = FormatColor(superchat.AuthorNameTextColor),
            StickerImageUrl = superchat.Sticker?.Url,
            StickerAltText = superchat.Sticker?.Alt,
        };
    }
    private static List<BadgeInfo> MapYtAuthorToBadges(YTLiveChatChatItem chatItem)
    {
        var badges = new List<BadgeInfo>();
        if (chatItem == null)
            return badges;
        if (chatItem.IsOwner)
            badges.Add(new BadgeInfo("youtube/owner/1", null));
        if (chatItem.IsModerator)
            badges.Add(new BadgeInfo("youtube/moderator/1", null));
        if (chatItem.IsMembership)
            badges.Add(new BadgeInfo("youtube/member/1", chatItem.Author.Badge?.Thumbnail?.Url));
        if (chatItem.IsVerified)
            badges.Add(new BadgeInfo("youtube/verified/1", null));
        return badges;
    }
    private static List<MessageSegment> MapYtMessageParts(IEnumerable<YTLiveChatMessagePart>? parts)
    {
        if (parts == null)
            return [];
        List<MessageSegment> segments = [];
        foreach (YTLiveChatMessagePart part in parts)
        {
            if (part is YTLiveChat.Contracts.Models.TextPart tp)
            {
                if (!string.IsNullOrEmpty(tp.Text))
                {
                    segments.Add(new TextSegment { Text = WebUtility.HtmlDecode(tp.Text) });
                }
            }
            else if (part is YTLiveChat.Contracts.Models.EmojiPart ep)
            {
                segments.Add(
                    new EmoteSegment
                    {
                        Id = $"youtube_{ep.EmojiText}",
                        Name = ep.Alt ?? ep.EmojiText,
                        ImageUrl = ep.Url,
                        Platform = "YouTube",
                    }
                );
            }
            else if (part is YTLiveChat.Contracts.Models.ImagePart ip)
            {
                segments.Add(
                    new EmoteSegment
                    {
                        Id = $"youtube_img_{ip.Alt ?? "image"}",
                        Name = ip.Alt ?? "[image]",
                        ImageUrl = ip.Url,
                        Platform = "YouTube",
                    }
                );
            }
        }
        return segments;
    }
    private string ParseCurrencyFromAmountString(string? amountString)
    {
        if (string.IsNullOrWhiteSpace(amountString))
            return "USD";
        amountString = amountString.Trim();
        if (amountString.StartsWith('€'))
            return "EUR";
        if (amountString.StartsWith('$'))
            return "USD";
        if (amountString.StartsWith('£'))
            return "GBP";
        if (amountString.StartsWith('¥'))
            return "JPY";
        if (amountString.EndsWith(" USD"))
            return "USD";
        if (amountString.EndsWith(" EUR"))
            return "EUR";
        if (amountString.EndsWith(" GBP"))
            return "GBP";
        if (amountString.EndsWith(" JPY"))
            return "JPY";
        if (amountString.EndsWith(" CAD"))
            return "CAD";
        if (amountString.EndsWith(" AUD"))
            return "AUD";
        _logger.LogWarning("Could not determine currency from amount string: '{AmountString}'. Defaulting to USD.", amountString);
        return "USD";
    }
    private void UpdateWrapperStatus(YouTubeClientWrapper wrapper, ConnectionStatus status, string? message = null)
    {
        bool changed = wrapper.Status != status || wrapper.StatusMessage != (message ?? wrapper.StatusMessage);
        wrapper.Status = status;
        wrapper.StatusMessage = message ?? wrapper.StatusMessage;
        if (changed)
        {
            _logger.LogInformation(
                "[{AccountId}] Status updated: {ConnectionStatus} | Msg: {StatusMessage}",
                wrapper.AccountId,
                status,
                wrapper.StatusMessage
            );
            UpdateAccountModelStatus(wrapper.AccountId, status, wrapper.StatusMessage);
        }
        else
        {
            _logger.LogTrace(
                "[{AccountId}] Status update skipped (no change): {ConnectionStatus} | Msg: {StatusMessage}",
                wrapper.AccountId,
                status,
                wrapper.StatusMessage
            );
        }
    }
    private static bool IsQuotaError(GoogleApiException ex) =>
        ex.Error?.Errors?.Any(e => e.Reason == "quotaExceeded" || e.Reason == "rateLimitExceeded" || e.Domain == "usageLimits") ?? false;
    private void UpdateAccountModelStatus(string accountId, ConnectionStatus status, string? message)
    {
        YouTubeAccount? accountModel = _settingsService.CurrentSettings?.Connections?.YouTubeAccounts?.FirstOrDefault(a => a.ChannelId == accountId);
        if (accountModel != null)
        {
            bool changed = false;
            if (accountModel.Status != status)
            {
                accountModel.Status = status;
                changed = true;
            }
            if (accountModel.StatusMessage != message)
            {
                accountModel.StatusMessage = message;
                changed = true;
            }
            if (changed)
            {
                _logger.LogTrace(
                    "Updated UI Model status for YouTube {ChannelName}: {Status} ('{Message}')",
                    accountModel.ChannelName,
                    status,
                    message
                );
            }
        }
        else
        {
            _logger.LogWarning("Could not find YouTubeAccount model for ID {AccountId} to update UI status.", accountId);
        }
    }
    private static string? CalculateYouTubeUsernameColor(List<BadgeInfo> badges)
    {
        if (badges == null || badges.Count == 0)
            return null;
        string? highestPriorityColor = null;
        int highestPriority = -1;
        foreach (BadgeInfo badge in badges)
        {
            string[] parts = badge.Identifier.Split('/');
            if (parts.Length >= 2 && parts[0].Equals("youtube", StringComparison.OrdinalIgnoreCase))
            {
                string badgeName = parts[1];
                if (s_youTubeBadgeColorPriority.TryGetValue(badgeName, out (int Priority, string Color) priorityInfo))
                {
                    if (priorityInfo.Priority > highestPriority)
                    {
                        highestPriority = priorityInfo.Priority;
                        highestPriorityColor = priorityInfo.Color;
                    }
                }
            }
        }
        return highestPriorityColor;
    }
    private static string? FormatColor(string? color)
    {
        if (string.IsNullOrWhiteSpace(color))
            return null;
        if (color.StartsWith('#'))
            return color;
        if (color.Length == 6)
            return '#' + color;
        if (color.Length == 8)
        {
            return '#' + color;
        }
        return null;
    }
    public ConnectionStatus GetStatus(string accountId) =>
        _activeClients.TryGetValue(accountId, out YouTubeClientWrapper? wrapper) ? wrapper.Status : ConnectionStatus.Disconnected;
    public string? GetStatusMessage(string accountId) =>
        _activeClients.TryGetValue(accountId, out YouTubeClientWrapper? wrapper) ? wrapper.StatusMessage : "Account not connected";
    public string? GetActiveVideoId(string accountId) =>
        _activeClients.TryGetValue(accountId, out YouTubeClientWrapper? wrapper) ? wrapper.ActiveVideoId : null;
    public string? GetAssociatedLiveChatId(string accountId) =>
        _activeClients.TryGetValue(accountId, out YouTubeClientWrapper? wrapper) ? wrapper.AssociatedLiveChatId : null;
    public async Task DeleteMessageAsync(string moderatorAccountId, string messageId)
    {
        const string actionName = "DeleteMessage";
        if (!_activeClients.TryGetValue(moderatorAccountId, out YouTubeClientWrapper? wrapper))
        {
            _logger.LogWarning("[{AccountId}] Cannot {Action}, client wrapper not found.", moderatorAccountId, actionName);
            return;
        }
        if (wrapper.OfficialApiService == null)
        {
            _logger.LogError("[{AccountId}] Cannot {Action}, official API service instance is null.", moderatorAccountId, actionName);
            return;
        }
        if (wrapper.Status == ConnectionStatus.Limited)
        {
            _logger.LogWarning("[{AccountId}] Cannot {Action}: Client is in Limited (Read-Only) state.", moderatorAccountId, actionName);
            return;
        }
        _logger.LogInformation("[{AccountId}] Attempting {Action} for Message ID: {MessageId}", moderatorAccountId, actionName, messageId);
        try
        {
            LiveChatMessagesResource.DeleteRequest request = wrapper.OfficialApiService.LiveChatMessages.Delete(messageId);
            string emptyResponse = await request.ExecuteAsync();
            _logger.LogInformation("[{AccountId}] {Action} successful for Message ID: {MessageId}.", moderatorAccountId, actionName, messageId);
        }
        catch (GoogleApiException apiEx) when (IsQuotaError(apiEx))
        {
            _logger.LogWarning(apiEx, "[{AccountId}] Quota error during {Action}. Entering Limited state.", moderatorAccountId, actionName);
            UpdateWrapperStatus(wrapper, ConnectionStatus.Limited, "Read-Only (API Quota Reached)");
            _messenger.Send(new ConnectionsUpdatedMessage());
        }
        catch (GoogleApiException apiEx)
        {
            string errorDetail = apiEx.Error?.Message ?? apiEx.Message;
            _logger.LogError(
                apiEx,
                "[{AccountId}] API Error during {Action} for Message ID {MessageId}. Status: {StatusCode}, Message: {ErrorDetail}",
                moderatorAccountId,
                actionName,
                messageId,
                apiEx.HttpStatusCode,
                errorDetail
            );
            if (apiEx.HttpStatusCode == HttpStatusCode.Forbidden)
                _logger.LogWarning("--> Moderator likely lacks permission to delete this message.");
            else if (apiEx.HttpStatusCode == HttpStatusCode.NotFound)
                _logger.LogWarning("--> Message ID {MessageId} not found or already deleted.", messageId);
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex,
                "[{AccountId}] Unexpected error during {Action} for Message ID {MessageId}",
                moderatorAccountId,
                actionName,
                messageId
            );
        }
    }
    public async Task TimeoutUserAsync(string moderatorAccountId, string liveChatId, string userIdToTimeout, uint durationSeconds)
    {
        const string actionName = "TimeoutUser";
        if (!_activeClients.TryGetValue(moderatorAccountId, out YouTubeClientWrapper? wrapper))
        {
            _logger.LogWarning("[{AccountId}] Cannot {Action}, client wrapper not found.", moderatorAccountId, actionName);
            return;
        }
        if (wrapper.OfficialApiService == null)
        {
            _logger.LogError("[{AccountId}] Cannot {Action}, official API service instance is null.", moderatorAccountId, actionName);
            return;
        }
        if (wrapper.Status == ConnectionStatus.Limited)
        {
            _logger.LogWarning("[{AccountId}] Cannot {Action}: Client is in Limited (Read-Only) state.", moderatorAccountId, actionName);
            return;
        }
        _logger.LogInformation(
            "[{AccountId}] Attempting {Action} for User ID: {TargetUserId} in Chat ID: {LiveChatId} for {Duration}s",
            moderatorAccountId,
            actionName,
            userIdToTimeout,
            liveChatId,
            durationSeconds
        );
        var liveChatBan = new LiveChatBan
        {
            Snippet = new LiveChatBanSnippet
            {
                LiveChatId = liveChatId,
                Type = "temporary",
                BannedUserDetails = new ChannelProfileDetails { ChannelId = userIdToTimeout },
                BanDurationSeconds = durationSeconds,
            },
        };
        try
        {
            LiveChatBansResource.InsertRequest request = wrapper.OfficialApiService.LiveChatBans.Insert(liveChatBan, "snippet");
            LiveChatBan responseBan = await request.ExecuteAsync();
            _logger.LogInformation(
                "[{AccountId}] {Action} successful for User ID: {TargetUserId}. Ban ID: {BanId}",
                moderatorAccountId,
                actionName,
                userIdToTimeout,
                responseBan.Id
            );
        }
        catch (GoogleApiException apiEx) when (IsQuotaError(apiEx))
        {
            _logger.LogWarning(apiEx, "[{AccountId}] Quota error during {Action}. Entering Limited state.", moderatorAccountId, actionName);
            UpdateWrapperStatus(wrapper, ConnectionStatus.Limited, "Read-Only (API Quota Reached)");
            _messenger.Send(new ConnectionsUpdatedMessage());
        }
        catch (GoogleApiException apiEx)
        {
            string errorDetail = apiEx.Error?.Message ?? apiEx.Message;
            _logger.LogError(
                apiEx,
                "[{AccountId}] API Error during {Action} for User ID {TargetUserId}. Status: {StatusCode}, Message: {ErrorDetail}",
                moderatorAccountId,
                actionName,
                userIdToTimeout,
                apiEx.HttpStatusCode,
                errorDetail
            );
            if (apiEx.HttpStatusCode == HttpStatusCode.Forbidden)
                _logger.LogWarning("--> Moderator likely lacks permission to timeout this user.");
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex,
                "[{AccountId}] Unexpected error during {Action} for User ID {TargetUserId}",
                moderatorAccountId,
                actionName,
                userIdToTimeout
            );
        }
    }
    public async Task BanUserAsync(string moderatorAccountId, string liveChatId, string userIdToBan)
    {
        const string actionName = "BanUser";
        if (!_activeClients.TryGetValue(moderatorAccountId, out YouTubeClientWrapper? wrapper))
        {
            _logger.LogWarning("[{AccountId}] Cannot {Action}, client wrapper not found.", moderatorAccountId, actionName);
            return;
        }
        if (wrapper.OfficialApiService == null)
        {
            _logger.LogError("[{AccountId}] Cannot {Action}, official API service instance is null.", moderatorAccountId, actionName);
            return;
        }
        if (wrapper.Status == ConnectionStatus.Limited)
        {
            _logger.LogWarning("[{AccountId}] Cannot {Action}: Client is in Limited (Read-Only) state.", moderatorAccountId, actionName);
            return;
        }
        _logger.LogInformation(
            "[{AccountId}] Attempting {Action} for User ID: {TargetUserId} in Chat ID: {LiveChatId}",
            moderatorAccountId,
            actionName,
            userIdToBan,
            liveChatId
        );
        var liveChatBan = new LiveChatBan
        {
            Snippet = new LiveChatBanSnippet
            {
                LiveChatId = liveChatId,
                Type = "permanent",
                BannedUserDetails = new ChannelProfileDetails { ChannelId = userIdToBan },
            },
        };
        try
        {
            LiveChatBansResource.InsertRequest request = wrapper.OfficialApiService.LiveChatBans.Insert(liveChatBan, "snippet");
            LiveChatBan responseBan = await request.ExecuteAsync();
            _logger.LogInformation(
                "[{AccountId}] {Action} successful for User ID: {TargetUserId}. Ban ID: {BanId}",
                moderatorAccountId,
                actionName,
                userIdToBan,
                responseBan.Id
            );
        }
        catch (GoogleApiException apiEx) when (IsQuotaError(apiEx))
        {
            _logger.LogWarning(apiEx, "[{AccountId}] Quota error during {Action}. Entering Limited state.", moderatorAccountId, actionName);
            UpdateWrapperStatus(wrapper, ConnectionStatus.Limited, "Read-Only (API Quota Reached)");
            _messenger.Send(new ConnectionsUpdatedMessage());
        }
        catch (GoogleApiException apiEx)
        {
            string errorDetail = apiEx.Error?.Message ?? apiEx.Message;
            _logger.LogError(
                apiEx,
                "[{AccountId}] API Error during {Action} for User ID {TargetUserId}. Status: {StatusCode}, Message: {ErrorDetail}",
                moderatorAccountId,
                actionName,
                userIdToBan,
                apiEx.HttpStatusCode,
                errorDetail
            );
            if (apiEx.HttpStatusCode == HttpStatusCode.Forbidden)
                _logger.LogWarning("--> Moderator likely lacks permission to ban this user.");
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex,
                "[{AccountId}] Unexpected error during {Action} for User ID {TargetUserId}",
                moderatorAccountId,
                actionName,
                userIdToBan
            );
        }
    }
    public async Task<string?> CreatePollAsync(string moderatorAccountId, string liveChatId, string question, List<string> options)
    {
        const string actionName = "CreatePoll";
        if (string.IsNullOrWhiteSpace(question) || question.Length > 100)
        {
            _logger.LogError("[{AccountId}] Cannot {Action}: Invalid question (empty or >100 chars).", moderatorAccountId, actionName);
            return null;
        }
        if (options == null || options.Count < 2 || options.Count > 5)
        {
            _logger.LogError(
                "[{AccountId}] Cannot {Action}: Invalid options count ({Count}). Must be 2-5.",
                moderatorAccountId,
                actionName,
                options?.Count ?? 0
            );
            return null;
        }
        if (options.Any(opt => string.IsNullOrWhiteSpace(opt) || opt.Length > 30))
        {
            _logger.LogError("[{AccountId}] Cannot {Action}: One or more options are empty or >30 chars.", moderatorAccountId, actionName);
            return null;
        }
        if (!_activeClients.TryGetValue(moderatorAccountId, out YouTubeClientWrapper? wrapper))
        {
            _logger.LogWarning("[{AccountId}] Cannot {Action}, client wrapper not found.", moderatorAccountId, actionName);
            return null;
        }
        if (wrapper.OfficialApiService == null)
        {
            _logger.LogError("[{AccountId}] Cannot {Action}, official API service instance is null.", moderatorAccountId, actionName);
            return null;
        }
        if (wrapper.Status == ConnectionStatus.Limited)
        {
            _logger.LogWarning("[{AccountId}] Cannot {Action}: Client is in Limited (Read-Only) state.", moderatorAccountId, actionName);
            return null;
        }
        if (wrapper.Status != ConnectionStatus.Connected)
        {
            _logger.LogWarning(
                "[{AccountId}] Cannot {Action}: Client not connected (Status: {Status}).",
                moderatorAccountId,
                actionName,
                wrapper.Status
            );
            return null;
        }
        _logger.LogInformation(
            "[{AccountId}] Attempting {Action} in Chat ID: {LiveChatId} with Question: '{Question}'",
            moderatorAccountId,
            actionName,
            liveChatId,
            question
        );
        var pollMessage = new LiveChatMessage
        {
            Snippet = new LiveChatMessageSnippet
            {
                LiveChatId = liveChatId,
                Type = "newPollEvent",
                PollDetails = new LiveChatPollDetails
                {
                    Metadata = new LiveChatPollDetailsPollMetadata
                    {
                        QuestionText = question,
                        Options = [.. options.Select(opt => new LiveChatPollDetailsPollMetadataPollOption { OptionText = opt })],
                    },
                },
            },
        };
        try
        {
            LiveChatMessagesResource.InsertRequest request = wrapper.OfficialApiService.LiveChatMessages.Insert(pollMessage, "snippet");
            LiveChatMessage responseMessage = await request.ExecuteAsync();
            _logger.LogInformation(
                "[{AccountId}] {Action} successful. Poll Message ID: {PollMessageId}",
                moderatorAccountId,
                actionName,
                responseMessage.Id
            );
            return responseMessage.Id;
        }
        catch (GoogleApiException apiEx) when (IsQuotaError(apiEx))
        {
            _logger.LogWarning(apiEx, "[{AccountId}] Quota error during {Action}. Entering Limited state.", moderatorAccountId, actionName);
            UpdateWrapperStatus(wrapper, ConnectionStatus.Limited, "Read-Only (API Quota Reached)");
            _messenger.Send(new ConnectionsUpdatedMessage());
            return null;
        }
        catch (GoogleApiException apiEx)
        {
            string errorDetail = apiEx.Error?.Message ?? apiEx.Message;
            _logger.LogError(
                apiEx,
                "[{AccountId}] API Error during {Action}. Status: {StatusCode}, Message: {ErrorDetail}",
                moderatorAccountId,
                actionName,
                apiEx.HttpStatusCode,
                errorDetail
            );
            if (apiEx.HttpStatusCode == HttpStatusCode.Forbidden)
                _logger.LogWarning("--> Moderator likely lacks permission to create polls.");
            if (apiEx.HttpStatusCode == HttpStatusCode.BadRequest)
                _logger.LogWarning("--> Bad Request during poll creation. Check question/option lengths or format.");
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "[{AccountId}] Unexpected error during {Action}", moderatorAccountId, actionName);
            return null;
        }
    }
    public async Task<bool> EndPollAsync(string moderatorAccountId, string pollMessageId, string status = "ended")
    {
        const string actionName = "EndPoll";
        if (!_activeClients.TryGetValue(moderatorAccountId, out YouTubeClientWrapper? wrapper))
        {
            _logger.LogWarning("[{AccountId}] Cannot {Action}, client wrapper not found.", moderatorAccountId, actionName);
            return false;
        }
        if (wrapper.OfficialApiService == null)
        {
            _logger.LogError("[{AccountId}] Cannot {Action}, official API service instance is null.", moderatorAccountId, actionName);
            return false;
        }
        if (wrapper.Status == ConnectionStatus.Limited)
        {
            _logger.LogWarning("[{AccountId}] Cannot {Action}: Client is in Limited (Read-Only) state.", moderatorAccountId, actionName);
            return false;
        }
        if (wrapper.Status != ConnectionStatus.Connected)
        {
            _logger.LogWarning(
                "[{AccountId}] Cannot {Action}: Client not connected (Status: {Status}).",
                moderatorAccountId,
                actionName,
                wrapper.Status
            );
            return false;
        }
        _logger.LogInformation(
            "[{AccountId}] Attempting {Action} for Poll Message ID: {PollMessageId} to Status: '{Status}'",
            moderatorAccountId,
            actionName,
            pollMessageId,
            status
        );
        try
        {
            LiveChatMessagesResource.TransitionRequest request = wrapper.OfficialApiService.LiveChatMessages.Transition();
            request.Id = pollMessageId;
            request.Status = LiveChatMessagesResource.TransitionRequest.StatusEnum.Closed;
            LiveChatMessage responseMessage = await request.ExecuteAsync();
            _logger.LogInformation(
                "[{AccountId}] {Action} successful for Poll Message ID: {PollMessageId}. New Status: {NewStatus}",
                moderatorAccountId,
                actionName,
                pollMessageId,
                responseMessage.Snippet?.PollDetails.Status ?? "Unknown"
            );
            return true;
        }
        catch (GoogleApiException apiEx) when (IsQuotaError(apiEx))
        {
            _logger.LogWarning(apiEx, "[{AccountId}] Quota error during {Action}. Entering Limited state.", moderatorAccountId, actionName);
            UpdateWrapperStatus(wrapper, ConnectionStatus.Limited, "Read-Only (API Quota Reached)");
            _messenger.Send(new ConnectionsUpdatedMessage());
            return false;
        }
        catch (GoogleApiException apiEx)
        {
            string errorDetail = apiEx.Error?.Message ?? apiEx.Message;
            _logger.LogError(
                apiEx,
                "[{AccountId}] API Error during {Action} for Poll ID {PollMessageId}. Status: {StatusCode}, Message: {ErrorDetail}",
                moderatorAccountId,
                actionName,
                pollMessageId,
                apiEx.HttpStatusCode,
                errorDetail
            );
            if (apiEx.HttpStatusCode == HttpStatusCode.Forbidden)
                _logger.LogWarning("--> Moderator likely lacks permission to transition this poll.");
            if (apiEx.HttpStatusCode == HttpStatusCode.BadRequest)
                _logger.LogWarning("--> Bad Request during poll transition. Check if Poll ID is correct and transition is valid.");
            if (apiEx.HttpStatusCode == HttpStatusCode.NotFound)
                _logger.LogWarning("--> Poll Message ID {PollMessageId} not found.", pollMessageId);
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex,
                "[{AccountId}] Unexpected error during {Action} for Poll ID {PollMessageId}",
                moderatorAccountId,
                actionName,
                pollMessageId
            );
            return false;
        }
    }
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    protected virtual void Dispose(bool disposing)
    {
        if (_isDisposed)
            return;
        if (disposing)
        {
            _logger.LogInformation("Disposing YouTubeService...");
            var accountIds = _activeClients.Keys.ToList();
            foreach (string id in accountIds)
            {
                Task.Run(() => DisconnectAsync(id)).Wait(TimeSpan.FromSeconds(3));
            }
            _activeClients.Clear();
            _logger.LogInformation("YouTubeService disposed.");
        }
        _isDisposed = true;
    }
}
</file>

<file path="Core/Services/Tts/TtsFormattingService.cs">
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Models.Events;
using StreamWeaver.Core.Models.Events.Messages;
using StreamWeaver.Core.Models.Settings;
using TTSTextNormalization.Abstractions;
namespace StreamWeaver.Core.Services.Tts;
public partial class TtsFormattingService(ILogger<TtsFormattingService> logger, ITextNormalizer textNormalizer)
{
    private readonly ILogger<TtsFormattingService> _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    private readonly ITextNormalizer _textNormalizer = textNormalizer ?? throw new ArgumentNullException(nameof(textNormalizer));
    public string? FormatAndNormalizeEvent(BaseEvent eventData, TtsSettings settings)
    {
        ArgumentNullException.ThrowIfNull(eventData);
        ArgumentNullException.ThrowIfNull(settings);
        string? format = GetFormatString(eventData, settings);
        if (format is null)
        {
            _logger.LogTrace("No format configured or event filtered out for type {EventType}, formatting skipped.", eventData.GetType().Name);
            return null;
        }
        string rawFormattedMessage = FormatMessage(format, eventData);
        if (string.IsNullOrWhiteSpace(rawFormattedMessage))
        {
            _logger.LogTrace("Empty message generated after formatting for event type {EventType}, normalization skipped.", eventData.GetType().Name);
            return null;
        }
        string normalizedMessage = _textNormalizer.Normalize(rawFormattedMessage);
        _logger.LogDebug(
            "Formatted TTS message: \"{FormattedMessage}\", Normalized: \"{NormalizedMessage}\"",
            rawFormattedMessage,
            normalizedMessage
        );
        return normalizedMessage;
    }
    private static string? GetFormatString(BaseEvent eventData, TtsSettings settings) =>
        eventData switch
        {
            DonationEvent de when ShouldReadDonation(de, settings) => de.Type switch
            {
                DonationType.Bits => settings.BitsMessageFormat,
                DonationType.SuperChat or DonationType.SuperSticker => settings.SuperChatMessageFormat,
                _ => settings.DonationMessageFormat,
            },
            SubscriptionEvent se when settings.ReadTwitchSubs => (se.IsGift, se.GiftCount > 1, se.CumulativeMonths > 0) switch
            {
                (true, true, _) => settings.GiftBombMessageFormat,
                (true, false, _) => settings.GiftSubMessageFormat,
                (false, _, true) => settings.ResubMessageFormat,
                (false, _, false) => settings.NewSubMessageFormat,
            },
            MembershipEvent me => me.MembershipType switch
            {
                MembershipEventType.New when settings.ReadYouTubeNewMembers => settings.NewMemberMessageFormat,
                MembershipEventType.Milestone when settings.ReadYouTubeMilestones && me.MilestoneMonths >= settings.MinimumMilestoneMonthsToRead =>
                    settings.MemberMilestoneFormat,
                MembershipEventType.GiftPurchase when settings.ReadYouTubeGiftPurchases && me.GiftCount >= settings.MinimumGiftCountToRead =>
                    settings.GiftedMemberPurchaseFormat,
                MembershipEventType.GiftRedemption when settings.ReadYouTubeGiftRedemptions => settings.GiftedMemberRedemptionFormat,
                _ => null,
            },
            FollowEvent _ when settings.ReadFollows => settings.FollowMessageFormat,
            RaidEvent re when settings.ReadRaids && re.ViewerCount >= settings.MinimumRaidViewersToRead => settings.RaidMessageFormat,
            _ => null,
        };
    private static bool ShouldReadDonation(DonationEvent donation, TtsSettings settings) =>
        donation.Type switch
        {
            DonationType.Streamlabs or DonationType.Other => settings.ReadStreamlabsDonations
                && donation.Amount >= (decimal)settings.MinimumDonationAmountToRead,
            DonationType.SuperChat or DonationType.SuperSticker => settings.ReadSuperChats
                && donation.Amount >= (decimal)settings.MinimumSuperChatAmountToRead,
            DonationType.Bits => settings.ReadTwitchBits && donation.Amount >= settings.MinimumBitAmountToRead,
            _ => false,
        };
    private string FormatMessage(string format, BaseEvent eventData)
    {
        if (string.IsNullOrWhiteSpace(format))
        {
            _logger.LogWarning("FormatMessage called with empty format string for event type {EventType}.", eventData.GetType().Name);
            return string.Empty;
        }
        string LogUnhandledPlaceholderAndReturnEmpty(BaseEvent? evt, string? ph)
        {
            _logger.LogWarning(
                "TTS Format placeholder '{{{Placeholder}}}' not handled or not applicable for event type {EventType}.",
                ph,
                evt?.GetType().Name ?? "Unknown"
            );
            return string.Empty;
        }
        try
        {
            string processedMessage = PlaceholderRegex()
                .Replace(
                    format,
                    match =>
                    {
                        string placeholder = match.Groups[1].Value;
                        string? valueString = (eventData, placeholder.ToLowerInvariant()) switch
                        {
                            (DonationEvent { Username: var uname }, "username") => uname,
                            (SubscriptionEvent { Username: var uname }, "username") => uname,
                            (MembershipEvent { Username: var uname }, "username") => uname,
                            (FollowEvent { Username: var uname }, "username") => uname,
                            (RaidEvent { RaiderUsername: var rname }, "username") => rname,
                            (DonationEvent de, "amount") => $"{de.Amount} {de.Currency}",
                            (SubscriptionEvent { IsGift: true, GiftCount: var count } se, "amount") when count > 1 => $"{count:N0}",
                            (MembershipEvent { MembershipType: MembershipEventType.GiftPurchase, GiftCount: { } giftCount } me, "amount") =>
                                $"{giftCount:N0}",
                            (RaidEvent re, "amount") => $"{re.ViewerCount:N0}",
                            (DonationEvent { RawMessage: var msg }, "message") => msg,
                            (SubscriptionEvent { IsGift: false, Message: var msg }, "message") => msg,
                            (MembershipEvent { MembershipType: MembershipEventType.Milestone, ParsedMessage: var segments }, "message") =>
                                string.Join(" ", segments.OfType<TextSegment>().Select(ts => ts.Text)),
                            (SubscriptionEvent { IsGift: true, RecipientUsername: var rcp }, "recipient") => rcp,
                            (SubscriptionEvent { IsGift: false, CumulativeMonths: var m } se, "months") when m > 0 => m.ToString(),
                            (SubscriptionEvent { Tier: var t }, "tier") => t,
                            (MembershipEvent { MembershipType: MembershipEventType.Milestone, MilestoneMonths: { } mm }, "months") => mm.ToString(),
                            (MembershipEvent { LevelName: var lvl }, "tier") => lvl,
                            (MembershipEvent { MembershipType: MembershipEventType.GiftPurchase, GifterUsername: var gname }, "gifter") => gname,
                            var (evt, ph) => LogUnhandledPlaceholderAndReturnEmpty(evt, ph),
                        };
                        return valueString ?? string.Empty;
                    }
                );
            processedMessage = ConsecutiveSpacesRegex().Replace(processedMessage, " ");
            return processedMessage.Trim();
        }
        catch (RegexMatchTimeoutException rex)
        {
            _logger.LogError(rex, "Regex timed out during TTS format processing for event type {EventType}.", eventData.GetType().Name);
            return format;
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex,
                "Error processing TTS format string for event type {EventType}. Format: '{FormatString}'",
                eventData.GetType().Name,
                format
            );
            return string.Empty;
        }
    }
    [GeneratedRegex(@"\{(\w+)\}", RegexOptions.Compiled | RegexOptions.CultureInvariant, matchTimeoutMilliseconds: 200)]
    private static partial Regex PlaceholderRegex();
    [GeneratedRegex(@"\s{2,}", RegexOptions.Compiled, matchTimeoutMilliseconds: 100)]
    private static partial Regex ConsecutiveSpacesRegex();
}
</file>

<file path="UI/Converters/DonationToBrushConverter.cs">
using Microsoft.UI;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Media;
using StreamWeaver.Core.Models.Events;
using Windows.UI;
namespace StreamWeaver.UI.Converters;
public class DonationToBrushConverter : IValueConverter
{
    private static readonly SolidColorBrush s_defaultBrush = new(Colors.DodgerBlue);
    private static readonly SolidColorBrush s_bitsBrush = new(Colors.MediumPurple);
    private static readonly SolidColorBrush s_superChatBaseBrush = new(Colors.Gold);
    public bool IsBackgroundConverter { get; set; } = false;
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is not DonationEvent donation)
        {
            return GetFallbackBrush();
        }
        SolidColorBrush baseBrush = donation.Type switch
        {
            DonationType.SuperChat => GetSuperChatBrush(donation.Amount),
            DonationType.Bits => s_bitsBrush,
            DonationType.Streamlabs or DonationType.Other => s_defaultBrush,
            _ => s_defaultBrush,
        };
        if (IsBackgroundConverter && baseBrush is SolidColorBrush solidBrush)
        {
            Color color = solidBrush.Color;
            return new SolidColorBrush(Color.FromArgb(38, color.R, color.G, color.B));
        }
        return baseBrush;
    }
    private static SolidColorBrush GetSuperChatBrush(decimal amount) => amount >= 500
            ? new SolidColorBrush(Colors.Red)
            : amount >= 100
            ? new SolidColorBrush(Colors.Magenta)
            : amount >= 50
            ? new SolidColorBrush(Colors.Orange)
            : amount >= 20
            ? new SolidColorBrush(Colors.Yellow)
            : amount >= 5
            ? new SolidColorBrush(Colors.Green)
            : amount >= 2 ? new SolidColorBrush(Colors.Cyan) : new SolidColorBrush(Colors.Blue);
    private SolidColorBrush GetFallbackBrush()
    {
        if (IsBackgroundConverter)
        {
            Color color = s_defaultBrush.Color;
            return new SolidColorBrush(Color.FromArgb(38, color.R, color.G, color.B));
        }
        return s_defaultBrush;
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Converters/LogLevelToBrushConverter.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Media;
using Windows.UI;
namespace StreamWeaver.UI.Converters;
public partial class LogLevelToBrushConverter : IValueConverter
{
    private static readonly Color s_debugColor = Colors.Gray;
    private static readonly Color s_infoColor = Colors.CornflowerBlue;
    private static readonly Color s_warningColor = Colors.Orange;
    private static readonly Color s_errorColor = Colors.OrangeRed;
    private static readonly Color s_criticalColor = Colors.Red;
    private static readonly Color s_traceColor = Colors.DarkGray;
    private static readonly Color s_noneColor = Colors.Black;
    private static readonly SolidColorBrush s_debugBrush = new(s_debugColor);
    private static readonly SolidColorBrush s_infoBrush = new(s_infoColor);
    private static readonly SolidColorBrush s_warningBrush = new(s_warningColor);
    private static readonly SolidColorBrush s_errorBrush = new(s_errorColor);
    private static readonly SolidColorBrush s_criticalBrush = new(s_criticalColor);
    private static readonly SolidColorBrush s_traceBrush = new(s_traceColor);
    private static readonly SolidColorBrush s_noneBrush = new(s_noneColor);
    private static readonly SolidColorBrush s_defaultBrush = new(Colors.Transparent);
    private const byte SubtleAlpha = 0x1A;
    private static readonly SolidColorBrush s_debugBgBrush = new(Color.FromArgb(SubtleAlpha, s_debugColor.R, s_debugColor.G, s_debugColor.B));
    private static readonly SolidColorBrush s_infoBgBrush = new(Color.FromArgb(SubtleAlpha, s_infoColor.R, s_infoColor.G, s_infoColor.B));
    private static readonly SolidColorBrush s_warningBgBrush = new(Color.FromArgb(SubtleAlpha, s_warningColor.R, s_warningColor.G, s_warningColor.B));
    private static readonly SolidColorBrush s_errorBgBrush = new(Color.FromArgb(SubtleAlpha, s_errorColor.R, s_errorColor.G, s_errorColor.B));
    private static readonly SolidColorBrush s_criticalBgBrush = new(Color.FromArgb(SubtleAlpha, s_criticalColor.R, s_criticalColor.G, s_criticalColor.B));
    private static readonly SolidColorBrush s_traceBgBrush = new(Color.FromArgb(SubtleAlpha, s_traceColor.R, s_traceColor.G, s_traceColor.B));
    public object Convert(object value, Type targetType, object parameter, string language)
    {
        if (value is not LogLevel level)
        {
            return s_defaultBrush;
        }
        bool useSubtleBackground = parameter is string strParam && strParam.Equals("Background", StringComparison.OrdinalIgnoreCase);
        return useSubtleBackground
            ? level switch
            {
                LogLevel.Information => s_infoBgBrush,
                LogLevel.Debug => s_debugBgBrush,
                LogLevel.Warning => s_warningBgBrush,
                LogLevel.Error => s_errorBgBrush,
                LogLevel.Critical => s_criticalBgBrush,
                LogLevel.Trace => s_traceBgBrush,
                _ => s_defaultBrush
            }
            : (object)(level switch
            {
                LogLevel.Information => s_infoBrush,
                LogLevel.Debug => s_debugBrush,
                LogLevel.Warning => s_warningBrush,
                LogLevel.Error => s_errorBrush,
                LogLevel.Critical => s_criticalBrush,
                LogLevel.Trace => s_traceBrush,
                LogLevel.None => s_noneBrush,
                _ => s_defaultBrush
            });
    }
    public object ConvertBack(object value, Type targetType, object parameter, string language) => throw new NotImplementedException();
}
</file>

<file path="UI/Selectors/EventTemplateSelector.cs">
using System.Diagnostics;
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using StreamWeaver.Core.Models.Events;
namespace StreamWeaver.UI.Selectors;
public partial class EventTemplateSelector : DataTemplateSelector
{
    private static readonly Lazy<ILogger<EventTemplateSelector>?> s_lazyLogger = new(() =>
    {
        try
        {
            return App.GetService<ILogger<EventTemplateSelector>>();
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[EventTemplateSelector.StaticInit] Failed to get ILogger: {ex.Message}");
            return null;
        }
    });
    private static ILogger<EventTemplateSelector>? Logger => s_lazyLogger.Value;
    public DataTemplate? ChatMessageTemplate { get; set; }
    public DataTemplate? SubscriptionTemplate { get; set; }
    public DataTemplate? DonationTemplate { get; set; }
    public DataTemplate? MembershipTemplate { get; set; }
    public DataTemplate? FollowTemplate { get; set; }
    public DataTemplate? RaidTemplate { get; set; }
    public DataTemplate? HostTemplate { get; set; }
    public DataTemplate? SystemMessageTemplate { get; set; }
    public DataTemplate? ModerationActionTemplate { get; set; }
    public DataTemplate? WhisperTemplate { get; set; }
    public DataTemplate? BotMessageTemplate { get; set; }
    public DataTemplate? CommandInvocationTemplate { get; set; }
    public DataTemplate? YouTubePollUpdateTemplate { get; set; }
    public DataTemplate? DefaultTemplate { get; set; }
    protected override DataTemplate? SelectTemplateCore(object item) => SelectTemplateCore(item, null);
    protected override DataTemplate? SelectTemplateCore(object item, DependencyObject? container)
    {
        string itemType = item?.GetType().Name ?? "null";
        DataTemplate? selectedTemplate = item switch
        {
            ChatMessageEvent _ => ChatMessageTemplate,
            SubscriptionEvent _ => SubscriptionTemplate,
            DonationEvent _ => DonationTemplate,
            MembershipEvent _ => MembershipTemplate,
            FollowEvent _ => FollowTemplate,
            RaidEvent _ => RaidTemplate,
            HostEvent _ => HostTemplate,
            SystemMessageEvent _ => SystemMessageTemplate,
            YouTubePollUpdateEvent _ => YouTubePollUpdateTemplate,
            ModerationActionEvent _ => ModerationActionTemplate,
            WhisperEvent _ => WhisperTemplate,
            BotMessageEvent _ => BotMessageTemplate,
            CommandInvocationEvent _ => CommandInvocationTemplate,
            _ => DefaultTemplate,
        };
        string templateName = selectedTemplate switch
        {
            _ when selectedTemplate == ChatMessageTemplate => nameof(ChatMessageTemplate),
            _ when selectedTemplate == SubscriptionTemplate => nameof(SubscriptionTemplate),
            _ when selectedTemplate == DonationTemplate => nameof(DonationTemplate),
            _ when selectedTemplate == MembershipTemplate => nameof(MembershipTemplate),
            _ when selectedTemplate == FollowTemplate => nameof(FollowTemplate),
            _ when selectedTemplate == RaidTemplate => nameof(RaidTemplate),
            _ when selectedTemplate == HostTemplate => nameof(HostTemplate),
            _ when selectedTemplate == SystemMessageTemplate => nameof(SystemMessageTemplate),
            _ when selectedTemplate == YouTubePollUpdateTemplate => nameof(YouTubePollUpdateTemplate),
            _ when selectedTemplate == ModerationActionTemplate => nameof(ModerationActionTemplate),
            _ when selectedTemplate == WhisperTemplate => nameof(WhisperTemplate),
            _ when selectedTemplate == BotMessageTemplate => nameof(BotMessageTemplate),
            _ when selectedTemplate == CommandInvocationTemplate => nameof(CommandInvocationTemplate),
            _ when selectedTemplate == DefaultTemplate => nameof(DefaultTemplate),
            _ => "Unknown/Null",
        };
        Logger?.LogTrace("SelectTemplateCore for item type '{ItemType}' returned template: {TemplateName}", itemType, templateName);
        return selectedTemplate ?? DefaultTemplate ?? base.SelectTemplateCore(item, container);
    }
}
</file>

<file path="UI/ViewModels/SettingsViewModel.cs">
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using CommunityToolkit.WinUI;
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using StreamWeaver.Core.Messaging;
using StreamWeaver.Core.Models.Settings;
using StreamWeaver.Core.Plugins;
using StreamWeaver.Core.Services;
using StreamWeaver.Core.Services.Authentication;
using StreamWeaver.Core.Services.Platforms;
using StreamWeaver.Core.Services.Settings;
using StreamWeaver.Core.Services.Tts;
using StreamWeaver.Core.Services.Web;
using StreamWeaver.Modules.Goals;
using StreamWeaver.Modules.Subathon;
using Windows.ApplicationModel.DataTransfer;
using Windows.System;
using DispatcherQueue = Microsoft.UI.Dispatching.DispatcherQueue;
namespace StreamWeaver.UI.ViewModels;
public class SettingsSection
{
    public required string Name { get; init; }
    public required string Glyph { get; init; }
    public required string Tag { get; init; }
}
public partial class SettingsViewModel : ObservableObject, IRecipient<ConnectionsUpdatedMessage>, IDisposable
{
    private readonly ILogger<SettingsViewModel> _logger;
    private readonly ISettingsService _settingsService;
    private readonly ITtsService _ttsService;
    private readonly UnifiedEventService _unifiedEventService;
    private readonly IMessenger _messenger;
    private readonly IStreamlabsClient _streamlabsClient;
    private readonly ITokenStorageService _tokenStorage;
    private readonly ITwitchClient _twitchClient;
    private readonly IYouTubeClient _youTubeClient;
    private readonly PluginService _pluginService;
    private readonly DispatcherQueue _dispatcherQueue;
    private bool _isDisposed = false;
    [ObservableProperty]
    public partial ObservableCollection<string> WindowsVoices { get; set; } = [];
    [ObservableProperty]
    public partial ObservableCollection<string> KokoroVoices { get; set; } = [];
    public ObservableCollection<string> TtsEngineOptions { get; } = [TtsSettings.WindowsEngine, TtsSettings.KokoroEngine];
    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(TestTtsCommand))]
    public partial string? TtsTestPhrase { get; set; } = "This is a test of the text to speech engine.";
    [ObservableProperty]
    public partial string ChatOverlayUrl { get; set; } = string.Empty;
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanDisableStreamlabs))]
    [NotifyCanExecuteChangedFor(nameof(DisableStreamlabsCommand))]
    public partial ConnectionStatus StreamlabsStatus { get; set; } = ConnectionStatus.Disconnected;
    [ObservableProperty]
    public partial string? StreamlabsStatusMessage { get; set; }
    [ObservableProperty]
    public partial ObservableCollection<SettingsSection> SettingsSections { get; set; } = [];
    [ObservableProperty]
    public partial SettingsSection? SelectedSection { get; set; }
    public ReadOnlyObservableCollection<IPlugin> LoadedPlugins { get; init; }
    public AppSettings CurrentSettings => _settingsService.CurrentSettings;
    public ApiCredentials Credentials => CurrentSettings.Credentials;
    public ConnectionSettings Connections => CurrentSettings.Connections;
    public TtsSettings TtsSettings => CurrentSettings.TextToSpeech;
    public OverlaySettings OverlaySettings => CurrentSettings.Overlays;
    public ModuleSettings ModuleSettings => CurrentSettings.Modules;
    public ObservableCollection<TwitchAccount> TwitchAccounts => Connections.TwitchAccounts;
    public ObservableCollection<YouTubeAccount> YouTubeAccounts => Connections.YouTubeAccounts;
    public bool IsTwitchConfigured => Credentials.IsTwitchConfigured;
    public bool IsYouTubeConfigured => Credentials.IsYouTubeConfigured;
    public bool IsStreamlabsTokenSetup => !string.IsNullOrEmpty(Connections.StreamlabsTokenId);
    public bool CanDisableStreamlabs => Connections.EnableStreamlabs || StreamlabsStatus != ConnectionStatus.Disconnected;
    public string SelectedEngine
    {
        get => TtsSettings.SelectedEngine;
        set
        {
            if (TtsSettings.SelectedEngine != value)
            {
                TtsSettings.SelectedEngine = value;
                OnPropertyChanged();
                OnPropertyChanged(nameof(TtsSettings));
                SelectedEngineChanged();
            }
        }
    }
    public string? SelectedWindowsVoice
    {
        get => TtsSettings.SelectedWindowsVoice;
        set
        {
            if (TtsSettings.SelectedWindowsVoice != value)
            {
                TtsSettings.SelectedWindowsVoice = value;
                OnPropertyChanged();
                OnPropertyChanged(nameof(TtsSettings));
                if (SelectedEngine == TtsSettings.WindowsEngine && value != null)
                {
                    _ttsService.SetWindowsVoice(value);
                }
            }
        }
    }
    public string? SelectedKokoroVoice
    {
        get => TtsSettings.SelectedKokoroVoice;
        set
        {
            if (TtsSettings.SelectedKokoroVoice != value)
            {
                TtsSettings.SelectedKokoroVoice = value;
                OnPropertyChanged();
                OnPropertyChanged(nameof(TtsSettings));
                if (SelectedEngine == TtsSettings.KokoroEngine && value != null)
                {
                    _ttsService.SetKokoroVoice(value);
                }
            }
        }
    }
    public SettingsViewModel(
        ILogger<SettingsViewModel> logger,
        ISettingsService settingsService,
        ITtsService ttsService,
        UnifiedEventService unifiedEventService,
        IMessenger messenger,
        IStreamlabsClient streamlabsClient,
        ITokenStorageService tokenStorageService,
        ITwitchClient twitchClient,
        IYouTubeClient youTubeClient,
        PluginService pluginService,
        DispatcherQueue dispatcherQueue
    )
    {
        _logger = logger;
        _settingsService = settingsService;
        _ttsService = ttsService;
        _unifiedEventService = unifiedEventService;
        _messenger = messenger;
        _streamlabsClient = streamlabsClient;
        _tokenStorage = tokenStorageService;
        _twitchClient = twitchClient;
        _youTubeClient = youTubeClient;
        _pluginService = pluginService;
        _dispatcherQueue = dispatcherQueue;
        _logger.LogInformation("Initializing SettingsViewModel.");
        LoadedPlugins = new ReadOnlyObservableCollection<IPlugin>(_pluginService.LoadedPlugins);
        SettingsSections.Add(
            new SettingsSection
            {
                Name = "Credentials",
                Glyph = "\uE72E",
                Tag = "Credentials",
            }
        );
        SettingsSections.Add(
            new SettingsSection
            {
                Name = "Accounts",
                Glyph = "\uE77B",
                Tag = "Accounts",
            }
        );
        SettingsSections.Add(
            new SettingsSection
            {
                Name = "Overlays",
                Glyph = "\uE7F4",
                Tag = "Overlays",
            }
        );
        SettingsSections.Add(
            new SettingsSection
            {
                Name = "Text-to-Speech",
                Glyph = "\uE767",
                Tag = "TTS",
            }
        );
        SettingsSections.Add(
            new SettingsSection
            {
                Name = "Modules",
                Glyph = "\uE737",
                Tag = "Modules",
            }
        );
        SettingsSections.Add(
            new SettingsSection
            {
                Name = "Plugins",
                Glyph = "\uE70E",
                Tag = "Plugins",
            }
        );
        SelectedSection = SettingsSections.FirstOrDefault();
        NotifyAllPropertiesChanged();
        LoadInitialTtsVoices();
        UpdateStreamlabsStatus();
        HookPropertyListeners();
        UpdateOverlayUrl();
        _settingsService.SettingsUpdated += SettingsService_SettingsUpdated;
        _messenger.Register(this);
        _logger.LogDebug("Subscribed to SettingsService.SettingsUpdated event.");
    }
    private async void SettingsService_SettingsUpdated(object? sender, EventArgs e)
    {
        _logger.LogInformation("SettingsService_SettingsUpdated event received. Refreshing ViewModel state.");
        await _dispatcherQueue.EnqueueAsync(() =>
        {
            if (_isDisposed)
                return;
            NotifyAllPropertiesChanged();
            RefreshAccountStatuses();
        });
    }
    public async void Receive(ConnectionsUpdatedMessage message)
    {
        _logger.LogInformation("ConnectionsUpdatedMessage received. Refreshing account statuses.");
        await _dispatcherQueue.EnqueueAsync(() =>
        {
            if (!_isDisposed)
                RefreshAccountStatuses();
        });
    }
    private void RefreshAccountStatuses()
    {
        if (_isDisposed)
            return;
        _logger.LogDebug("Refreshing Twitch and YouTube account statuses...");
        if (Connections?.TwitchAccounts != null)
        {
            foreach (TwitchAccount acc in Connections.TwitchAccounts)
            {
                if (!string.IsNullOrEmpty(acc.UserId))
                {
                    ConnectionStatus currentStatus = _twitchClient.GetStatus(acc.UserId);
                    string? currentMessage = _twitchClient.GetStatusMessage(acc.UserId);
                    if (acc.Status != currentStatus || acc.StatusMessage != currentMessage)
                    {
                        acc.Status = currentStatus;
                        acc.StatusMessage = currentMessage;
                        _logger.LogTrace(
                            "Updated Twitch account {Username} status to {Status} ('{Message}')",
                            acc.Username,
                            currentStatus,
                            currentMessage
                        );
                    }
                }
            }
        }
        if (Connections?.YouTubeAccounts != null)
        {
            foreach (YouTubeAccount acc in Connections.YouTubeAccounts)
            {
                if (!string.IsNullOrEmpty(acc.ChannelId))
                {
                    ConnectionStatus currentStatus = _youTubeClient.GetStatus(acc.ChannelId);
                    string? currentMessage = _youTubeClient.GetStatusMessage(acc.ChannelId);
                    if (acc.Status != currentStatus || acc.StatusMessage != currentMessage)
                    {
                        acc.Status = currentStatus;
                        acc.StatusMessage = currentMessage;
                        _logger.LogTrace(
                            "Updated YouTube account {ChannelName} status to {Status} ('{Message}')",
                            acc.ChannelName,
                            currentStatus,
                            currentMessage
                        );
                    }
                }
            }
        }
        _logger.LogDebug("Account status refresh complete.");
    }
    private void NotifyAllPropertiesChanged()
    {
        _logger.LogTrace("Notifying all derived properties changed.");
        OnPropertyChanged(nameof(CurrentSettings));
        OnPropertyChanged(nameof(Credentials));
        OnPropertyChanged(nameof(Connections));
        OnPropertyChanged(nameof(TtsSettings));
        OnPropertyChanged(nameof(SelectedEngine));
        OnPropertyChanged(nameof(SelectedWindowsVoice));
        OnPropertyChanged(nameof(SelectedKokoroVoice));
        OnPropertyChanged(nameof(OverlaySettings));
        OnPropertyChanged(nameof(ModuleSettings));
        OnPropertyChanged(nameof(TwitchAccounts));
        OnPropertyChanged(nameof(YouTubeAccounts));
        OnPropertyChanged(nameof(IsTwitchConfigured));
        OnPropertyChanged(nameof(IsYouTubeConfigured));
        OnPropertyChanged(nameof(IsStreamlabsTokenSetup));
        OnPropertyChanged(nameof(CanDisableStreamlabs));
        UpdateOverlayUrl();
        NotifyCommandCanExecuteChanged();
    }
    private void HookPropertyListeners()
    {
        _logger.LogTrace("Hooking property listeners.");
        UnhookPropertyListeners();
        if (Credentials != null)
            Credentials.PropertyChanged += NestedSetting_PropertyChanged;
        if (Connections != null)
            Connections.PropertyChanged += NestedSetting_PropertyChanged;
        if (TtsSettings != null)
            TtsSettings.PropertyChanged += NestedSetting_PropertyChanged;
        if (OverlaySettings != null)
            OverlaySettings.PropertyChanged += NestedSetting_PropertyChanged;
        if (OverlaySettings?.Chat != null)
            OverlaySettings.Chat.PropertyChanged += NestedSetting_PropertyChanged;
        if (ModuleSettings != null)
            ModuleSettings.PropertyChanged += NestedSetting_PropertyChanged;
        if (ModuleSettings?.Subathon != null)
            ModuleSettings.Subathon.PropertyChanged += NestedSetting_PropertyChanged;
        if (ModuleSettings?.Goals != null)
            ModuleSettings.Goals.PropertyChanged += NestedSetting_PropertyChanged;
        if (_streamlabsClient is INotifyPropertyChanged slNotifier)
        {
            slNotifier.PropertyChanged += StreamlabsClient_PropertyChanged;
        }
    }
    private void UnhookPropertyListeners()
    {
        _logger.LogTrace("Unhooking property listeners.");
        if (Credentials != null)
            Credentials.PropertyChanged -= NestedSetting_PropertyChanged;
        if (Connections != null)
            Connections.PropertyChanged -= NestedSetting_PropertyChanged;
        if (TtsSettings != null)
            TtsSettings.PropertyChanged -= NestedSetting_PropertyChanged;
        if (OverlaySettings != null)
            OverlaySettings.PropertyChanged -= NestedSetting_PropertyChanged;
        if (OverlaySettings?.Chat != null)
            OverlaySettings.Chat.PropertyChanged -= NestedSetting_PropertyChanged;
        if (ModuleSettings != null)
            ModuleSettings.PropertyChanged -= NestedSetting_PropertyChanged;
        if (ModuleSettings?.Subathon != null)
            ModuleSettings.Subathon.PropertyChanged -= NestedSetting_PropertyChanged;
        if (ModuleSettings?.Goals != null)
            ModuleSettings.Goals.PropertyChanged -= NestedSetting_PropertyChanged;
        if (_streamlabsClient is INotifyPropertyChanged slNotifier)
        {
            slNotifier.PropertyChanged -= StreamlabsClient_PropertyChanged;
        }
    }
    private void NestedSetting_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (_isDisposed)
            return;
        _logger.LogTrace(
            "NestedSetting_PropertyChanged: Sender={SenderType}, Property={PropertyName}",
            sender?.GetType().Name ?? "null",
            e.PropertyName
        );
        switch (sender)
        {
            case ApiCredentials:
                OnPropertyChanged(nameof(IsTwitchConfigured));
                OnPropertyChanged(nameof(IsYouTubeConfigured));
                ConnectTwitchAccountCommand.NotifyCanExecuteChanged();
                ConnectYouTubeAccountCommand.NotifyCanExecuteChanged();
                break;
            case ConnectionSettings:
                if (e.PropertyName is nameof(ConnectionSettings.EnableStreamlabs) or nameof(ConnectionSettings.StreamlabsTokenId))
                {
                    OnPropertyChanged(nameof(IsStreamlabsTokenSetup));
                    DisableStreamlabsCommand.NotifyCanExecuteChanged();
                }
                break;
            case OverlaySettings _:
                if (e.PropertyName == nameof(OverlaySettings.WebServerPort))
                    UpdateOverlayUrl();
                _messenger.Send(new OverlaySettingsUpdateMessage(OverlaySettings));
                break;
            case ChatOverlaySettings:
                _logger.LogDebug("ChatOverlaySettings changed ({PropertyName}), sending update message.", e.PropertyName);
                _messenger.Send(new OverlaySettingsUpdateMessage(OverlaySettings));
                break;
            case TtsSettings ttsSettings:
                if (e.PropertyName == nameof(TtsSettings.Enabled))
                {
                    TestTtsCommand.NotifyCanExecuteChanged();
                    if (ttsSettings.Enabled && WindowsVoices.Count == 0 && KokoroVoices.Count == 0)
                    {
                        LoadInitialTtsVoices();
                    }
                }
                else if (e.PropertyName == nameof(TtsSettings.SelectedEngine))
                {
                    OnPropertyChanged(nameof(SelectedEngine));
                    SelectedEngineChanged();
                }
                else if (e.PropertyName == nameof(TtsSettings.SelectedWindowsVoice))
                {
                    OnPropertyChanged(nameof(SelectedWindowsVoice));
                    if (SelectedEngine == TtsSettings.WindowsEngine)
                        ApplyVoiceSetting();
                }
                else if (e.PropertyName == nameof(TtsSettings.SelectedKokoroVoice))
                {
                    OnPropertyChanged(nameof(SelectedKokoroVoice));
                    if (SelectedEngine == TtsSettings.KokoroEngine)
                        ApplyVoiceSetting();
                }
                else if (e.PropertyName == nameof(TtsSettings.Rate))
                {
                    _ttsService.SetRate(ttsSettings.Rate);
                }
                else if (e.PropertyName == nameof(TtsSettings.Volume))
                {
                    _ttsService.SetVolume(ttsSettings.Volume);
                }
                break;
            case ModuleSettings _:
                break;
            case SubathonSettings:
                break;
            case GoalSettings:
                break;
            default:
                _logger.LogTrace("Unhandled sender type in NestedSetting_PropertyChanged: {SenderType}", sender?.GetType().Name ?? "null");
                break;
        }
    }
    private async void StreamlabsClient_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (_isDisposed)
            return;
        if (e.PropertyName is nameof(IStreamlabsClient.Status) or nameof(IStreamlabsClient.StatusMessage))
        {
            _logger.LogTrace("StreamlabsClient_PropertyChanged: {PropertyName}. Queueing status update.", e.PropertyName);
            await _dispatcherQueue.EnqueueAsync(() =>
            {
                if (!_isDisposed)
                    UpdateStreamlabsStatus();
            });
        }
    }
    private void UpdateStreamlabsStatus()
    {
        StreamlabsStatus = _streamlabsClient.Status;
        StreamlabsStatusMessage = _streamlabsClient.StatusMessage;
        _logger.LogDebug("Updated Streamlabs Status UI: {Status}, Message: '{Message}'", StreamlabsStatus, StreamlabsStatusMessage);
    }
    private void NotifyCommandCanExecuteChanged()
    {
        _logger.LogTrace("Notifying CanExecuteChanged for commands.");
        ConnectTwitchAccountCommand.NotifyCanExecuteChanged();
        ConnectYouTubeAccountCommand.NotifyCanExecuteChanged();
        DisableStreamlabsCommand.NotifyCanExecuteChanged();
        ConnectAllCommand.NotifyCanExecuteChanged();
        DisconnectAllCommand.NotifyCanExecuteChanged();
        SaveSettingsCommand.NotifyCanExecuteChanged();
        TestTtsCommand.NotifyCanExecuteChanged();
        CopyOverlayUrlCommand.NotifyCanExecuteChanged();
        SetupStreamlabsTokenCommand.NotifyCanExecuteChanged();
    }
    private void LoadInitialTtsVoices()
    {
        if (SelectedEngine == TtsSettings.KokoroEngine)
        {
            _ = LoadKokoroVoicesAsync();
        }
        else
        {
            _ = LoadWindowsVoicesAsync();
        }
    }
    private async void SelectedEngineChanged()
    {
        _logger.LogInformation("Selected TTS Engine changed to: {Engine}", SelectedEngine);
        if (SelectedEngine == TtsSettings.KokoroEngine)
        {
            await LoadKokoroVoicesAsync();
        }
        else
        {
            await LoadWindowsVoicesAsync();
        }
        ApplyVoiceSetting();
    }
    private void ApplyVoiceSetting()
    {
        if (_isDisposed)
            return;
        try
        {
            if (SelectedEngine == TtsSettings.KokoroEngine && !string.IsNullOrEmpty(SelectedKokoroVoice))
            {
                _ttsService.SetKokoroVoice(SelectedKokoroVoice);
            }
            else if (SelectedEngine == TtsSettings.WindowsEngine && !string.IsNullOrEmpty(SelectedWindowsVoice))
            {
                _ttsService.SetWindowsVoice(SelectedWindowsVoice);
            }
            else
            {
                _logger.LogDebug("No specific voice selected for engine {Engine} or voice is null.", SelectedEngine);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error applying selected voice setting for engine {Engine}.", SelectedEngine);
        }
    }
    private async Task LoadWindowsVoicesAsync()
    {
        if (_isDisposed)
            return;
        _logger.LogInformation("Loading Windows TTS voices via Composite Service...");
        try
        {
            IEnumerable<string> installedVoices = await _ttsService.GetInstalledWindowsVoicesAsync();
            await _dispatcherQueue.EnqueueAsync(() =>
            {
                if (_isDisposed)
                    return;
                WindowsVoices.Clear();
                string? currentSelected = SelectedWindowsVoice;
                if (installedVoices.Any())
                {
                    foreach (string voice in installedVoices)
                        WindowsVoices.Add(voice);
                    bool selectionStillValid = WindowsVoices.Contains(currentSelected ?? "");
                    _logger.LogDebug("Loaded {Count} Windows TTS voices.", WindowsVoices.Count);
                    if (!selectionStillValid && WindowsVoices.Any())
                    {
                        // Update the TtsSettings model property directly
                        TtsSettings.SelectedWindowsVoice = WindowsVoices.FirstOrDefault();
                        // Notify the UI that the underlying setting changed
                        OnPropertyChanged(nameof(SelectedWindowsVoice));
                    }
                }
                else
                {
                    _logger.LogWarning("No installed Windows TTS voices found.");
                    TtsSettings.SelectedWindowsVoice = null;
                    OnPropertyChanged(nameof(SelectedWindowsVoice));
                }
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error loading Windows TTS voices.");
            await _dispatcherQueue.EnqueueAsync(() =>
            {
                if (_isDisposed)
                    return;
                WindowsVoices.Clear();
                TtsSettings.SelectedWindowsVoice = null;
                OnPropertyChanged(nameof(SelectedWindowsVoice));
            });
        }
    }
    /// <summary>
    /// Loads available Kokoro TTS voices from the TTS service.
    /// </summary>
    private async Task LoadKokoroVoicesAsync()
    {
        if (_isDisposed)
            return;
        _logger.LogInformation("Loading Kokoro TTS voices via Composite Service...");
        try
        {
            // Use the composite service method
            IEnumerable<string> installedVoices = await _ttsService.GetInstalledKokoroVoicesAsync();
            await _dispatcherQueue.EnqueueAsync(() =>
            {
                if (_isDisposed)
                    return;
                KokoroVoices.Clear();
                string? currentSelected = SelectedKokoroVoice;
                if (installedVoices.Any())
                {
                    foreach (string voice in installedVoices)
                        KokoroVoices.Add(voice);
                    bool selectionStillValid = KokoroVoices.Contains(currentSelected ?? "");
                    _logger.LogDebug("Loaded {Count} Kokoro TTS voices.", KokoroVoices.Count);
                    if (!selectionStillValid && KokoroVoices.Any())
                    {
                        TtsSettings.SelectedKokoroVoice = KokoroVoices.FirstOrDefault();
                        OnPropertyChanged(nameof(SelectedKokoroVoice));
                    }
                }
                else
                {
                    _logger.LogWarning("No installed Kokoro TTS voices found (or loading not implemented).");
                    TtsSettings.SelectedKokoroVoice = null;
                    OnPropertyChanged(nameof(SelectedKokoroVoice));
                }
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error loading Kokoro TTS voices.");
            await _dispatcherQueue.EnqueueAsync(() =>
            {
                if (_isDisposed)
                    return;
                KokoroVoices.Clear();
                TtsSettings.SelectedKokoroVoice = null;
                OnPropertyChanged(nameof(SelectedKokoroVoice));
            });
        }
    }
    /// <summary>
    /// Command to test the Text-to-Speech configuration using the currently selected engine, voice,
    /// and the text provided in the TtsTestPhrase property.
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanTestTts))]
    private async Task TestTtsAsync()
    {
        // Use MemberNotNullWhen guard for cleaner null checks
        [MemberNotNullWhen(true, nameof(TtsTestPhrase))]
        bool HasTestPhrase() => !string.IsNullOrWhiteSpace(TtsTestPhrase);
        if (!TtsSettings.Enabled)
        {
            _logger.LogInformation("Test TTS requested but TTS is currently disabled.");
            return;
        }
        if (!HasTestPhrase())
        {
            _logger.LogInformation("Test TTS requested but no test phrase entered.");
            return;
        }
        string voiceToUse = (SelectedEngine == TtsSettings.KokoroEngine ? SelectedKokoroVoice : SelectedWindowsVoice) ?? "Default";
        _logger.LogInformation(
            "Testing TTS with Engine: {Engine}, Voice: '{SelectedVoice}', Rate: {Rate}, Volume: {Volume}, Phrase: '{Phrase}'",
            SelectedEngine,
            voiceToUse,
            TtsSettings.Rate,
            TtsSettings.Volume,
            TtsTestPhrase
        );
        await _ttsService.SpeakAsync(TtsTestPhrase);
    }
    private bool CanTestTts() => TtsSettings.Enabled;
    private void UpdateOverlayUrl()
    {
        ChatOverlayUrl = $"http://localhost:{CurrentSettings.Overlays.WebServerPort}/chat";
        _logger.LogDebug("Chat Overlay URL updated: {Url}", ChatOverlayUrl);
        CopyOverlayUrlCommand.NotifyCanExecuteChanged();
    }
    [RelayCommand]
    private async Task SaveSettingsAsync()
    {
        _logger.LogInformation("Saving settings...");
        await _settingsService.SaveSettingsAsync(CurrentSettings);
        _messenger.Send(new OverlaySettingsUpdateMessage(CurrentSettings.Overlays));
    }
    [RelayCommand]
    private static async Task OpenUrlAsync(string? url)
    {
        ILogger<SettingsViewModel> logger = App.GetService<ILogger<SettingsViewModel>>();
        if (!Uri.TryCreate(url, UriKind.Absolute, out Uri? uri))
        {
            logger?.LogWarning("Invalid URL format provided to OpenUrlAsync: {Url}", url);
            return;
        }
        try
        {
            logger?.LogInformation("Opening URL: {Url}", url);
            await Launcher.LaunchUriAsync(uri);
        }
        catch (Exception ex)
        {
            logger?.LogError(ex, "Error opening URL {Url}", url);
        }
    }
    [RelayCommand]
    private void CopyOverlayUrl(string? overlayType)
    {
        string urlToCopy = overlayType?.ToLowerInvariant() switch
        {
            "chat" => ChatOverlayUrl,
            _ => string.Empty,
        };
        if (string.IsNullOrEmpty(urlToCopy))
        {
            _logger.LogWarning("CopyOverlayUrl called with invalid/unsupported type or URL is empty: {OverlayType}", overlayType ?? "null");
            return;
        }
        try
        {
            DataPackage dataPackage = new() { RequestedOperation = DataPackageOperation.Copy };
            dataPackage.SetText(urlToCopy);
            Clipboard.SetContent(dataPackage);
            _logger.LogInformation("Copied overlay URL to clipboard: {Url}", urlToCopy);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to copy URL to clipboard: {Url}", urlToCopy);
        }
    }
    [RelayCommand(CanExecute = nameof(IsTwitchConfigured))]
    private async Task ConnectTwitchAccountAsync()
    {
        _logger.LogInformation("ConnectTwitchAccount command executed.");
        try
        {
            await _unifiedEventService.TriggerTwitchLoginAsync();
            _logger.LogInformation("Twitch login flow initiated via UnifiedEventService.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error initiating Twitch login flow.");
        }
        finally
        {
        }
    }
    [RelayCommand]
    private async Task RemoveTwitchAccountAsync(TwitchAccount? accountToRemove)
    {
        if (accountToRemove?.UserId == null)
            return;
        string userId = accountToRemove.UserId;
        string username = accountToRemove.Username;
        _logger.LogInformation("Removing Twitch account: {Username} ({UserId})", username, userId);
        try
        {
            await _unifiedEventService.LogoutTwitchAccountAsync(userId);
            bool removed = false;
            await _dispatcherQueue.EnqueueAsync(() =>
            {
                removed = CurrentSettings.Connections.TwitchAccounts.Remove(accountToRemove);
                if (removed)
                {
                    _logger.LogInformation("Removed {Username} from settings collection.", username);
                }
                else
                {
                    _logger.LogWarning("Failed to remove {Username} from settings collection (already removed?).", username);
                }
            });
            if (removed)
            {
                await SaveSettingsAsync();
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error removing Twitch {Username}", username);
        }
        finally
        {
            _messenger.Send(new ConnectionsUpdatedMessage());
        }
    }
    [RelayCommand(CanExecute = nameof(IsYouTubeConfigured))]
    private async Task ConnectYouTubeAccountAsync()
    {
        _logger.LogInformation("ConnectYouTubeAccount command executed.");
        try
        {
            await _unifiedEventService.TriggerYouTubeLoginAsync();
            _logger.LogInformation("YouTube login flow initiated via UnifiedEventService.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error initiating YouTube login flow.");
        }
        finally
        {
        }
    }
    [RelayCommand]
    private async Task RemoveYouTubeAccountAsync(YouTubeAccount? accountToRemove)
    {
        if (accountToRemove?.ChannelId == null)
            return;
        string channelId = accountToRemove.ChannelId;
        string channelName = accountToRemove.ChannelName;
        _logger.LogInformation("Removing YouTube account: {ChannelName} ({ChannelId})", channelName, channelId);
        try
        {
            await _unifiedEventService.LogoutYouTubeAccountAsync(channelId);
            bool removed = false;
            await _dispatcherQueue.EnqueueAsync(() =>
            {
                removed = CurrentSettings.Connections.YouTubeAccounts.Remove(accountToRemove);
                if (removed)
                {
                    _logger.LogInformation("Removed {ChannelName} from settings collection.", channelName);
                }
                else
                {
                    _logger.LogWarning("Failed to remove {ChannelName} from settings collection (already removed?).", channelName);
                }
            });
            if (removed)
            {
                await SaveSettingsAsync();
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error removing YouTube {ChannelName}", channelName);
        }
        finally
        {
            _messenger.Send(new ConnectionsUpdatedMessage());
        }
    }
    [RelayCommand]
    private async Task ConnectAllAsync()
    {
        _logger.LogInformation("ConnectAll command executed.");
        await _unifiedEventService.ConnectAllConfiguredAsync();
    }
    [RelayCommand]
    private async Task DisconnectAllAsync()
    {
        _logger.LogInformation("DisconnectAll command executed.");
        await _unifiedEventService.DisconnectAllAsync();
    }
    [RelayCommand]
    public async Task ToggleStreamlabsEnableAsync(bool enable)
    {
        if (_isDisposed)
            return;
        _logger.LogInformation("Toggle Streamlabs Enable changed to: {IsEnabled}", enable);
        if (CurrentSettings.Connections.EnableStreamlabs != enable)
        {
            CurrentSettings.Connections.EnableStreamlabs = enable;
            await SaveSettingsAsync();
            if (enable)
            {
                await _unifiedEventService.ConnectStreamlabsAsync();
            }
            else
            {
                await _unifiedEventService.DisableStreamlabsAsync();
            }
        }
    }
    [RelayCommand]
    private async Task SetupStreamlabsTokenAsync()
    {
        _logger.LogInformation("SetupStreamlabsToken command executed.");
        XamlRoot? xamlRoot = App.MainWindow?.Content?.XamlRoot;
        if (xamlRoot == null)
        {
            _logger.LogError("Cannot show Streamlabs token dialog: XamlRoot is null.");
            return;
        }
        TextBox tokenInputBox = new() { PlaceholderText = "Paste your Socket API token here..." };
        ContentDialog inputDialog = new()
        {
            Title = "Streamlabs Socket API Token",
            Content = tokenInputBox,
            PrimaryButtonText = "Save & Enable",
            SecondaryButtonText = "Save Only",
            CloseButtonText = "Cancel",
            DefaultButton = ContentDialogButton.Primary,
            XamlRoot = xamlRoot,
        };
        ContentDialogResult result = await inputDialog.ShowAsync();
        string? tokenInput = tokenInputBox.Text;
        bool enableNow = result == ContentDialogResult.Primary;
        bool saveOnly = result == ContentDialogResult.Secondary;
        if ((enableNow || saveOnly) && !string.IsNullOrWhiteSpace(tokenInput))
        {
            string streamlabsStorageKey = CurrentSettings.Connections.StreamlabsTokenId ?? $"streamlabs_socket_{Guid.NewGuid()}";
            try
            {
                await _tokenStorage.SaveTokensAsync(streamlabsStorageKey, tokenInput, null);
                bool settingsChanged = false;
                if (CurrentSettings.Connections.StreamlabsTokenId != streamlabsStorageKey)
                {
                    CurrentSettings.Connections.StreamlabsTokenId = streamlabsStorageKey;
                    settingsChanged = true;
                }
                if (enableNow && !CurrentSettings.Connections.EnableStreamlabs)
                {
                    CurrentSettings.Connections.EnableStreamlabs = true;
                    settingsChanged = true;
                }
                if (settingsChanged)
                {
                    await SaveSettingsAsync();
                }
                if (enableNow)
                {
                    await _unifiedEventService.ConnectStreamlabsAsync();
                }
                NotifyAllPropertiesChanged();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to save Streamlabs token/settings.");
            }
        }
        else if (result == ContentDialogResult.None)
        {
            _logger.LogInformation("Streamlabs token setup cancelled.");
        }
        else
        {
            _logger.LogWarning("Streamlabs token setup skipped: No token entered.");
        }
    }
    [RelayCommand(CanExecute = nameof(CanDisableStreamlabs))]
    private async Task DisableStreamlabsAsync()
    {
        _logger.LogInformation("DisableStreamlabs command executed.");
        await _unifiedEventService.DisableStreamlabsAsync();
        NotifyAllPropertiesChanged();
    }
    public async Task HandleAccountToggleAsync(object account, bool connect)
    {
        if (_isDisposed)
            return;
        bool settingsChanged = false;
        string? accountId = null;
        string? platform = null;
        string? displayName = null;
        if (account is TwitchAccount twitchAcc)
        {
            accountId = twitchAcc.UserId;
            platform = "Twitch";
            displayName = twitchAcc.Username;
            if (twitchAcc.AutoConnect != connect)
            {
                twitchAcc.AutoConnect = connect;
                settingsChanged = true;
                _logger.LogDebug("Updated AutoConnect for Twitch account {Username} to {AutoConnect}", displayName, connect);
            }
        }
        else if (account is YouTubeAccount ytAcc)
        {
            accountId = ytAcc.ChannelId;
            platform = "YouTube";
            displayName = ytAcc.ChannelName;
            if (ytAcc.AutoConnect != connect)
            {
                ytAcc.AutoConnect = connect;
                settingsChanged = true;
                _logger.LogDebug("Updated AutoConnect for YouTube account {ChannelName} to {AutoConnect}", displayName, connect);
            }
        }
        if (accountId == null || platform == null)
        {
            _logger.LogWarning("HandleAccountToggleAsync called with invalid account type: {AccountType}", account?.GetType().Name);
            return;
        }
        try
        {
            Task? actionTask = null;
            if (connect)
            {
                _logger.LogInformation(
                    "Toggle ON: Attempting to connect {Platform} account {DisplayName} ({AccountId})",
                    platform,
                    displayName,
                    accountId
                );
                actionTask = platform switch
                {
                    "Twitch" => _unifiedEventService.ConnectTwitchAccountAsync((TwitchAccount)account),
                    "YouTube" => _unifiedEventService.ConnectYouTubeAccountAsync((YouTubeAccount)account),
                    _ => Task.CompletedTask,
                };
            }
            else
            {
                _logger.LogInformation(
                    "Toggle OFF: Disconnecting {Platform} client for {DisplayName} ({AccountId})",
                    platform,
                    displayName,
                    accountId
                );
                actionTask = platform switch
                {
                    "Twitch" => _twitchClient.DisconnectAsync(accountId),
                    "YouTube" => _youTubeClient.DisconnectAsync(accountId),
                    _ => Task.CompletedTask,
                };
            }
            if (actionTask != null)
            {
                await actionTask;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during toggle connect/disconnect action for {Platform} account {DisplayName}", platform, displayName);
        }
        finally
        {
            if (settingsChanged)
            {
                await SaveSettingsAsync();
            }
        }
    }
    public void Dispose()
    {
        if (_isDisposed)
            return;
        _isDisposed = true;
        _logger.LogInformation("Disposing SettingsViewModel...");
        _settingsService.SettingsUpdated -= SettingsService_SettingsUpdated;
        _messenger.Unregister<ConnectionsUpdatedMessage>(this);
        UnhookPropertyListeners();
        _logger.LogInformation("SettingsViewModel Dispose finished.");
        GC.SuppressFinalize(this);
    }
}
</file>

<file path="Core/Services/Tts/WindowsTtsService.cs">
using System.Speech.Synthesis;
using Microsoft.Extensions.Logging;
using StreamWeaver.Core.Models.Settings;
namespace StreamWeaver.Core.Services.Tts;
public sealed partial class WindowsTtsService(ILogger<WindowsTtsService> logger) : IEngineSpecificTtsService
{
    private readonly ILogger<WindowsTtsService> _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    private SpeechSynthesizer? _synthesizer;
    private bool _isDisposed = false;
    private string? _selectedVoiceName;
    public string EngineId => TtsSettings.WindowsEngine;
    public Task InitializeAsync()
    {
        if (_synthesizer != null)
        {
            _logger.LogInformation("Windows TTS Engine already initialized.");
            return Task.CompletedTask;
        }
        try
        {
            _logger.LogInformation("Initializing Windows SpeechSynthesizer...");
            _synthesizer = new SpeechSynthesizer();
            _logger.LogInformation("Windows SpeechSynthesizer initialized.");
            _synthesizer.Volume = 80;
            _synthesizer.Rate = 0;
        }
        catch (PlatformNotSupportedException pnsEx)
        {
            _logger.LogCritical(pnsEx, "Failed to initialize SpeechSynthesizer: Platform Not Supported. System.Speech might require Desktop Runtime components. Windows TTS will be disabled.");
            _synthesizer = null;
        }
        catch (Exception ex)
        {
            _logger.LogCritical(ex, "Failed to initialize SpeechSynthesizer. Windows TTS will be disabled.");
            _synthesizer = null;
        }
        return Task.CompletedTask;
    }
    public Task<IEnumerable<string>> GetInstalledVoicesAsync()
    {
        if (_synthesizer == null)
        {
            _logger.LogWarning("Cannot get installed voices: Synthesizer not available.");
            return Task.FromResult(Enumerable.Empty<string>());
        }
        return Task.Run(() =>
        {
            try
            {
                _logger.LogDebug("Fetching installed and enabled Windows voices...");
                var voices = _synthesizer.GetInstalledVoices()
                                        .Where(v => v.Enabled)
                                        .Select(v => v.VoiceInfo.Name)
                                        .ToList();
                _logger.LogDebug("Found {VoiceCount} enabled Windows voices.", voices.Count);
                return voices.AsEnumerable();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting installed Windows voices.");
                return [];
            }
        });
    }
    public void SetVoice(string voiceName)
    {
        if (_synthesizer == null)
        {
            _logger.LogWarning("SetVoice skipped: Synthesizer not available.");
            return;
        }
        if (string.IsNullOrWhiteSpace(voiceName))
        {
            _logger.LogWarning("SetVoice called with null or empty voice name.");
            return;
        }
        try
        {
            if (_selectedVoiceName != null && _selectedVoiceName.Equals(voiceName, StringComparison.OrdinalIgnoreCase))
            {
                _logger.LogTrace("SetVoice skipped: Voice '{VoiceName}' is already selected.", voiceName);
                return;
            }
            _logger.LogDebug("Attempting to set Windows TTS voice to: {VoiceName}", voiceName);
            bool voiceExists = _synthesizer
                .GetInstalledVoices()
                .Any(v => v.Enabled && v.VoiceInfo.Name.Equals(voiceName, StringComparison.OrdinalIgnoreCase));
            if (voiceExists)
            {
                _synthesizer.SelectVoice(voiceName);
                _selectedVoiceName = voiceName;
                _logger.LogInformation("Windows TTS Voice set to: {VoiceName}", voiceName);
            }
            else
            {
                _logger.LogWarning("Windows TTS Voice '{VoiceName}' not found or is not enabled.", voiceName);
                if (_selectedVoiceName != null && _selectedVoiceName.Equals(voiceName, StringComparison.OrdinalIgnoreCase))
                {
                    _synthesizer.SelectVoice(null);
                    _selectedVoiceName = null;
                    _logger.LogInformation("Fell back to default system voice as '{VoiceName}' is unavailable.", voiceName);
                }
            }
        }
        catch (ArgumentException argEx)
        {
            _logger.LogWarning(argEx, "Failed to set Windows TTS voice to '{VoiceName}'. Voice likely not found.", voiceName);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error setting Windows TTS voice to '{VoiceName}'.", voiceName);
        }
    }
    public void SetVolume(int volume)
    {
        if (_synthesizer == null) return;
        try
        {
            int clampedVolume = Math.Clamp(volume, 0, 100);
            if (_synthesizer.Volume != clampedVolume)
            {
                _synthesizer.Volume = clampedVolume;
                _logger.LogTrace("Windows TTS Volume set to: {Volume}", clampedVolume);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error setting Windows TTS volume to {Volume}.", volume);
        }
    }
    public void SetRate(int rate)
    {
        if (_synthesizer == null) return;
        try
        {
            int clampedRate = Math.Clamp(rate, -10, 10);
            if (_synthesizer.Rate != clampedRate)
            {
                _synthesizer.Rate = clampedRate;
                _logger.LogTrace("Windows TTS Rate set to: {Rate}", clampedRate);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error setting Windows TTS rate to {Rate}.", rate);
        }
    }
    public Task SpeakAsync(string textToSpeak)
    {
        if (_synthesizer == null)
        {
            _logger.LogWarning("SpeakAsync called but synthesizer is not available.");
            return Task.CompletedTask;
        }
        if (string.IsNullOrWhiteSpace(textToSpeak))
        {
            _logger.LogTrace("SpeakAsync called with empty text, skipping.");
            return Task.CompletedTask;
        }
        return Task.Run(() =>
        {
            try
            {
                if (_synthesizer.State == SynthesizerState.Speaking)
                {
                    _logger.LogTrace("Cancelling previous Windows speech before speaking new text.");
                    _synthesizer.SpeakAsyncCancelAll();
                }
                _logger.LogInformation("Speaking (Windows): \"{TextToSpeak}\"", textToSpeak);
                _synthesizer.SpeakAsync(textToSpeak);
            }
            catch (ObjectDisposedException)
            {
                _logger.LogWarning("SpeakAsync (Windows) failed: SpeechSynthesizer was disposed.");
            }
            catch (InvalidOperationException opEx)
            {
                _logger.LogError(opEx, "Invalid operation during SpeakAsync (Windows), synthesizer might be in an unexpected state.");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during SpeakAsync (Windows) execution: {ErrorMessage}", ex.Message);
            }
        });
    }
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    private void Dispose(bool disposing)
    {
        if (_isDisposed) return;
        if (disposing)
        {
            _logger.LogInformation("Disposing Windows TTS Engine Service...");
            if (_synthesizer != null)
            {
                try
                {
                    if (_synthesizer.State == SynthesizerState.Speaking)
                    {
                        _synthesizer.SpeakAsyncCancelAll();
                    }
                    _synthesizer.Dispose();
                    _logger.LogInformation("Windows SpeechSynthesizer disposed.");
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Exception during Windows SpeechSynthesizer disposal.");
                }
                _synthesizer = null;
            }
            _logger.LogInformation("Windows TTS Engine Service disposed.");
        }
        _isDisposed = true;
    }
}
</file>

<file path="StreamWeaver.sln">
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.13.35919.96
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "StreamWeaver", "StreamWeaver.csproj", "{865B243C-F6B6-4669-9CDE-0920BAA0B93F}"
	ProjectSection(ProjectDependencies) = postProject
		{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC} = {2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "StreamWeaver.Plugin.HelloWorld", "..\StreamWeaver.Plugin.HelloWorld\StreamWeaver.Plugin.HelloWorld.csproj", "{E24D71AD-E710-4569-9271-EE3E975898E0}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "YTLiveChat", "..\YTLiveChat\YTLiveChat\YTLiveChat.csproj", "{CD7CAA56-058B-2867-2160-2EFE782E157F}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TTSTextNormalization", "..\TTSTextNormalization\TTSTextNormalization\TTSTextNormalization.csproj", "{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "StreamWeaver.Plugin.BannedWordsPlugin", "..\StreamWeaver.Plugin.BannedWordsPlugin\StreamWeaver.Plugin.BannedWordsPlugin.csproj", "{38BBFCFB-6C51-4BCC-8789-208874FFBD01}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Debug|ARM64.Build.0 = Debug|ARM64
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Debug|x64.ActiveCfg = Debug|x64
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Debug|x64.Build.0 = Debug|x64
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Debug|x64.Deploy.0 = Debug|x64
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Debug|x86.ActiveCfg = Debug|x86
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Debug|x86.Build.0 = Debug|x86
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Debug|x86.Deploy.0 = Debug|x86
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Release|ARM64.ActiveCfg = Release|ARM64
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Release|ARM64.Build.0 = Release|ARM64
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Release|ARM64.Deploy.0 = Release|ARM64
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Release|x64.ActiveCfg = Release|x64
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Release|x64.Build.0 = Release|x64
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Release|x64.Deploy.0 = Release|x64
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Release|x86.ActiveCfg = Release|x86
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Release|x86.Build.0 = Release|x86
		{865B243C-F6B6-4669-9CDE-0920BAA0B93F}.Release|x86.Deploy.0 = Release|x86
		{E24D71AD-E710-4569-9271-EE3E975898E0}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{E24D71AD-E710-4569-9271-EE3E975898E0}.Debug|ARM64.Build.0 = Debug|Any CPU
		{E24D71AD-E710-4569-9271-EE3E975898E0}.Debug|x64.ActiveCfg = Debug|x64
		{E24D71AD-E710-4569-9271-EE3E975898E0}.Debug|x64.Build.0 = Debug|x64
		{E24D71AD-E710-4569-9271-EE3E975898E0}.Debug|x86.ActiveCfg = Debug|Any CPU
		{E24D71AD-E710-4569-9271-EE3E975898E0}.Debug|x86.Build.0 = Debug|Any CPU
		{E24D71AD-E710-4569-9271-EE3E975898E0}.Release|ARM64.ActiveCfg = Release|Any CPU
		{E24D71AD-E710-4569-9271-EE3E975898E0}.Release|ARM64.Build.0 = Release|Any CPU
		{E24D71AD-E710-4569-9271-EE3E975898E0}.Release|x64.ActiveCfg = Release|Any CPU
		{E24D71AD-E710-4569-9271-EE3E975898E0}.Release|x64.Build.0 = Release|Any CPU
		{E24D71AD-E710-4569-9271-EE3E975898E0}.Release|x86.ActiveCfg = Release|Any CPU
		{E24D71AD-E710-4569-9271-EE3E975898E0}.Release|x86.Build.0 = Release|Any CPU
		{CD7CAA56-058B-2867-2160-2EFE782E157F}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{CD7CAA56-058B-2867-2160-2EFE782E157F}.Debug|ARM64.Build.0 = Debug|Any CPU
		{CD7CAA56-058B-2867-2160-2EFE782E157F}.Debug|x64.ActiveCfg = Debug|Any CPU
		{CD7CAA56-058B-2867-2160-2EFE782E157F}.Debug|x64.Build.0 = Debug|Any CPU
		{CD7CAA56-058B-2867-2160-2EFE782E157F}.Debug|x86.ActiveCfg = Debug|Any CPU
		{CD7CAA56-058B-2867-2160-2EFE782E157F}.Debug|x86.Build.0 = Debug|Any CPU
		{CD7CAA56-058B-2867-2160-2EFE782E157F}.Release|ARM64.ActiveCfg = Release|Any CPU
		{CD7CAA56-058B-2867-2160-2EFE782E157F}.Release|ARM64.Build.0 = Release|Any CPU
		{CD7CAA56-058B-2867-2160-2EFE782E157F}.Release|x64.ActiveCfg = Release|Any CPU
		{CD7CAA56-058B-2867-2160-2EFE782E157F}.Release|x64.Build.0 = Release|Any CPU
		{CD7CAA56-058B-2867-2160-2EFE782E157F}.Release|x86.ActiveCfg = Release|Any CPU
		{CD7CAA56-058B-2867-2160-2EFE782E157F}.Release|x86.Build.0 = Release|Any CPU
		{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}.Debug|ARM64.Build.0 = Debug|Any CPU
		{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}.Debug|x64.ActiveCfg = Debug|Any CPU
		{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}.Debug|x64.Build.0 = Debug|Any CPU
		{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}.Debug|x86.ActiveCfg = Debug|Any CPU
		{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}.Debug|x86.Build.0 = Debug|Any CPU
		{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}.Release|ARM64.ActiveCfg = Release|Any CPU
		{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}.Release|ARM64.Build.0 = Release|Any CPU
		{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}.Release|x64.ActiveCfg = Release|Any CPU
		{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}.Release|x64.Build.0 = Release|Any CPU
		{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}.Release|x86.ActiveCfg = Release|Any CPU
		{2D3B51A4-9FF6-F26A-21ED-CB5EB6ACF3EC}.Release|x86.Build.0 = Release|Any CPU
		{38BBFCFB-6C51-4BCC-8789-208874FFBD01}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{38BBFCFB-6C51-4BCC-8789-208874FFBD01}.Debug|ARM64.Build.0 = Debug|Any CPU
		{38BBFCFB-6C51-4BCC-8789-208874FFBD01}.Debug|x64.ActiveCfg = Debug|Any CPU
		{38BBFCFB-6C51-4BCC-8789-208874FFBD01}.Debug|x64.Build.0 = Debug|Any CPU
		{38BBFCFB-6C51-4BCC-8789-208874FFBD01}.Debug|x86.ActiveCfg = Debug|Any CPU
		{38BBFCFB-6C51-4BCC-8789-208874FFBD01}.Debug|x86.Build.0 = Debug|Any CPU
		{38BBFCFB-6C51-4BCC-8789-208874FFBD01}.Release|ARM64.ActiveCfg = Release|Any CPU
		{38BBFCFB-6C51-4BCC-8789-208874FFBD01}.Release|ARM64.Build.0 = Release|Any CPU
		{38BBFCFB-6C51-4BCC-8789-208874FFBD01}.Release|x64.ActiveCfg = Release|Any CPU
		{38BBFCFB-6C51-4BCC-8789-208874FFBD01}.Release|x64.Build.0 = Release|Any CPU
		{38BBFCFB-6C51-4BCC-8789-208874FFBD01}.Release|x86.ActiveCfg = Release|Any CPU
		{38BBFCFB-6C51-4BCC-8789-208874FFBD01}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {38A0AC18-C794-40BD-8F21-A6AE8E7A0C75}
	EndGlobalSection
EndGlobal
</file>

<file path="UI/Views/MainChatView.xaml">
<?xml version="1.0" encoding="utf-8"?>
<Page
    x:Class="StreamWeaver.UI.Views.MainChatView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:StreamWeaver.UI.Views"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:viewmodels="using:StreamWeaver.UI.ViewModels"
    xmlns:models_events="using:StreamWeaver.Core.Models.Events"
    xmlns:segments="using:StreamWeaver.Core.Models.Events.Messages"
    xmlns:selectors="using:StreamWeaver.UI.Selectors"
    xmlns:converters="using:StreamWeaver.UI.Converters"
    xmlns:helpers="using:StreamWeaver.UI.Helpers"
    mc:Ignorable="d"
    d:DataContext="{d:DesignInstance Type=viewmodels:MainChatViewModel, IsDesignTimeCreatable=False}"
    Loaded="Page_Loaded"
    Unloaded="Page_Unloaded">

    <Page.Resources>
        <!-- Converters -->
        <converters:DateTimeFormatConverter x:Key="DateTimeFormatConverter"/>
        <converters:PlatformToBrushConverter x:Key="PlatformToBrushConverter"/>
        <converters:PlatformToIconConverter x:Key="PlatformToIconConverter"/>
        <converters:StringToBrushConverter x:Key="StringToBrushConverter"/>
        <converters:BadgeInfoToImageSourceConverter x:Key="BadgeInfoToImageSourceConverter"/>
        <converters:BoolToVisibilityConverter x:Key="BoolToVisibilityConverter"/>
        <converters:StringToVisibilityConverter x:Key="StringToVisibilityConverter"/>
        <converters:SystemMessageLevelToBrushConverter x:Key="SystemLevelToBrushConverter"/>
        <converters:SystemMessageLevelToSymbolConverter x:Key="SystemLevelToSymbolConverter"/>
        <converters:BoolToFontStyleConverter x:Key="BoolToFontStyleConverter"/>
        <converters:SubEventVerbConverter x:Key="SubEventVerbConverter"/>
        <converters:SubEventDurationConverter x:Key="SubEventDurationConverter"/>
        <converters:SubEventTotalGiftsConverter x:Key="SubEventTotalGiftsConverter"/>
        <converters:SubEventRecipientConverter x:Key="SubEventRecipientConverter"/>
        <converters:SubEventMessageConverter x:Key="SubEventMessageConverter"/>
        <converters:MembershipMilestoneConverter x:Key="MembershipMilestoneConverter"/>
        <converters:HostEventTextConverter x:Key="HostEventTextConverter"/>
        <converters:AutoHostTextConverter x:Key="AutoHostTextConverter"/>
        <converters:IntToVisibilityConverter x:Key="IntToVisibilityConverter"/>
        <converters:DonationToBrushConverter x:Key="DonationBorderBrushConverter"/>
        <converters:DonationToBrushConverter x:Key="DonationBackgroundBrushConverter" IsBackgroundConverter="True"/>
        <converters:PlatformToVisibilityConverter x:Key="PlatformToVisibilityConverter"/>
        <converters:PlatformToMarginConverter x:Key="PlatformToMarginConverter"/>
        <converters:PlatformToIsEnabledConverter x:Key="PlatformToIsEnabledConverter"/>
        <converters:MembershipDetailsConverter x:Key="MembershipDetailsConverter"/>
        <converters:MembershipTypeToBrushConverter x:Key="MembershipTypeToBrushConverter"/>
        <converters:BoolToStringConverter x:Key="BoolToStringConverter"/>
        <!-- Added -->

        <!-- Styles -->
        <Style x:Key="ProfilePictureStyle" TargetType="Image">
            <Setter Property="Width" Value="36"/>
            <Setter Property="Height" Value="36"/>
            <Setter Property="Margin" Value="0,0,6,0"/>
            <Setter Property="VerticalAlignment" Value="Top"/>
            <Setter Property="Stretch" Value="UniformToFill"/>
        </Style>
        <Style TargetType="Ellipse" x:Key="ProfilePictureEllipseStyle">
            <Setter Property="Width" Value="36"/>
            <Setter Property="Height" Value="36"/>
            <Setter Property="Margin" Value="0,0,6,0"/>
            <Setter Property="VerticalAlignment" Value="Top"/>
            <Setter Property="Stroke" Value="{ThemeResource CardStrokeColorDefaultBrush}"/>
            <Setter Property="StrokeThickness" Value="1"/>
        </Style>
        <SolidColorBrush x:Key="DefaultProfilePicFallbackBrush" Color="{ThemeResource SystemAccentColor}"/>
        <Style x:Key="MoreButtonStyle" TargetType="Button">
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="Foreground" Value="{ThemeResource ButtonForeground}"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Padding" Value="4"/>
            <Setter Property="MinWidth" Value="0"/>
            <Setter Property="MinHeight" Value="0"/>
            <Setter Property="VerticalAlignment" Value="Center"/>
            <Setter Property="HorizontalAlignment" Value="Right"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Grid x:Name="RootGrid" Background="{TemplateBinding Background}">
                            <VisualStateManager.VisualStateGroups>
                                <VisualStateGroup x:Name="CommonStates">
                                    <VisualState x:Name="Normal"/>
                                    <VisualState x:Name="PointerOver">
                                        <Storyboard>
                                            <ObjectAnimationUsingKeyFrames Storyboard.TargetName="RootGrid" Storyboard.TargetProperty="Background">
                                                <DiscreteObjectKeyFrame KeyTime="0" Value="{ThemeResource ButtonBackgroundPointerOver}"/>
                                            </ObjectAnimationUsingKeyFrames>
                                            <ObjectAnimationUsingKeyFrames Storyboard.TargetName="ContentGlyph" Storyboard.TargetProperty="Foreground">
                                                <DiscreteObjectKeyFrame KeyTime="0" Value="{ThemeResource ButtonForegroundPointerOver}"/>
                                            </ObjectAnimationUsingKeyFrames>
                                        </Storyboard>
                                    </VisualState>
                                    <VisualState x:Name="Pressed">
                                        <Storyboard>
                                            <ObjectAnimationUsingKeyFrames Storyboard.TargetName="RootGrid" Storyboard.TargetProperty="Background">
                                                <DiscreteObjectKeyFrame KeyTime="0" Value="{ThemeResource ButtonBackgroundPressed}"/>
                                            </ObjectAnimationUsingKeyFrames>
                                            <ObjectAnimationUsingKeyFrames Storyboard.TargetName="ContentGlyph" Storyboard.TargetProperty="Foreground">
                                                <DiscreteObjectKeyFrame KeyTime="0" Value="{ThemeResource ButtonForegroundPressed}"/>
                                            </ObjectAnimationUsingKeyFrames>
                                        </Storyboard>
                                    </VisualState>
                                    <VisualState x:Name="Disabled">
                                        <Storyboard>
                                            <ObjectAnimationUsingKeyFrames Storyboard.TargetName="ContentGlyph" Storyboard.TargetProperty="Foreground">
                                                <DiscreteObjectKeyFrame KeyTime="0" Value="{ThemeResource ButtonForegroundDisabled}"/>
                                            </ObjectAnimationUsingKeyFrames>
                                        </Storyboard>
                                    </VisualState>
                                </VisualStateGroup>
                            </VisualStateManager.VisualStateGroups>
                            <FontIcon x:Name="ContentGlyph" FontFamily="{StaticResource SymbolThemeFontFamily}" Glyph="" FontSize="14" VerticalAlignment="Center" HorizontalAlignment="Center" Foreground="{TemplateBinding Foreground}"/>
                        </Grid>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
        <Style x:Key="SubtleIconButton" TargetType="Button">
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Padding" Value="4"/>
            <Setter Property="MinWidth" Value="0"/>
            <Setter Property="MinHeight" Value="0"/>
            <Setter Property="VerticalAlignment" Value="Center"/>
            <Setter Property="HorizontalAlignment" Value="Center"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Grid x:Name="RootGrid" Background="{TemplateBinding Background}">
                            <VisualStateManager.VisualStateGroups>
                                <VisualStateGroup x:Name="CommonStates">
                                    <VisualState x:Name="Normal"/>
                                    <VisualState x:Name="PointerOver">
                                        <Storyboard>
                                            <ObjectAnimationUsingKeyFrames Storyboard.TargetName="RootGrid" Storyboard.TargetProperty="Background">
                                                <DiscreteObjectKeyFrame KeyTime="0" Value="{ThemeResource ButtonBackgroundPointerOver}"/>
                                            </ObjectAnimationUsingKeyFrames>
                                        </Storyboard>
                                    </VisualState>
                                    <VisualState x:Name="Pressed">
                                        <Storyboard>
                                            <ObjectAnimationUsingKeyFrames Storyboard.TargetName="RootGrid" Storyboard.TargetProperty="Background">
                                                <DiscreteObjectKeyFrame KeyTime="0" Value="{ThemeResource ButtonBackgroundPressed}"/>
                                            </ObjectAnimationUsingKeyFrames>
                                        </Storyboard>
                                    </VisualState>
                                    <VisualState x:Name="Disabled">
                                        <Storyboard>
                                            <ObjectAnimationUsingKeyFrames Storyboard.TargetName="RootGrid" Storyboard.TargetProperty="Background">
                                                <DiscreteObjectKeyFrame KeyTime="0" Value="Transparent"/>
                                            </ObjectAnimationUsingKeyFrames>
                                            <ObjectAnimationUsingKeyFrames Storyboard.TargetName="ContentPresenter" Storyboard.TargetProperty="Foreground">
                                                <DiscreteObjectKeyFrame KeyTime="0" Value="{ThemeResource ButtonForegroundDisabled}"/>
                                            </ObjectAnimationUsingKeyFrames>
                                        </Storyboard>
                                    </VisualState>
                                </VisualStateGroup>
                            </VisualStateManager.VisualStateGroups>
                            <ContentPresenter x:Name="ContentPresenter" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" VerticalAlignment="{TemplateBinding VerticalContentAlignment}" Content="{TemplateBinding Content}" Foreground="{TemplateBinding Foreground}"/>
                        </Grid>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <!-- DataTemplates -->
        <DataTemplate x:Key="ChatMessageDataTemplate" x:DataType="models_events:ChatMessageEvent">
            <Grid Margin="0,2" Padding="4">
                <VisualStateManager.VisualStateGroups>
                    <VisualStateGroup x:Name="CommonStates">
                        <VisualState x:Name="Normal"/>
                        <VisualState x:Name="PointerOver">
                            <Storyboard>
                                <ObjectAnimationUsingKeyFrames Storyboard.TargetName="HoverBackground" Storyboard.TargetProperty="Opacity">
                                    <DiscreteObjectKeyFrame KeyTime="0" Value="0.1"/>
                                </ObjectAnimationUsingKeyFrames>
                            </Storyboard>
                        </VisualState>
                    </VisualStateGroup>
                </VisualStateManager.VisualStateGroups>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>
                <Border x:Name="HoverBackground" Background="{ThemeResource SystemControlHighlightListLowBrush}" CornerRadius="2" Opacity="0" Grid.ColumnSpan="3"/>
                <!-- Profile Picture (YouTube only for now) -->
                <Ellipse Grid.Column="0" Style="{StaticResource ProfilePictureEllipseStyle}" Visibility="{Binding Platform, Converter={StaticResource PlatformToVisibilityConverter}}">
                    <Ellipse.Fill>
                        <ImageBrush ImageSource="{Binding ProfileImageUrl, FallbackValue={StaticResource DefaultProfilePicFallbackBrush}}" Stretch="UniformToFill"/>
                    </Ellipse.Fill>
                </Ellipse>
                <!-- Chat Content (uses Helper) -->
                <Grid Grid.Column="1" Margin="{Binding Platform, Converter={StaticResource PlatformToMarginConverter}}">
                    <RichTextBlock helpers:RichTextBlockEventHelper.ChatEventSource="{Binding}" TextWrapping="Wrap" VerticalAlignment="Top" IsTextSelectionEnabled="True" FontSize="{ThemeResource ControlContentThemeFontSize}">
                        <RichTextBlock.Resources>
                            <Style TargetType="Paragraph">
                                <Setter Property="Margin" Value="0"/>
                            </Style>
                        </RichTextBlock.Resources>
                    </RichTextBlock>
                    <Border Background="{ThemeResource SystemControlHighlightAccentBrush}" Opacity="0.1" CornerRadius="2" Margin="-2" IsHitTestVisible="False" Visibility="{Binding IsHighlight, Converter={StaticResource BoolToVisibilityConverter}}"/>
                </Grid>
                <!-- Moderation Button (YouTube only) -->
                <Button Grid.Column="2" Style="{StaticResource MoreButtonStyle}" DataContext="{Binding}" IsEnabled="{Binding Platform, Converter={StaticResource PlatformToIsEnabledConverter}}">
                    <Button.Flyout>
                        <MenuFlyout>
                            <MenuFlyoutItem Text="Timeout User (10m)" Icon="Clock" IsEnabled="{Binding Platform, Converter={StaticResource PlatformToIsEnabledConverter}}" Command="{Binding DataContext.TimeoutUserCommand, ElementName=ChatListView}" CommandParameter="{Binding}"/>
                            <MenuFlyoutItem Text="Ban User" Icon="BlockContact" IsEnabled="{Binding Platform, Converter={StaticResource PlatformToIsEnabledConverter}}" Command="{Binding DataContext.BanUserCommand, ElementName=ChatListView}" CommandParameter="{Binding}"/>
                            <MenuFlyoutSeparator/>
                            <MenuFlyoutItem Text="Delete Message" Icon="Delete" IsEnabled="{Binding Platform, Converter={StaticResource PlatformToIsEnabledConverter}}" Command="{Binding DataContext.DeleteMessageCommand, ElementName=ChatListView}" CommandParameter="{Binding}"/>
                        </MenuFlyout>
                    </Button.Flyout>
                    <ToolTipService.ToolTip>
                        <ToolTip Content="Moderation Actions (YouTube Only)"/>
                    </ToolTipService.ToolTip>
                </Button>
            </Grid>
        </DataTemplate>

        <DataTemplate x:Key="DonationDataTemplate" x:DataType="models_events:DonationEvent">
            <Grid Margin="0,2" CornerRadius="4">
                <!-- Background for the whole item, subtle tint based on type -->
                <Border Background="{Binding Converter={StaticResource DonationBackgroundBrushConverter}}"/>
                <Grid Padding="0">
                    <!-- Inner Grid for structure, no default padding -->
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>

                    <!-- Profile Picture (YouTube only) -->
                    <Ellipse Grid.Column="0" Margin="6,4,0,4" Style="{StaticResource ProfilePictureEllipseStyle}" Visibility="{Binding Platform, Converter={StaticResource PlatformToVisibilityConverter}}">
                        <Ellipse.Fill>
                            <ImageBrush ImageSource="{Binding ProfileImageUrl, FallbackValue={StaticResource DefaultProfilePicFallbackBrush}}" Stretch="UniformToFill"/>
                        </Ellipse.Fill>
                    </Ellipse>

                    <!-- Main Content StackPanel -->
                    <StackPanel Grid.Column="1" Margin="{Binding Platform, Converter={StaticResource PlatformToMarginConverter}}">
                        <!-- Apply indent -->
                        <!-- Header (SuperChat/Sticker/Bits/Streamlabs) -->
                        <Border x:Name="DonationHeaderBorder"
                                CornerRadius="4,4,0,0"
                                Background="{Binding HeaderBackgroundColor, Converter={StaticResource StringToBrushConverter}, FallbackValue={ThemeResource LayerFillColorDefaultBrush}}"
                                BorderBrush="{Binding BodyBackgroundColor, Converter={StaticResource StringToBrushConverter}, FallbackValue={ThemeResource CardStrokeColorDefaultBrush}}"
                                BorderThickness="0,0,0,1">
                            <Grid Padding="6,4">
                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition Width="Auto"/>
                                    <ColumnDefinition Width="Auto"/>
                                    <ColumnDefinition Width="Auto"/>
                                    <ColumnDefinition Width="*"/>
                                    <ColumnDefinition Width="Auto"/>
                                </Grid.ColumnDefinitions>

                                <TextBlock Grid.Column="0" Text="{Binding Timestamp, Converter={StaticResource DateTimeFormatConverter}, ConverterParameter='HH:mm'}" FontSize="10" VerticalAlignment="Center" Margin="0,0,5,0" Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                                <FontIcon Grid.Column="1" FontFamily="Segoe Fluent Icons" FontSize="14" Margin="0,0,6,0" VerticalAlignment="Center" Glyph="{Binding Platform, Converter={StaticResource PlatformToIconConverter}}" Foreground="{Binding Platform, Converter={StaticResource PlatformToBrushConverter}}"/>

                                <ItemsControl Grid.Column="2" ItemsSource="{Binding Badges}" VerticalAlignment="Center" Margin="0,0,4,0">
                                    <ItemsControl.ItemsPanel>
                                        <ItemsPanelTemplate>
                                            <StackPanel Orientation="Horizontal"/>
                                        </ItemsPanelTemplate>
                                    </ItemsControl.ItemsPanel>
                                    <ItemsControl.ItemTemplate>
                                        <DataTemplate x:DataType="models_events:BadgeInfo">
                                            <Image Source="{Binding Converter={StaticResource BadgeInfoToImageSourceConverter}}" Height="18" Width="18" Margin="0,0,2,0" VerticalAlignment="Center">
                                                <ToolTipService.ToolTip>
                                                    <ToolTip Content="{Binding Identifier}"/>
                                                </ToolTipService.ToolTip>
                                            </Image>
                                        </DataTemplate>
                                    </ItemsControl.ItemTemplate>
                                </ItemsControl>

                                <TextBlock Grid.Column="3" Text="{Binding Username}" FontWeight="SemiBold" VerticalAlignment="Center" Foreground="{Binding AuthorNameTextColor, Converter={StaticResource StringToBrushConverter}, FallbackValue={ThemeResource TextFillColorPrimaryBrush}}"/>
                                <TextBlock Grid.Column="4" Text="{Binding FormattedAmount}" FontWeight="Bold" VerticalAlignment="Center" HorizontalAlignment="Right" Foreground="{Binding HeaderTextColor, Converter={StaticResource StringToBrushConverter}, FallbackValue={ThemeResource TextFillColorPrimaryBrush}}"/>
                            </Grid>
                        </Border>

                        <!-- Body (SuperChat Message / Sticker / Bits Message / SL Message) -->
                        <Border x:Name="DonationBodyBorder"
                                CornerRadius="0,0,4,4"
                                Background="{Binding BodyBackgroundColor, Converter={StaticResource StringToBrushConverter}, FallbackValue=Transparent}">
                            <StackPanel Padding="6,4">
                                <Image Source="{Binding StickerImageUrl}" Stretch="Uniform" MaxHeight="80" HorizontalAlignment="Left" Margin="0,4,0,4" Visibility="{Binding StickerImageUrl, Converter={StaticResource StringToVisibilityConverter}}">
                                    <ToolTipService.ToolTip>
                                        <ToolTip Content="{Binding StickerAltText}"/>
                                    </ToolTipService.ToolTip>
                                </Image>
                                <!-- Use helper for parsed message -->
                                <RichTextBlock helpers:RichTextBlockHelper.SegmentsSource="{Binding ParsedMessage}" TextWrapping="Wrap" IsTextSelectionEnabled="True" Margin="0,4,0,0" Foreground="{Binding BodyTextColor, Converter={StaticResource StringToBrushConverter}, FallbackValue={ThemeResource TextFillColorPrimaryBrush}}" Visibility="{Binding ParsedMessage.Count, Converter={StaticResource IntToVisibilityConverter}}">
                                    <RichTextBlock.Resources>
                                        <Style TargetType="Paragraph">
                                            <Setter Property="Margin" Value="0"/>
                                        </Style>
                                    </RichTextBlock.Resources>
                                </RichTextBlock>
                            </StackPanel>
                        </Border>
                    </StackPanel>
                </Grid>
            </Grid>
        </DataTemplate>

        <DataTemplate x:Key="MembershipDataTemplate" x:DataType="models_events:MembershipEvent">
            <!-- Apply subtle background based on type -->
            <Grid Margin="0,2" Padding="4" Background="{Binding MembershipType, Converter={StaticResource MembershipTypeToBrushConverter}}" CornerRadius="4">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>
                <!-- Profile Picture -->
                <Ellipse Grid.Column="0" Style="{StaticResource ProfilePictureEllipseStyle}">
                    <Ellipse.Fill>
                        <ImageBrush ImageSource="{Binding ProfileImageUrl, FallbackValue={StaticResource DefaultProfilePicFallbackBrush}}" Stretch="UniformToFill"/>
                    </Ellipse.Fill>
                </Ellipse>
                <!-- Main Content StackPanel -->
                <StackPanel Grid.Column="1" Spacing="4" Margin="{Binding Platform, Converter={StaticResource PlatformToMarginConverter}}">
                    <!-- Apply indent -->
                    <!-- Header Row: Timestamp, Icon, Badges, Username, HeaderText -->
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="*"/>
                        </Grid.ColumnDefinitions>
                        <TextBlock Grid.Column="0" Text="{Binding Timestamp, Converter={StaticResource DateTimeFormatConverter}, ConverterParameter='HH:mm'}" FontSize="10" VerticalAlignment="Center" Margin="0,0,5,0" Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                        <FontIcon Grid.Column="1" FontFamily="Segoe Fluent Icons" FontSize="14" Margin="0,0,6,0" VerticalAlignment="Center" Glyph="" Foreground="{Binding Platform, Converter={StaticResource PlatformToBrushConverter}}"/>
                        <ItemsControl Grid.Column="2" ItemsSource="{Binding Badges}" VerticalAlignment="Center" Margin="0,0,4,0">
                            <ItemsControl.ItemsPanel>
                                <ItemsPanelTemplate>
                                    <StackPanel Orientation="Horizontal"/>
                                </ItemsPanelTemplate>
                            </ItemsControl.ItemsPanel>
                            <ItemsControl.ItemTemplate>
                                <DataTemplate x:DataType="models_events:BadgeInfo">
                                    <Image Source="{Binding Converter={StaticResource BadgeInfoToImageSourceConverter}}" Height="18" Width="18" Margin="0,0,2,0" VerticalAlignment="Center">
                                        <ToolTipService.ToolTip>
                                            <ToolTip Content="{Binding Identifier}"/>
                                        </ToolTipService.ToolTip>
                                    </Image>
                                </DataTemplate>
                            </ItemsControl.ItemTemplate>
                        </ItemsControl>
                        <TextBlock Grid.Column="3" FontWeight="SemiBold" TextWrapping="Wrap" VerticalAlignment="Center" Foreground="{Binding UsernameColor, Converter={StaticResource StringToBrushConverter}, FallbackValue={ThemeResource TextFillColorPrimaryBrush}}">
                            <Run Text="{Binding Username}"/><Run Text=" "/>
                            <Run Text="{Binding HeaderText}" FontStyle="Italic"/>
                        </TextBlock>
                    </Grid>
                    <!-- Details Row: Level, Months, Gifter, Count -->
                    <TextBlock x:Name="MembershipDetailsTextBlock"
                               FontSize="11"
                               Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                               TextWrapping="Wrap"
                               Text="{Binding Converter={StaticResource MembershipDetailsConverter}}"
                               Visibility="{Binding Text, ElementName=MembershipDetailsTextBlock, Converter={StaticResource StringToVisibilityConverter}}"/>
                    <!-- Milestone User Message (only shown for Milestones with a message) -->
                    <RichTextBlock helpers:RichTextBlockHelper.SegmentsSource="{Binding ParsedMessage}" TextWrapping="Wrap" IsTextSelectionEnabled="True" Margin="0,4,0,0" FontSize="{ThemeResource ControlContentThemeFontSize}" Visibility="{Binding ParsedMessage.Count, Converter={StaticResource IntToVisibilityConverter}}">
                        <RichTextBlock.Resources>
                            <Style TargetType="Paragraph">
                                <Setter Property="Margin" Value="0"/>
                            </Style>
                        </RichTextBlock.Resources>
                    </RichTextBlock>
                </StackPanel>
            </Grid>
        </DataTemplate>

        <DataTemplate x:Key="SubscriptionDataTemplate" x:DataType="models_events:SubscriptionEvent">
            <Grid Margin="0,2" Padding="4,2" Background="{ThemeResource SystemControlBackgroundListLowBrush}">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <!-- Indent Spacer -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Timestamp -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Platform Icon -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Badges -->
                    <ColumnDefinition Width="*"/>
                    <!-- Message -->
                </Grid.ColumnDefinitions>
                
                <!-- Using a subtle theme background -->
                <!-- Top Border Accent -->
                <Border BorderBrush="#FF8A2BE2" BorderThickness="0,2,0,0" VerticalAlignment="Top"/>

                <!-- Indent Spacer (for visual consistency with YouTube messages) -->
                <Rectangle Grid.Column="0" Width="36" Height="1" VerticalAlignment="Top" Margin="0,0,6,0" Fill="Transparent"/>

                <TextBlock Grid.Column="1" Text="{Binding Timestamp, Converter={StaticResource DateTimeFormatConverter}, ConverterParameter='HH:mm'}" FontSize="10" VerticalAlignment="Center" Margin="0,0,5,0" Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                <FontIcon Grid.Column="2" FontFamily="Segoe Fluent Icons" FontSize="14" Margin="0,0,6,0" VerticalAlignment="Center" Glyph="" Foreground="{Binding Platform, Converter={StaticResource PlatformToBrushConverter}}"/>
                <ItemsControl Grid.Column="3" ItemsSource="{Binding Badges}" VerticalAlignment="Center" Margin="0,0,4,0">
                    <ItemsControl.ItemsPanel>
                        <ItemsPanelTemplate>
                            <StackPanel Orientation="Horizontal"/>
                        </ItemsPanelTemplate>
                    </ItemsControl.ItemsPanel>
                    <ItemsControl.ItemTemplate>
                        <DataTemplate x:DataType="models_events:BadgeInfo">
                            <Image Source="{Binding Converter={StaticResource BadgeInfoToImageSourceConverter}}" Height="18" Width="18" Margin="0,0,2,0" VerticalAlignment="Center">
                                <ToolTipService.ToolTip>
                                    <ToolTip Content="{Binding Identifier}"/>
                                </ToolTipService.ToolTip>
                            </Image>
                        </DataTemplate>
                    </ItemsControl.ItemTemplate>
                </ItemsControl>
                <TextBlock Grid.Column="4" TextWrapping="Wrap" FontStyle="Italic" VerticalAlignment="Center" Foreground="{Binding UsernameColor, Converter={StaticResource StringToBrushConverter}, FallbackValue={ThemeResource TextFillColorPrimaryBrush}}">
                     <Run Text="{Binding Username}" FontWeight="SemiBold"/>
                     <Run Text="{Binding Converter={StaticResource SubEventVerbConverter}}"/>
                     <Run Text="{Binding Tier}"/><Run Text=" Sub"/>
                     <Run Text="{Binding Converter={StaticResource SubEventRecipientConverter}}"/>
                     <Run Text="{Binding Converter={StaticResource SubEventDurationConverter}}"/>
                     <Run Text="{Binding Converter={StaticResource SubEventTotalGiftsConverter}}"/>
                     <Run Text="{Binding Message, Converter={StaticResource SubEventMessageConverter}}"/>
                </TextBlock>
            </Grid>
        </DataTemplate>

        <DataTemplate x:Key="FollowDataTemplate" x:DataType="models_events:FollowEvent">
            <Grid Margin="0,2" Padding="4,2" Background="#0A00BCD4">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <!-- Indent -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Timestamp -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Icon -->
                    <ColumnDefinition Width="*"/>
                    <!-- Message -->
                </Grid.ColumnDefinitions>

                <!-- Subtle Teal -->
                <Border BorderBrush="#FF00BCD4" BorderThickness="2,0,0,0" HorizontalAlignment="Left"/>
                <!-- Left Accent -->
                
                <Rectangle Grid.Column="0" Width="36" Height="1" VerticalAlignment="Top" Margin="0,0,6,0" Fill="Transparent"/>
                <TextBlock Grid.Column="1" Text="{Binding Timestamp, Converter={StaticResource DateTimeFormatConverter}, ConverterParameter='HH:mm'}" FontSize="10" VerticalAlignment="Center" Margin="0,0,5,0" Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                <FontIcon Grid.Column="2" Glyph="" FontFamily="Segoe Fluent Icons" FontSize="14" Margin="0,0,6,0" VerticalAlignment="Center" Foreground="{Binding Platform, Converter={StaticResource PlatformToBrushConverter}}"/>
                <TextBlock Grid.Column="3" VerticalAlignment="Center"><Run Text="{Binding Username}" FontWeight="SemiBold"/><Run Text=" just followed!"/></TextBlock>
            </Grid>
        </DataTemplate>

        <DataTemplate x:Key="RaidDataTemplate" x:DataType="models_events:RaidEvent">
            <Grid Margin="0,2" Padding="4,2" Background="#0AFFC107">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <!-- Indent -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Timestamp -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Icon -->
                    <ColumnDefinition Width="*"/>
                    <!-- Message -->
                </Grid.ColumnDefinitions>

                <!-- Subtle Yellow -->
                <Border BorderBrush="#FFFFC107" BorderThickness="2,0,0,0" HorizontalAlignment="Left"/>
                <!-- Left Accent -->
                
                <Rectangle Grid.Column="0" Width="36" Height="1" VerticalAlignment="Top" Margin="0,0,6,0" Fill="Transparent"/>
                <TextBlock Grid.Column="1" Text="{Binding Timestamp, Converter={StaticResource DateTimeFormatConverter}, ConverterParameter='HH:mm'}" FontSize="10" VerticalAlignment="Center" Margin="0,0,5,0" Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                <FontIcon Grid.Column="2" Glyph="" FontFamily="Segoe Fluent Icons" FontSize="14" Margin="0,0,6,0" VerticalAlignment="Center" Foreground="{Binding Platform, Converter={StaticResource PlatformToBrushConverter}}"/>
                <TextBlock Grid.Column="3" VerticalAlignment="Center">
                        <Run Text="{Binding RaiderUsername}" FontWeight="SemiBold"/>
                        <Run Text=" is raiding with "/><Run Text="{Binding ViewerCount}" FontWeight="SemiBold"/>
                        <Run Text=" viewers!"/>
                </TextBlock>
            </Grid>
        </DataTemplate>

        <DataTemplate x:Key="HostDataTemplate" x:DataType="models_events:HostEvent">
            <Grid Margin="0,2" Padding="4,2" Background="#0A03A9F4">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <!-- Indent -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Timestamp -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Icon -->
                    <ColumnDefinition Width="*"/>
                    <!-- Message -->
                </Grid.ColumnDefinitions>

                <!-- Subtle Blue -->
                <Border BorderBrush="#FF03A9F4" BorderThickness="2,0,0,0" HorizontalAlignment="Left"/>
                <!-- Left Accent -->
                
                <Rectangle Grid.Column="0" Width="36" Height="1" VerticalAlignment="Top" Margin="0,0,6,0" Fill="Transparent"/>
                <TextBlock Grid.Column="1" Text="{Binding Timestamp, Converter={StaticResource DateTimeFormatConverter}, ConverterParameter='HH:mm'}" FontSize="10" VerticalAlignment="Center" Margin="0,0,5,0" Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                <FontIcon Grid.Column="2" Glyph="" FontFamily="Segoe Fluent Icons" FontSize="14" Margin="0,0,6,0" VerticalAlignment="Center" Foreground="{Binding Platform, Converter={StaticResource PlatformToBrushConverter}}"/>
                <TextBlock Grid.Column="3" VerticalAlignment="Center"><Run Text="{Binding Converter={StaticResource HostEventTextConverter}}"/><Run Text="{Binding IsAutoHost, Converter={StaticResource AutoHostTextConverter}}" FontStyle="Italic"/></TextBlock>
            </Grid>
        </DataTemplate>

        <DataTemplate x:Key="SystemMessageDataTemplate" x:DataType="models_events:SystemMessageEvent">
            <Grid Margin="0,2" Padding="4,2" Background="#0A808080">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <!-- Indent -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Timestamp -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Icon -->
                    <ColumnDefinition Width="*"/>
                    <!-- Message -->
                </Grid.ColumnDefinitions>

                <!-- Subtle Gray -->
                <Border BorderBrush="{ThemeResource SystemControlForegroundBaseMediumBrush}" BorderThickness="2,0,0,0" HorizontalAlignment="Left"/>
                <!-- Left Accent -->
                
                <Rectangle Grid.Column="0" Width="36" Height="1" VerticalAlignment="Top" Margin="0,0,6,0" Fill="Transparent"/>
                <TextBlock Grid.Column="1" Text="{Binding Timestamp, Converter={StaticResource DateTimeFormatConverter}, ConverterParameter='HH:mm:ss'}" FontSize="10" VerticalAlignment="Center" Margin="0,0,5,0" Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                <FontIcon Grid.Column="2" Glyph="{Binding Level, Converter={StaticResource SystemLevelToSymbolConverter}}" FontFamily="Segoe Fluent Icons" FontSize="14" Margin="0,0,6,0" VerticalAlignment="Center" Foreground="{Binding Level, Converter={StaticResource SystemLevelToBrushConverter}}"/>
                <TextBlock Grid.Column="3" Text="{Binding Message}" TextWrapping="Wrap" FontStyle="Italic" Foreground="{ThemeResource SystemControlPageTextBaseMediumBrush}" VerticalAlignment="Center"/>
            </Grid>
        </DataTemplate>

        <DataTemplate x:Key="BotMessageDataTemplate" x:DataType="models_events:BotMessageEvent">
            <Grid Margin="0,2" Padding="4,2" Background="{ThemeResource LayerFillColorDefaultBrush}">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <!-- Indent -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Timestamp -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Icon -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Sender Name -->
                    <ColumnDefinition Width="Auto"/>
                    <!-- Arrow -->
                    <ColumnDefinition Width="*"/>
                    <!-- Message -->
                </Grid.ColumnDefinitions>
                
                <!-- Subtle Gray -->
                <Border BorderBrush="{ThemeResource AccentFillColorDefaultBrush}" BorderThickness="2,0,0,0" HorizontalAlignment="Left"/>
                <!-- Left Accent -->
                
                <Rectangle Grid.Column="0" Width="36" Height="1" VerticalAlignment="Top" Margin="0,0,6,0" Fill="Transparent"/>
                <TextBlock Grid.Column="1" Text="{Binding Timestamp, Converter={StaticResource DateTimeFormatConverter}, ConverterParameter='HH:mm'}" FontSize="10" VerticalAlignment="Center" Margin="0,0,5,0" Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                <FontIcon Grid.Column="2" Glyph="" FontFamily="Segoe Fluent Icons" FontSize="14" Margin="0,0,6,0" VerticalAlignment="Center" Foreground="{ThemeResource AccentFillColorDefaultBrush}"/>
                <TextBlock Grid.Column="3" Text="{Binding SenderDisplayName}" FontWeight="SemiBold" FontStyle="Italic" VerticalAlignment="Center" Foreground="{ThemeResource AccentTextFillColorPrimaryBrush}"/>
                <TextBlock Grid.Column="4" Text="»" VerticalAlignment="Center" Margin="4,0,4,0" FontWeight="Bold" Foreground="{ThemeResource AccentTextFillColorPrimaryBrush}"/>
                <RichTextBlock Grid.Column="5" helpers:RichTextBlockHelper.SegmentsSource="{Binding ParsedMessage}" TextWrapping="Wrap" VerticalAlignment="Center" IsTextSelectionEnabled="True" FontSize="{ThemeResource ControlContentThemeFontSize}"/>
            </Grid>
        </DataTemplate>

        <DataTemplate x:Key="CommandInvocationDataTemplate" x:DataType="models_events:CommandInvocationEvent">
            <Border Background="{ThemeResource SystemControlBackgroundListLowBrush}" BorderBrush="{ThemeResource ControlStrongStrokeColorDefaultBrush}" CornerRadius="4" BorderThickness="1" Margin="0,2" Padding="4,6">
                <StackPanel Spacing="4">
                    <!-- Original Command Message -->
                    <Grid Opacity="0.8">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="*"/>
                            <!-- No Mod Button Needed -->
                        </Grid.ColumnDefinitions>
                        <Ellipse Grid.Column="0" Style="{StaticResource ProfilePictureEllipseStyle}" Visibility="{Binding OriginalCommandMessage.Platform, Converter={StaticResource PlatformToVisibilityConverter}}">
                            <Ellipse.Fill>
                                <ImageBrush ImageSource="{Binding OriginalCommandMessage.ProfileImageUrl, FallbackValue={StaticResource DefaultProfilePicFallbackBrush}}" Stretch="UniformToFill"/>
                            </Ellipse.Fill>
                        </Ellipse>
                        <Grid Grid.Column="1" Margin="{Binding OriginalCommandMessage.Platform, Converter={StaticResource PlatformToMarginConverter}}">
                            <RichTextBlock helpers:RichTextBlockEventHelper.ChatEventSource="{Binding OriginalCommandMessage}" TextWrapping="Wrap" VerticalAlignment="Top" IsTextSelectionEnabled="True" FontSize="{ThemeResource ControlContentThemeFontSize}">
                                <RichTextBlock.Resources>
                                    <Style TargetType="Paragraph">
                                        <Setter Property="Margin" Value="0"/>
                                    </Style>
                                </RichTextBlock.Resources>
                            </RichTextBlock>
                        </Grid>
                    </Grid>
                    <!-- Bot Reply Message -->
                    <Grid Visibility="{Binding ReplyMessage, Converter={StaticResource StringToVisibilityConverter}}">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto"/>
                            <!-- Indent -->
                            <ColumnDefinition Width="Auto"/>
                            <!-- Icon -->
                            <ColumnDefinition Width="Auto"/>
                            <!-- Bot Name -->
                            <ColumnDefinition Width="Auto"/>
                            <!-- Arrow -->
                            <ColumnDefinition Width="*"/>
                            <!-- Reply Text -->
                        </Grid.ColumnDefinitions>
                        <Rectangle Grid.Column="0" Width="42" Margin="0,0,6,0"/>
                        <!-- Maintain indent -->
                        <FontIcon Grid.Column="1" Glyph="" FontFamily="Segoe Fluent Icons" FontSize="14" Margin="0,0,6,0" VerticalAlignment="Center" Foreground="{ThemeResource AccentFillColorDefaultBrush}"/>
                        <TextBlock Grid.Column="2" Text="{Binding BotSenderDisplayName}" FontWeight="SemiBold" FontStyle="Italic" VerticalAlignment="Center" Foreground="{ThemeResource AccentTextFillColorPrimaryBrush}"/>
                        <TextBlock Grid.Column="3" Text="»" VerticalAlignment="Center" Margin="4,0,4,0" FontWeight="Bold" Foreground="{ThemeResource AccentTextFillColorPrimaryBrush}"/>
                        <TextBlock Grid.Column="4" Text="{Binding ReplyMessage}" TextWrapping="Wrap" VerticalAlignment="Center" IsTextSelectionEnabled="True" FontSize="{ThemeResource ControlContentThemeFontSize}"/>
                    </Grid>
                </StackPanel>
            </Border>
        </DataTemplate>

        <DataTemplate x:Key="YouTubePollUpdateDataTemplate" x:DataType="models_events:YouTubePollUpdateEvent">
            <Grid Margin="0,2" Padding="6,4" Background="#10808080" CornerRadius="4">
                <Border BorderBrush="#FFB0B0B0" BorderThickness="2,0,0,0" HorizontalAlignment="Left"/>
                <!-- Left Accent -->
                <StackPanel Spacing="5">
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto"/>
                            <!-- Indent -->
                            <ColumnDefinition Width="Auto"/>
                            <!-- Timestamp -->
                            <ColumnDefinition Width="Auto"/>
                            <!-- Icon -->
                            <ColumnDefinition Width="*"/>
                            <!-- Title -->
                            <ColumnDefinition Width="Auto"/>
                            <!-- Status -->
                        </Grid.ColumnDefinitions>
                        <Rectangle Grid.Column="0" Width="36" Height="1" VerticalAlignment="Top" Margin="0,0,6,0" Fill="Transparent"/>
                        <TextBlock Grid.Column="1" Text="{Binding Timestamp, Converter={StaticResource DateTimeFormatConverter}, ConverterParameter='HH:mm'}" FontSize="10" VerticalAlignment="Center" Margin="0,0,5,0" Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                        <FontIcon Grid.Column="2" Glyph="" FontFamily="Segoe Fluent Icons" FontSize="14" Margin="0,0,6,0" VerticalAlignment="Center" Foreground="{Binding Platform, Converter={StaticResource PlatformToBrushConverter}}"/>
                        <TextBlock Grid.Column="3" Text="Poll:" FontWeight="SemiBold" VerticalAlignment="Center"/>
                        <TextBlock Grid.Column="4" FontWeight="SemiBold" VerticalAlignment="Center" HorizontalAlignment="Right" FontSize="10">
                             <!-- Corrected Binding -->
                             <Run Text="{Binding IsActive, Converter={StaticResource BoolToStringConverter}, ConverterParameter='Active;Closed'}"/>
                        </TextBlock>
                    </Grid>
                    <TextBlock Text="{Binding Question}" FontWeight="SemiBold" TextWrapping="Wrap" Margin="42,0,0,0"/>
                    <!-- Indented -->
                    <ItemsControl ItemsSource="{Binding Options}" Margin="42,0,0,0">
                        <!-- Indented -->
                        <ItemsControl.ItemTemplate>
                            <DataTemplate x:DataType="segments:PollOption">
                                <Grid Margin="0,2">
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="*"/>
                                        <ColumnDefinition Width="Auto"/>
                                    </Grid.ColumnDefinitions>
                                    <TextBlock Grid.Column="0" Text="{Binding Text}" TextTrimming="CharacterEllipsis"/>
                                    <TextBlock Grid.Column="1" Text="{Binding VotePercentage}" Margin="10,0,0,0" Visibility="{Binding VotePercentage, Converter={StaticResource StringToVisibilityConverter}}" Foreground="{ThemeResource TextFillColorSecondaryBrush}" FontSize="11"/>
                                </Grid>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </StackPanel>
            </Grid>
        </DataTemplate>

        <!-- Fallback template for unhandled event types -->
        <DataTemplate x:Key="DefaultTemplate">
            <Border Background="#1A808080" BorderBrush="Gray" BorderThickness="1" Margin="0,2" Padding="4,2">
                <TextBlock Opacity="0.7" FontStyle="Italic">
                     <Run Text="{Binding Platform, Mode=OneTime}"/><Run Text=" event: "/><Run Text="{Binding}"/>
                </TextBlock>
            </Border>
        </DataTemplate>

        <!-- The Template Selector -->
        <selectors:EventTemplateSelector x:Key="EventSelector"
                                         ChatMessageTemplate="{StaticResource ChatMessageDataTemplate}"
                                         SubscriptionTemplate="{StaticResource SubscriptionDataTemplate}"
                                         MembershipTemplate="{StaticResource MembershipDataTemplate}"
                                         DonationTemplate="{StaticResource DonationDataTemplate}"
                                         FollowTemplate="{StaticResource FollowDataTemplate}"
                                         RaidTemplate="{StaticResource RaidDataTemplate}"
                                         HostTemplate="{StaticResource HostDataTemplate}"
                                         SystemMessageTemplate="{StaticResource SystemMessageDataTemplate}"
                                         YouTubePollUpdateTemplate="{StaticResource YouTubePollUpdateDataTemplate}"
                                         ModerationActionTemplate="{StaticResource DefaultTemplate}"
                                         BotMessageTemplate="{StaticResource BotMessageDataTemplate}"
                                         CommandInvocationTemplate="{StaticResource CommandInvocationDataTemplate}"
                                         WhisperTemplate="{StaticResource DefaultTemplate}"
                                         DefaultTemplate="{StaticResource DefaultTemplate}"/>
    </Page.Resources>

    <!-- Main Layout Grid -->
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Chat List -->
        <ListView
            x:Name="ChatListView"
            Grid.Row="0"
            Margin="5"
            SelectionMode="None"
            ItemsSource="{Binding Events}"
            ItemTemplateSelector="{StaticResource EventSelector}"
            HorizontalContentAlignment="Stretch"
            ScrollViewer.VerticalScrollBarVisibility="Auto"
            ScrollViewer.HorizontalScrollBarVisibility="Disabled">

            <ListView.ItemContainerTransitions>
                <TransitionCollection>
                    <AddDeleteThemeTransition/>
                </TransitionCollection>
            </ListView.ItemContainerTransitions>
        </ListView>

        <!-- Input Area -->
        <Grid Grid.Row="1"
              Margin="5"
              VerticalAlignment="Bottom">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>

            <!-- Interactions Button -->
            <Button x:Name="InteractionsButton"
                    Grid.Column="0"
                    Margin="0,0,5,0"
                    Style="{StaticResource SubtleIconButton}"
                    VerticalAlignment="Center">
                <ToolTipService.ToolTip>
                    <ToolTip Content="Open Polls, Goals, etc."/>
                </ToolTipService.ToolTip>
                <FontIcon FontFamily="{StaticResource SymbolThemeFontFamily}"
                          Glyph=""/>
                <Button.Flyout>
                    <MenuFlyout>
                        <MenuFlyoutItem Text="Create YouTube Poll"
                                        Command="{Binding ShowCreatePollDialogCommand}"
                                        IsEnabled="{Binding CanCreateYouTubePoll}">
                            <MenuFlyoutItem.Icon>
                                <SymbolIcon Symbol="Accept" />
                            </MenuFlyoutItem.Icon>
                        </MenuFlyoutItem>
                        <MenuFlyoutItem Text="End Current YouTube Poll"
                                        Command="{Binding EndPollCommand}"
                                        IsEnabled="{Binding CanEndYouTubePoll}">
                            <MenuFlyoutItem.Icon>
                                <SymbolIcon Symbol="Cancel" />
                            </MenuFlyoutItem.Icon>
                        </MenuFlyoutItem>
                    </MenuFlyout>
                </Button.Flyout>
            </Button>

            <TextBox x:Name="MessageInputBox"
                     Grid.Column="1"
                     Margin="0,0,5,0"
                     Text="{Binding MessageToSend, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                     PlaceholderText="Send a message..."
                     AcceptsReturn="False"
                     KeyDown="MessageInputBox_KeyDown"/>
            <ComboBox Grid.Column="2"
                      Margin="0,0,5,0"
                      VerticalAlignment="Center"
                      MinWidth="120"
                      ItemsSource="{Binding SendTargets}"
                      SelectedItem="{Binding SelectedSendTarget, Mode=TwoWay}"
                      PlaceholderText="Send As...">
                <ComboBox.ItemTemplate>
                    <DataTemplate x:DataType="viewmodels:SendTarget">
                        <TextBlock Text="{Binding DisplayName}"/>
                    </DataTemplate>
                </ComboBox.ItemTemplate>
            </ComboBox>
            <Button x:Name="SendButton"
                    Grid.Column="3"
                    Content="Send"
                    Command="{Binding SendMessageCommand}"/>
        </Grid>
    </Grid>
</Page>
</file>

<file path="UI/Views/MainChatView.xaml.cs">
using System.Collections.Specialized;
using System.Diagnostics;
using CommunityToolkit.WinUI;
using Microsoft.Extensions.Logging;
using Microsoft.UI.Dispatching;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Input;
using Microsoft.UI.Xaml.Media;
using StreamWeaver.UI.ViewModels;
using Windows.System;
namespace StreamWeaver.UI.Views;
public sealed partial class MainChatView : Page
{
    private readonly ILogger<MainChatView> _logger;
    public MainChatViewModel ViewModel { get; }
    private bool _shouldScrollToBottom = true;
    private ScrollViewer? _chatScrollViewer;
    public MainChatView()
    {
        InitializeComponent();
        try
        {
            ViewModel = App.GetService<MainChatViewModel>();
            _logger = App.GetService<ILogger<MainChatView>>();
            DataContext = ViewModel;
            _logger.LogInformation("DataContext set to MainChatViewModel.");
        }
        catch (Exception ex)
        {
            try
            {
                App.GetService<ILogger<MainChatView>>()
                    ?.LogCritical(ex, "FATAL: Failed to resolve MainChatViewModel or ILogger. View cannot function.");
            }
            catch
            {
                Debug.WriteLine($"[MainChatView.Ctor] FATAL: Failed to resolve dependencies: {ex}");
            }
            throw new InvalidOperationException("Failed to initialize MainChatView dependencies.", ex);
        }
    }
    private void Page_Loaded(object sender, RoutedEventArgs e)
    {
        _logger.LogDebug("MainChatView Page_Loaded.");
        if (ViewModel?.Events != null)
        {
            ViewModel.Events.CollectionChanged -= Events_CollectionChanged;
            ViewModel.Events.CollectionChanged += Events_CollectionChanged;
            _logger.LogDebug("Subscribed to ViewModel Events CollectionChanged.");
        }
        else
        {
            _logger.LogError("ViewModel or ViewModel.Events collection is null on Page_Loaded. Cannot subscribe for auto-scroll.");
        }
        FindAndHookScrollViewer();
        _logger.LogDebug("Scheduling initial ScrollToBottom after a short delay.");
        _ = DispatcherQueue.EnqueueAsync(async () =>
        {
            _logger.LogTrace("Executing delayed initial ScrollToBottom...");
            await Task.Delay(250);
            if (IsLoaded)
            {
                await ScrollToBottom();
                _logger.LogDebug("Initial scroll attempt finished.");
            }
            else
            {
                _logger.LogDebug("Initial scroll cancelled as page was unloaded.");
            }
        });
    }
    private void FindAndHookScrollViewer()
    {
        if (_chatScrollViewer == null)
        {
            _chatScrollViewer = FindScrollViewer(ChatListView);
            if (_chatScrollViewer != null)
            {
                _chatScrollViewer.ViewChanged -= ScrollViewer_ViewChanged;
                _chatScrollViewer.ViewChanged += ScrollViewer_ViewChanged;
                _logger.LogInformation("Found and hooked ScrollViewer within ChatListView.");
            }
            else
            {
                _logger.LogWarning(
                    "Could not find the internal ScrollViewer for ChatListView on initial load. Auto-scroll may be delayed or disabled."
                );
            }
        }
        else
        {
            _chatScrollViewer.ViewChanged -= ScrollViewer_ViewChanged;
            _chatScrollViewer.ViewChanged += ScrollViewer_ViewChanged;
            _logger.LogDebug("ScrollViewer already cached, ensured ViewChanged event is hooked.");
        }
    }
    private void MessageInputBox_KeyDown(object sender, KeyRoutedEventArgs e)
    {
        if (e.Key == VirtualKey.Enter)
        {
            if (ViewModel?.SendMessageCommand?.CanExecute(null) ?? false)
            {
                _logger.LogDebug("Enter key pressed in input box, executing SendMessageCommand.");
                ViewModel.SendMessageCommand.Execute(null);
                e.Handled = true;
            }
            else
            {
                _logger.LogDebug("Enter key pressed in input box, but SendMessageCommand cannot execute or ViewModel is null.");
            }
        }
    }
    private void Events_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        if (e.Action == NotifyCollectionChangedAction.Add && _shouldScrollToBottom)
        {
            _logger.LogTrace("New items added and auto-scroll enabled. Enqueueing ScrollToBottom task.");
            _ = DispatcherQueue.EnqueueAsync(ScrollToBottom);
        }
        else if (e.Action == NotifyCollectionChangedAction.Reset)
        {
            _logger.LogDebug("Event collection reset. Re-enabling auto-scroll.");
            _shouldScrollToBottom = true;
            _ = DispatcherQueue.EnqueueAsync(ScrollToBottom);
        }
    }
    private void ScrollViewer_ViewChanged(object? sender, ScrollViewerViewChangedEventArgs e)
    {
        if (_chatScrollViewer != null && !e.IsIntermediate)
        {
            const double bottomTolerance = 10.0;
            bool isNearBottom = _chatScrollViewer.VerticalOffset >= _chatScrollViewer.ScrollableHeight - bottomTolerance;
            if (isNearBottom)
            {
                if (!_shouldScrollToBottom)
                {
                    _logger.LogDebug("User scrolled near bottom. Re-enabling auto-scroll.");
                    _shouldScrollToBottom = true;
                }
            }
            else
            {
                if (_shouldScrollToBottom)
                {
                    _logger.LogDebug(
                        "User scrolled up ({VerticalOffset}/{ScrollableHeight}). Disabling auto-scroll.",
                        _chatScrollViewer.VerticalOffset,
                        _chatScrollViewer.ScrollableHeight
                    );
                    _shouldScrollToBottom = false;
                }
            }
        }
    }
    private async Task ScrollToBottom()
    {
        if (_chatScrollViewer == null)
        {
            _logger.LogTrace("ScrollToBottom called, attempting to find ScrollViewer first.");
            FindAndHookScrollViewer();
            if (_chatScrollViewer == null)
            {
                _logger.LogWarning("ScrollToBottom: ScrollViewer not found. Cannot scroll.");
                return;
            }
        }
        await Task.Yield();
        await Task.Delay(50);
        if (ChatListView.Items.Count > 0)
        {
            try
            {
                object lastItem = ChatListView.Items[^1];
                _logger.LogTrace("Scrolling last item into view using default ScrollIntoView (after delay).");
                ChatListView.ScrollIntoView(lastItem, ScrollIntoViewAlignment.Leading);
                _shouldScrollToBottom = true;
            }
            catch (ArgumentOutOfRangeException ex)
            {
                _logger.LogWarning(ex, "Failed to get last item for scrolling (collection might have changed).");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error occurred during simple ScrollIntoView operation.");
            }
        }
        else
        {
            _logger.LogTrace("ScrollToBottom called but ChatListView is empty.");
        }
    }
    private static ScrollViewer? FindScrollViewer(DependencyObject element)
    {
        if (element is ScrollViewer viewer)
            return viewer;
        int childrenCount = VisualTreeHelper.GetChildrenCount(element);
        for (int i = 0; i < childrenCount; i++)
        {
            DependencyObject child = VisualTreeHelper.GetChild(element, i);
            ScrollViewer? result = FindScrollViewer(child);
            if (result != null)
                return result;
        }
        return null;
    }
    private void Page_Unloaded(object sender, RoutedEventArgs e)
    {
        _logger.LogInformation("Page unloaded. Unsubscribing from events.");
        if (ViewModel?.Events != null)
        {
            ViewModel.Events.CollectionChanged -= Events_CollectionChanged;
        }
        if (_chatScrollViewer != null)
        {
            _chatScrollViewer.ViewChanged -= ScrollViewer_ViewChanged;
        }
    }
}
</file>

<file path="UI/Views/SettingsPages/TtsSettingsPage.xaml">
<?xml version="1.0" encoding="utf-8"?>
<Page
    x:Class="StreamWeaver.UI.Views.SettingsPages.TtsSettingsPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:StreamWeaver.UI.Views.SettingsPages"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:viewmodels="using:StreamWeaver.UI.ViewModels"
    xmlns:converters="using:StreamWeaver.UI.Converters"
    xmlns:settings="using:StreamWeaver.Core.Models.Settings"
    xmlns:controls="using:CommunityToolkit.WinUI.Controls"
    xmlns:ui="using:CommunityToolkit.WinUI"
    mc:Ignorable="d"
    d:DataContext="{d:DesignInstance Type=viewmodels:SettingsViewModel, IsDesignTimeCreatable=False}"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Page.Resources>
        <x:Double x:Key="SettingsCardSpacing">4</x:Double>
        <converters:BoolToVisibilityConverter x:Key="BoolToVisibilityConverter"/>
        <converters:BoolToOpacityConverter x:Key="BoolToOpacityConverter"/>
        <StaticResource x:Key="DecimalFormatter" ResourceKey="DecimalFormatter"/>
        <StaticResource x:Key="IntegerFormatter" ResourceKey="IntegerFormatter"/>
        <converters:EqualityToVisibilityConverter x:Key="EngineToVisibilityConverter"/>

        <!-- Helper style for format TextBoxes -->
        <Style x:Key="FormatTextBoxStyle" TargetType="TextBox">
            <Setter Property="AcceptsReturn" Value="True"/>
            <Setter Property="TextWrapping" Value="Wrap"/>
            <Setter Property="MinHeight" Value="60"/>
            <Setter Property="Margin" Value="0,5,0,0"/>
        </Style>

        <!-- Style for nested settings StackPanel -->
        <Style x:Key="NestedSettingsStackPanelStyle" TargetType="StackPanel">
            <Setter Property="Margin" Value="48,5,0,10"/>
            <!-- Indent -->
            <Setter Property="Spacing" Value="10"/>
            <Setter Property="BorderBrush" Value="{ThemeResource CardStrokeColorDefault}"/>
            <Setter Property="BorderThickness" Value="0,0,0,1"/>
            <!-- Bottom border -->
            <Setter Property="Padding" Value="0,0,0,10"/>
            <!-- Padding below border -->
        </Style>

    </Page.Resources>

    <ScrollViewer VerticalScrollBarVisibility="Auto" Padding="20">
        <StackPanel Spacing="{StaticResource SettingsCardSpacing}">
            <TextBlock Text="Text-to-Speech (TTS)" Style="{ThemeResource SubtitleTextBlockStyle}" Margin="0,0,0,10"/>

            <!-- General Settings -->
            <controls:SettingsCard Header="Enable TTS" HeaderIcon="{ui:FontIcon Glyph=}">
                <ToggleSwitch IsOn="{Binding TtsSettings.Enabled, Mode=TwoWay}"/>
            </controls:SettingsCard>

            <controls:SettingsCard Header="TTS Engine" HeaderIcon="{ui:FontIcon Glyph=}" IsEnabled="{Binding TtsSettings.Enabled}">
                <RadioButtons ItemsSource="{Binding TtsEngineOptions}" SelectedItem="{Binding SelectedEngine, Mode=TwoWay}">
                    <RadioButtons.ItemTemplate>
                        <DataTemplate>
                            <TextBlock Text="{Binding}"/>
                        </DataTemplate>
                    </RadioButtons.ItemTemplate>
                </RadioButtons>
            </controls:SettingsCard>

            <controls:SettingsCard Header="Windows Voice" HeaderIcon="{ui:FontIcon Glyph=}"
                                   IsEnabled="{Binding TtsSettings.Enabled}"
                                   Visibility="{Binding SelectedEngine, Converter={StaticResource EngineToVisibilityConverter}, ConverterParameter='Windows'}">
                <ComboBox ItemsSource="{Binding WindowsVoices}"
                          SelectedItem="{Binding SelectedWindowsVoice, Mode=TwoWay}"
                          PlaceholderText="Default System Voice" MinWidth="200"/>
            </controls:SettingsCard>

            <controls:SettingsCard Header="Kokoro Voice" HeaderIcon="{ui:FontIcon Glyph=}"
                                   IsEnabled="{Binding TtsSettings.Enabled}"
                                   Visibility="{Binding SelectedEngine, Converter={StaticResource EngineToVisibilityConverter}, ConverterParameter='Kokoro'}">
                <ComboBox ItemsSource="{Binding KokoroVoices}"
                          SelectedItem="{Binding SelectedKokoroVoice, Mode=TwoWay}"
                          PlaceholderText="No Kokoro voices found" MinWidth="200"/>
            </controls:SettingsCard>

            <controls:SettingsCard Header="Volume and Rate" HeaderIcon="{ui:FontIcon Glyph=}" IsEnabled="{Binding TtsSettings.Enabled}">
                <controls:SettingsCard.Resources>
                    <!-- Define the resource directly inside the card's resources -->
                    <x:Double x:Key="SettingsCardWrapThreshold">600</x:Double>
                </controls:SettingsCard.Resources>
                <StackPanel Orientation="Horizontal" Spacing="10">
                    <Slider Header="Volume" Minimum="0" Maximum="100" Value="{Binding TtsSettings.Volume, Mode=TwoWay}" TickFrequency="10" TickPlacement="Inline" StepFrequency="1" MinWidth="150"/>
                    <Slider Header="Rate" Minimum="-10" Maximum="10" Value="{Binding TtsSettings.Rate, Mode=TwoWay}" TickFrequency="1" TickPlacement="Inline" StepFrequency="1" MinWidth="150"/>
                </StackPanel>
            </controls:SettingsCard>

            <controls:SettingsCard Header="Test TTS" HeaderIcon="{ui:FontIcon Glyph=}" IsEnabled="{Binding TtsSettings.Enabled}">
                <StackPanel Spacing="10">
                    <TextBox Text="{Binding TtsTestPhrase, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" PlaceholderText="Enter text here to test TTS..." AcceptsReturn="True" TextWrapping="Wrap" MinHeight="80"/>
                    <Button Content="Test" Command="{Binding TestTtsCommand}" HorizontalAlignment="Left"/>
                </StackPanel>
            </controls:SettingsCard>

                    <!-- Twitch Events -->
                    <controls:SettingsExpander Header="Twitch Events" HeaderIcon="{ui:FontIcon Glyph=}" IsEnabled="{Binding TtsSettings.Enabled}">
                        <controls:SettingsExpander.Items>
                            <controls:SettingsCard Header="Subscriptions / Resubs / Gifts" HeaderIcon="{ui:FontIcon Glyph=}">
                                <ToggleSwitch x:Name="TwitchSubsToggle" IsOn="{Binding TtsSettings.ReadTwitchSubs, Mode=TwoWay}"/>
                            </controls:SettingsCard>
                            <StackPanel Style="{StaticResource NestedSettingsStackPanelStyle}" Opacity="{Binding IsOn, ElementName=TwitchSubsToggle, Converter={StaticResource BoolToOpacityConverter}}">
                                <TextBox Header="New Sub Format" IsEnabled="{Binding IsOn, ElementName=TwitchSubsToggle}" Text="{Binding TtsSettings.NewSubMessageFormat, Mode=TwoWay}" Style="{StaticResource FormatTextBoxStyle}"/>
                                <TextBox Header="Resub Format" IsEnabled="{Binding IsOn, ElementName=TwitchSubsToggle}" Text="{Binding TtsSettings.ResubMessageFormat, Mode=TwoWay}" Style="{StaticResource FormatTextBoxStyle}"/>
                                <TextBox Header="Gift Sub Format" IsEnabled="{Binding IsOn, ElementName=TwitchSubsToggle}" Text="{Binding TtsSettings.GiftSubMessageFormat, Mode=TwoWay}" Style="{StaticResource FormatTextBoxStyle}"/>
                                <TextBox Header="Gift Bomb Format" IsEnabled="{Binding IsOn, ElementName=TwitchSubsToggle}" Text="{Binding TtsSettings.GiftBombMessageFormat, Mode=TwoWay}" Style="{StaticResource FormatTextBoxStyle}"/>
                            </StackPanel>

                            <controls:SettingsCard Header="Bits / Cheers" HeaderIcon="{ui:FontIcon Glyph=}">
                                <ToggleSwitch x:Name="TwitchBitsToggle" IsOn="{Binding TtsSettings.ReadTwitchBits, Mode=TwoWay}"/>
                            </controls:SettingsCard>
                            <StackPanel Style="{StaticResource NestedSettingsStackPanelStyle}" Opacity="{Binding IsOn, ElementName=TwitchBitsToggle, Converter={StaticResource BoolToOpacityConverter}}">
                                <NumberBox Header="Minimum Bits to Read" Minimum="0" Value="{Binding TtsSettings.MinimumBitAmountToRead, Mode=TwoWay}" IsEnabled="{Binding IsOn, ElementName=TwitchBitsToggle}" NumberFormatter="{StaticResource IntegerFormatter}" SpinButtonPlacementMode="Inline" SmallChange="10" LargeChange="100"/>
                                <TextBox Header="Bits Format" Text="{Binding TtsSettings.BitsMessageFormat, Mode=TwoWay}" IsEnabled="{Binding IsOn, ElementName=TwitchBitsToggle}" Style="{StaticResource FormatTextBoxStyle}"/>
                            </StackPanel>

                            <controls:SettingsCard Header="Raids" HeaderIcon="{ui:FontIcon Glyph=}">
                                <ToggleSwitch x:Name="TwitchRaidsToggle" IsOn="{Binding TtsSettings.ReadRaids, Mode=TwoWay}"/>
                            </controls:SettingsCard>
                            <StackPanel Style="{StaticResource NestedSettingsStackPanelStyle}" Opacity="{Binding IsOn, ElementName=TwitchRaidsToggle, Converter={StaticResource BoolToOpacityConverter}}">
                                <NumberBox Header="Minimum Raid Viewers to Read" Minimum="0" Value="{Binding TtsSettings.MinimumRaidViewersToRead, Mode=TwoWay}" IsEnabled="{Binding IsOn, ElementName=TwitchRaidsToggle}" NumberFormatter="{StaticResource IntegerFormatter}" SpinButtonPlacementMode="Inline" SmallChange="1" LargeChange="10"/>
                                <TextBox Header="Raid Format" Text="{Binding TtsSettings.RaidMessageFormat, Mode=TwoWay}" IsEnabled="{Binding IsOn, ElementName=TwitchRaidsToggle}" Style="{StaticResource FormatTextBoxStyle}"/>
                            </StackPanel>
                        </controls:SettingsExpander.Items>
                    </controls:SettingsExpander>

                    <!-- YouTube Events -->
                    <controls:SettingsExpander Header="YouTube Events" HeaderIcon="{ui:FontIcon Glyph=}" IsEnabled="{Binding TtsSettings.Enabled}">
                        <controls:SettingsExpander.Items>
                            <controls:SettingsCard Header="New Members" HeaderIcon="{ui:FontIcon Glyph=}">
                                <ToggleSwitch x:Name="YouTubeNewMembersToggle" IsOn="{Binding TtsSettings.ReadYouTubeNewMembers, Mode=TwoWay}"/>
                            </controls:SettingsCard>
                            <StackPanel Style="{StaticResource NestedSettingsStackPanelStyle}" Opacity="{Binding IsOn, ElementName=YouTubeNewMembersToggle, Converter={StaticResource BoolToOpacityConverter}}">
                                <TextBox Header="New Member Format" IsEnabled="{Binding IsOn, ElementName=YouTubeNewMembersToggle}" Text="{Binding TtsSettings.NewMemberMessageFormat, Mode=TwoWay}" Style="{StaticResource FormatTextBoxStyle}"/>
                            </StackPanel>

                            <controls:SettingsCard Header="Member Milestones" HeaderIcon="{ui:FontIcon Glyph=}">
                                <ToggleSwitch x:Name="YouTubeMilestonesToggle" IsOn="{Binding TtsSettings.ReadYouTubeMilestones, Mode=TwoWay}"/>
                            </controls:SettingsCard>
                            <StackPanel Style="{StaticResource NestedSettingsStackPanelStyle}" Opacity="{Binding IsOn, ElementName=YouTubeMilestonesToggle, Converter={StaticResource BoolToOpacityConverter}}">
                                <NumberBox Header="Minimum Milestone Months to Read" Minimum="1" Value="{Binding TtsSettings.MinimumMilestoneMonthsToRead, Mode=TwoWay}" IsEnabled="{Binding IsOn, ElementName=YouTubeMilestonesToggle}" NumberFormatter="{StaticResource IntegerFormatter}" SpinButtonPlacementMode="Inline" SmallChange="1" LargeChange="6"/>
                                <TextBox Header="Member Milestone Format" IsEnabled="{Binding IsOn, ElementName=YouTubeMilestonesToggle}" Text="{Binding TtsSettings.MemberMilestoneFormat, Mode=TwoWay}" Style="{StaticResource FormatTextBoxStyle}"/>
                            </StackPanel>

                            <controls:SettingsCard Header="Membership Gift Purchases (Gifter)" HeaderIcon="{ui:FontIcon Glyph=}">
                                <controls:SettingsCard.Description>Announce when a user purchases gift memberships for others.</controls:SettingsCard.Description>
                                <ToggleSwitch x:Name="YouTubeGiftPurchasesToggle" IsOn="{Binding TtsSettings.ReadYouTubeGiftPurchases, Mode=TwoWay}"/>
                            </controls:SettingsCard>
                            <StackPanel Style="{StaticResource NestedSettingsStackPanelStyle}" Opacity="{Binding IsOn, ElementName=YouTubeGiftPurchasesToggle, Converter={StaticResource BoolToOpacityConverter}}">
                                <NumberBox Header="Minimum Gifted Memberships to Read" Minimum="1" Value="{Binding TtsSettings.MinimumGiftCountToRead, Mode=TwoWay}" IsEnabled="{Binding IsOn, ElementName=YouTubeGiftPurchasesToggle}" NumberFormatter="{StaticResource IntegerFormatter}" SpinButtonPlacementMode="Inline" SmallChange="1" LargeChange="5"/>
                                <TextBox Header="Gift Purchase Format" IsEnabled="{Binding IsOn, ElementName=YouTubeGiftPurchasesToggle}" Text="{Binding TtsSettings.GiftedMemberPurchaseFormat, Mode=TwoWay}" Style="{StaticResource FormatTextBoxStyle}"/>
                            </StackPanel>

                            <controls:SettingsCard Header="Membership Gift Redemptions (Recipient)" HeaderIcon="{ui:FontIcon Glyph=}">
                                <controls:SettingsCard.Description>Announce when a user receives a gifted membership.</controls:SettingsCard.Description>
                                <ToggleSwitch x:Name="YouTubeGiftRedemptionsToggle" IsOn="{Binding TtsSettings.ReadYouTubeGiftRedemptions, Mode=TwoWay}"/>
                            </controls:SettingsCard>
                            <StackPanel Style="{StaticResource NestedSettingsStackPanelStyle}" Opacity="{Binding IsOn, ElementName=YouTubeGiftRedemptionsToggle, Converter={StaticResource BoolToOpacityConverter}}">
                                <TextBox Header="Gift Redemption Format" IsEnabled="{Binding IsOn, ElementName=YouTubeGiftRedemptionsToggle}" Text="{Binding TtsSettings.GiftedMemberRedemptionFormat, Mode=TwoWay}" Style="{StaticResource FormatTextBoxStyle}"/>
                            </StackPanel>

                            <controls:SettingsCard Header="Super Chats / Stickers" HeaderIcon="{ui:FontIcon Glyph=}">
                                <ToggleSwitch x:Name="YouTubeSuperChatsToggle" IsOn="{Binding TtsSettings.ReadSuperChats, Mode=TwoWay}"/>
                            </controls:SettingsCard>
                            <StackPanel Style="{StaticResource NestedSettingsStackPanelStyle}" Opacity="{Binding IsOn, ElementName=YouTubeSuperChatsToggle, Converter={StaticResource BoolToOpacityConverter}}">
                                <NumberBox Header="Minimum Super Chat Amount" Minimum="0" Value="{Binding TtsSettings.MinimumSuperChatAmountToRead, Mode=TwoWay}" IsEnabled="{Binding IsOn, ElementName=YouTubeSuperChatsToggle}" NumberFormatter="{StaticResource DecimalFormatter}" SpinButtonPlacementMode="Inline" SmallChange="0.5" LargeChange="1"/>
                                <TextBox Header="SuperChat Format" IsEnabled="{Binding IsOn, ElementName=YouTubeSuperChatsToggle}" Text="{Binding TtsSettings.SuperChatMessageFormat, Mode=TwoWay}" Style="{StaticResource FormatTextBoxStyle}"/>
                            </StackPanel>
                        </controls:SettingsExpander.Items>
                    </controls:SettingsExpander>

                    <!-- Other Events -->
                    <controls:SettingsExpander Header="Other Events" HeaderIcon="{ui:FontIcon Glyph=}" IsEnabled="{Binding TtsSettings.Enabled}">
                        <controls:SettingsExpander.Items>
                            <controls:SettingsCard Header="Streamlabs Donations" HeaderIcon="{ui:FontIcon Glyph=}">
                                <ToggleSwitch x:Name="StreamlabsDonationsToggle" IsOn="{Binding TtsSettings.ReadStreamlabsDonations, Mode=TwoWay}"/>
                            </controls:SettingsCard>
                            <StackPanel Style="{StaticResource NestedSettingsStackPanelStyle}" Opacity="{Binding IsOn, ElementName=StreamlabsDonationsToggle, Converter={StaticResource BoolToOpacityConverter}}">
                                <NumberBox Header="Minimum Donation Amount" Minimum="0" Value="{Binding TtsSettings.MinimumDonationAmountToRead, Mode=TwoWay}" IsEnabled="{Binding IsOn, ElementName=StreamlabsDonationsToggle}" NumberFormatter="{StaticResource DecimalFormatter}" SpinButtonPlacementMode="Inline" SmallChange="0.5" LargeChange="1"/>
                                <TextBox Header="Donation Format" IsEnabled="{Binding IsOn, ElementName=StreamlabsDonationsToggle}" Text="{Binding TtsSettings.DonationMessageFormat, Mode=TwoWay}" Style="{StaticResource FormatTextBoxStyle}"/>
                            </StackPanel>

                            <controls:SettingsCard Header="Follows" HeaderIcon="{ui:FontIcon Glyph=}">
                                <ToggleSwitch x:Name="FollowsToggle" IsOn="{Binding TtsSettings.ReadFollows, Mode=TwoWay}"/>
                            </controls:SettingsCard>
                            <StackPanel Style="{StaticResource NestedSettingsStackPanelStyle}" Opacity="{Binding IsOn, ElementName=FollowsToggle, Converter={StaticResource BoolToOpacityConverter}}">
                                <TextBox Header="Follow Format" IsEnabled="{Binding IsOn, ElementName=FollowsToggle}" Text="{Binding TtsSettings.FollowMessageFormat, Mode=TwoWay}" Style="{StaticResource FormatTextBoxStyle}"/>
                            </StackPanel>
                        </controls:SettingsExpander.Items>
                    </controls:SettingsExpander>
        </StackPanel>
    </ScrollViewer>
</Page>
</file>

<file path="MainWindow.xaml.cs">
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using StreamWeaver.Core.Plugins;
using StreamWeaver.Core.Services.Tts;
using StreamWeaver.Core.Services.Web;
using StreamWeaver.Core.Services;
using StreamWeaver.UI.ViewModels;
using StreamWeaver.UI.Views;
namespace StreamWeaver;
public sealed partial class MainWindow : Window
{
    private readonly ILogger<MainWindow> _logger;
    public MainWindowViewModel ViewModel { get; }
    public MainWindow(ILogger<MainWindow> logger, MainWindowViewModel viewModel)
    {
        _logger = logger;
        ViewModel = viewModel;
        _logger.LogInformation("Initializing...");
        InitializeComponent();
        ExtendsContentIntoTitleBar = true;
        if (AppTitleBar != null)
        {
            SetTitleBar(AppTitleBar);
            _logger.LogInformation("Custom title bar region set.");
        }
        else
        {
            _logger.LogWarning("AppTitleBar element not found in XAML. Custom drag region will not be active.");
        }
        NavView.Loaded += OnNavViewLoaded;
    }
    private void OnNavViewLoaded(object sender, RoutedEventArgs args)
    {
        if (NavView.MenuItems.Count > 0 && NavView.SelectedItem == null)
        {
            NavView.SelectedItem = NavView.MenuItems[0];
            Navigate("Chat");
            _logger.LogInformation("Initial navigation view set to Chat.");
        }
        NavView.Loaded -= OnNavViewLoaded;
    }
    private void NavView_SelectionChanged(NavigationView sender, NavigationViewSelectionChangedEventArgs args)
    {
        string? tag = null;
        if (args.IsSettingsSelected)
        {
            tag = "Settings";
        }
        else if (args.SelectedItemContainer?.Tag is string itemTag)
        {
            tag = itemTag;
        }
        if (!string.IsNullOrEmpty(tag))
        {
            _logger.LogDebug("NavigationView selection changed. Attempting navigation to view tag: {ViewTag}", tag);
            Navigate(tag);
        }
        else
        {
            _logger.LogWarning("NavigationView selection changed, but no valid tag found for navigation.");
        }
    }
    private void Navigate(string tag)
    {
        Type pageType = tag switch
        {
            "Chat" => typeof(MainChatView),
            "Logs" => typeof(LogsView),
            "Settings" => typeof(SettingsView),
            _ => typeof(MainChatView),
        };
        if (ContentFrame.CurrentSourcePageType != pageType)
        {
            _logger.LogInformation("Navigating ContentFrame to {PageType}", pageType.Name);
            ContentFrame.Navigate(pageType);
        }
        else
        {
            _logger.LogDebug("Navigation requested to {PageType}, but it is already the current page. Navigation skipped.", pageType.Name);
        }
    }
    private void MainWindow_Closed(object sender, WindowEventArgs args)
    {
        _logger.LogInformation("MainWindow_Closed event triggered. Explicitly disposing services...");
        try
        {
            var ttsService = App.GetService<ITtsService>();
            if (ttsService is IDisposable disposableTts)
            {
                _logger.LogDebug("Disposing ITtsService...");
                disposableTts.Dispose();
                _logger.LogDebug("ITtsService disposed.");
            }
            var webServerService = App.GetService<WebServerService>();
            _logger.LogDebug("Disposing WebServerService...");
            webServerService.Dispose();
            _logger.LogDebug("WebServerService disposed.");
            var unifiedEventService = App.GetService<UnifiedEventService>();
            if (unifiedEventService is IDisposable disposableUES)
            {
                _logger.LogDebug("Disposing UnifiedEventService...");
                disposableUES.Dispose();
                _logger.LogDebug("UnifiedEventService disposed.");
            }
            var pluginService = App.GetService<PluginService>();
            _logger.LogDebug("Disposing PluginService (initiating shutdown)...");
            Task.Run(() => pluginService.ShutdownPluginsAsync()).Wait(TimeSpan.FromSeconds(2));
            _logger.LogDebug("PluginService shutdown initiated.");
            _logger.LogInformation("Explicit service disposal completed in MainWindow_Closed.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during explicit service disposal in MainWindow_Closed.");
        }
    }
}
</file>

<file path="README.md">
### ⚠️⚠️⚠️ This is largly untested as of yet, as I don't stream myself. If anyone wants to help test this, please, hit me up! Below is what's currently implemented (at least has some code for it), not all confirmed to be in a *working* status so to say.

----

# StreamWeaver 🧵 woven chats, smooth streams! ✨


[![GitHub Actions Workflow Status](https://img.shields.io/github/actions/workflow/status/Agash/StreamWeaver/master.yml?style=flat-square&logo=github&logoColor=white)](https://github.com/Agash/StreamWeaver/actions)
[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg?style=flat-square)](LICENSE.txt)

Tired of juggling multiple chat windows? Wish you could see Twitch, YouTube, and maybe even Streamlabs events all in one place, looking *exactly* like they should? Enter **StreamWeaver!** 🎉

StreamWeaver is your friendly, free, and open-source desktop sidekick designed to wrangle the chaos of multi-platform streaming into a single, unified, and *actually useful* view. No more alt-tabbing nightmares or missing important messages!

## What's the Big Deal? 🤔

*   **One Chat to Rule Them All:** Connect multiple *distinct* Twitch and YouTube accounts. That means, multiple YouTube and multiple Twitch Accounts. See all your chats combined, but styled accurately for each platform. 👑
*   **Know Your Platforms:** Messages look like they belong – Twitch subs look like Twitch subs, YouTube Super Chats look like Super Chats (colors and all!). 🎨
*   **Event Horizon (The Good Kind):** Catches not just chat, but also subs, follows, raids, memberships, Super Chats, donations (via Streamlabs), and more! 📢
*   **Talk Back!** Send messages from any of your connected accounts right from the app. 🗣️
*   **Moderation Power:** Timeout, Ban, and Delete messages directly on YouTube (using the official API!). Twitch moderation coming soon™. 🛡️
*   **Engage Your Audience:** Create and end YouTube Polls directly from the app! (Goals coming soon™). 📊
*   **OBS Overlay Included:** A built-in browser source overlay to show your unified chat on stream. Customizable, naturally. 📺
*   **Installer & Auto-Updates:** Easy installation and automatic updates via GitHub Releases (Planned). ✨
*   **Advanced TTS Options:** Includes standard Windows TTS and plans for high-quality KokoroSharp TTS voices (Planned, including sound playback before & after). 🔊
*   **Plugin Power!** Extend StreamWeaver's capabilities with C# plugins (more features planned!). 🔌
*   **Built with Modern .NET:** Crafted using C# 13, .NET 9, and WinUI 3 for a native Windows experience. 💻
*   **Free & Open Source:** Use it, peek at the code, suggest changes, make it your own! It's all MIT licensed. 💖

## ⚠️ Important: API Credentials ⚠️

StreamWeaver requires **you** to provide your own API Client ID and Client Secret for both Twitch and YouTube (via their respective developer consoles). **This is mandatory and by design.**

**Why?**

1.  **Security & Control:** You authenticate directly with Twitch/Google. StreamWeaver never sees your password. You grant permissions *only* to your own developer application, giving you full control over access to your account. Using shared credentials would be a major security risk.
2.  **API Quotas:** Platforms like Twitch and Google impose usage limits (quotas) on API calls. By using your own credentials, your usage is tied to your application, preventing the entire StreamWeaver user base from being blocked if one shared key hits its limit. This ensures fair and reliable access for everyone.
3.  **Platform Terms of Service:** Using individual API keys and user authentication aligns with the Terms of Service for Twitch and Google APIs, which generally require applications to act on behalf of authenticated users via their own approved applications.
4.  **Transparency:** You know exactly what application is accessing your data because you created it.

You can create API credentials here:
*   **Twitch:** [https://dev.twitch.tv/console/apps](https://dev.twitch.tv/console/apps)
*   **Google/YouTube:** [https://console.cloud.google.com/apis/credentials](https://console.cloud.google.com/apis/credentials)

Please refer to the setup documentation (coming soon) or the settings page within StreamWeaver for guidance on configuring the Redirect URIs needed during credential setup (`http://localhost:5081/callback/twitch` and `http://localhost:5081/callback/google`).

## Current Status (As of April 2025) 🚧

*   **Twitch:** ✅ Chat Read/Send, ✅ Event Parsing (Subs, Raids, Follows, etc.). ⏳ Moderation actions planned.
*   **YouTube:** ✅ Chat Read (via unofficial API), ✅ Chat Send (Official API), ✅ Membership/Super Chat Events, ✅ Moderation Actions (Delete, Timeout, Ban - Official API), ✅ Poll Creation/Ending (Official API). ⏳ Goal features planned.
*   **Streamlabs:** ✅ Basic Connection (Socket API), ✅ Donation Events. ⏳ Parsing for other SL event types planned.
*   **Overlays:** ✅ Basic Chat Overlay functionality.⏳ Proper display pending ⏳ Enhancements & other overlay types planned.
*   **TTS:** ✅ Basic Windows TTS implementation. ⏳ KokoroSharp (fast, local, natural TTS) integration, Queued playback, Enhanced formatting planned.
*   **Installer:** ⏳ Installer with auto-updates planned.
*   **Plugins:** ✅ Basic C# plugin system functional. ⏳ Basic JavaScript plugin system planned.

## Tech Stack 🤓

*   **Core:** C# 13 / .NET 9
*   **UI:** WinUI 3 (Windows App SDK)
*   **Architecture:** MVVM (CommunityToolkit.Mvvm), Dependency Injection
*   **Platform Libs:** TwitchLib, Google.Apis.YouTube.v3, YTLiveChat (Unofficial Reader), SocketIOClient, **KokoroSharp (Planned)**
*   **Web Server:** ASP.NET Core Kestrel
*   **Installer:** Velopack

## ⚠️ Disclaimer: The YouTube Reading Part ⚠️

StreamWeaver uses the excellent [**YTLiveChat**](https://github.com/Agash/YTLiveChat) (_cough cough self promotion_) library to *read* YouTube chat messages. This library uses the same internal methods your web browser does, which means **it doesn't need an official YouTube Data API key and doesn't consume your API quota for reading chat**.

However, this is an **unofficial** method. YouTube *could* change their internal workings at any time, which might break chat reading until the library (or StreamWeaver) is updated. Use this feature with that understanding!

**Sending messages, moderating, and creating polls/goals on YouTube *does* use the official API** and requires you to provide your own API credentials and consent via OAuth.

## Contributing 🙏

Got ideas? Found a bug? Want to help build the ultimate streamer tool? Contributions are welcome! Check out the issues tab or feel free to submit a pull request.

---

Let's weave those streams together! Happy streaming! 🚀
</file>

<file path="UI/ViewModels/MainChatViewModel.cs">
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using Microsoft.Extensions.Logging;
using Microsoft.UI.Dispatching;
using Microsoft.UI.Xaml.Controls;
using StreamWeaver.Core.Messaging;
using StreamWeaver.Core.Models.Events;
using StreamWeaver.Core.Models.Settings;
using StreamWeaver.Core.Services;
using StreamWeaver.Core.Services.Platforms;
using StreamWeaver.Core.Services.Settings;
using StreamWeaver.UI.Dialogs;
namespace StreamWeaver.UI.ViewModels;
public partial class MainChatViewModel : ObservableObject, IRecipient<NewEventMessage>, IRecipient<ConnectionsUpdatedMessage>, IDisposable
{
    private const int MAX_MESSAGES = 200;
    private readonly ILogger<MainChatViewModel> _logger;
    private readonly IMessenger _messenger;
    private readonly UnifiedEventService _unifiedEventService;
    private readonly ISettingsService _settingsService;
    private readonly ITwitchClient _twitchClient;
    private readonly IYouTubeClient _youTubeClient;
    private readonly DispatcherQueue _dispatcherQueue;
    private bool _isDisposed = false;
    [ObservableProperty]
    public partial ObservableCollection<BaseEvent> Events { get; set; } = [];
    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(SendMessageCommand))]
    public partial string? MessageToSend { get; set; }
    [ObservableProperty]
    public partial ObservableCollection<SendTarget> SendTargets { get; set; } = [];
    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(SendMessageCommand))]
    [NotifyPropertyChangedFor(nameof(CanCreateYouTubePoll))]
    [NotifyPropertyChangedFor(nameof(CanEndYouTubePoll))]
    [NotifyCanExecuteChangedFor(nameof(ShowCreatePollDialogCommand))]
    [NotifyCanExecuteChangedFor(nameof(EndPollCommand))]
    public partial SendTarget? SelectedSendTarget { get; set; }
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanEndYouTubePoll))]
    [NotifyCanExecuteChangedFor(nameof(EndPollCommand))]
    public partial string? ActivePollMessageId { get; set; }
    public bool CanCreateYouTubePoll => SelectedSendTarget?.Platform is "YouTube" or "All";
    public bool CanEndYouTubePoll => CanCreateYouTubePoll && !string.IsNullOrWhiteSpace(ActivePollMessageId);
    public MainChatViewModel(
        ILogger<MainChatViewModel> logger,
        IMessenger messenger,
        UnifiedEventService unifiedEventService,
        ISettingsService settingsService,
        ITwitchClient twitchClient,
        IYouTubeClient youTubeClient,
        DispatcherQueue dispatcherQueue
    )
    {
        _logger = logger;
        _messenger = messenger;
        _unifiedEventService = unifiedEventService;
        _settingsService = settingsService;
        _twitchClient = twitchClient;
        _youTubeClient = youTubeClient;
        _dispatcherQueue = dispatcherQueue;
        _messenger.Register<NewEventMessage>(this);
        _messenger.Register<ConnectionsUpdatedMessage>(this);
        UpdateSendTargets();
        _logger.LogInformation("Initialized and registered for messages.");
    }
    private void UpdateSendTargets() =>
         _dispatcherQueue.TryEnqueue(() =>
         {
             if (_isDisposed)
                 return;
             _logger.LogDebug("Updating send targets...");
             AppSettings currentSettings = _settingsService.CurrentSettings;
             List<SendTarget> newTargets = [];
             int connectedTargetsCount = 0;
             if (currentSettings.Connections?.TwitchAccounts != null)
             {
                 foreach (TwitchAccount twitchAcc in currentSettings.Connections.TwitchAccounts)
                 {
                     if (!string.IsNullOrEmpty(twitchAcc.UserId) && IsAccountConnected(twitchAcc.UserId, "Twitch"))
                     {
                         newTargets.Add(
                             new SendTarget
                             {
                                 DisplayName = $"Twitch: {twitchAcc.Username}",
                                 Platform = "Twitch",
                                 AccountId = twitchAcc.UserId,
                                 AccountChannelName = twitchAcc.Username,
                             }
                         );
                         connectedTargetsCount++;
                         _logger.LogTrace("Added connected Twitch target: {Username} ({UserId})", twitchAcc.Username, twitchAcc.UserId);
                     }
                 }
             }
             if (currentSettings.Connections?.YouTubeAccounts != null)
             {
                 foreach (YouTubeAccount ytAcc in currentSettings.Connections.YouTubeAccounts)
                 {
                     if (!string.IsNullOrEmpty(ytAcc.ChannelId) && IsAccountConnected(ytAcc.ChannelId, "YouTube"))
                     {
                         newTargets.Add(
                             new SendTarget
                             {
                                 DisplayName = $"YouTube: {ytAcc.ChannelName}",
                                 Platform = "YouTube",
                                 AccountId = ytAcc.ChannelId,
                                 AccountChannelName = ytAcc.ChannelName,
                             }
                         );
                         connectedTargetsCount++;
                         _logger.LogTrace("Added connected YouTube target: {ChannelName} ({ChannelId})", ytAcc.ChannelName, ytAcc.ChannelId);
                     }
                 }
             }
             if (connectedTargetsCount > 1)
             {
                 _logger.LogTrace("Adding 'All' target.");
                 newTargets.Insert(
                     0,
                     new SendTarget
                     {
                         DisplayName = "All",
                         Platform = "All",
                         AccountId = null,
                         AccountChannelName = null,
                     }
                 );
             }
             SendTarget? previouslySelected = SelectedSendTarget;
             var currentTargetKeys = SendTargets.Select(t => $"{t.Platform}_{t.AccountId ?? "all"}").ToHashSet();
             var newTargetKeys = newTargets.Select(t => $"{t.Platform}_{t.AccountId ?? "all"}").ToHashSet();
             var targetsToRemove = SendTargets.Where(t => !newTargetKeys.Contains($"{t.Platform}_{t.AccountId ?? "all"}")).ToList();
             foreach (SendTarget? target in targetsToRemove)
             {
                 SendTargets.Remove(target);
             }
             var targetsToAdd = newTargets.Where(t => !currentTargetKeys.Contains($"{t.Platform}_{t.AccountId ?? "all"}")).ToList();
             foreach (SendTarget? target in targetsToAdd)
             {
                 // Maintain order if possible (add specific accounts after 'All')
                 if (target.Platform == "All")
                     SendTargets.Insert(0, target);
                 else
                     SendTargets.Add(target);
             }
             SendTarget? newSelection = null;
             if (previouslySelected != null)
             {
                 newSelection = SendTargets.FirstOrDefault(t =>
                     t.Platform == previouslySelected.Platform && t.AccountId == previouslySelected.AccountId
                 );
             }
             SelectedSendTarget = newSelection ?? SendTargets.FirstOrDefault();
             _logger.LogInformation(
                 "Send targets updated. Count: {Count}. Selected: {SelectedTarget}",
                 SendTargets.Count,
                 SelectedSendTarget?.DisplayName ?? "None"
             );
             OnPropertyChanged(nameof(SelectedSendTarget));
             OnPropertyChanged(nameof(CanCreateYouTubePoll));
             OnPropertyChanged(nameof(CanEndYouTubePoll));
             ShowCreatePollDialogCommand.NotifyCanExecuteChanged();
             EndPollCommand.NotifyCanExecuteChanged();
             SendMessageCommand.NotifyCanExecuteChanged();
         });
    public void Receive(NewEventMessage message)
    {
        if (_isDisposed) return;
        _dispatcherQueue.TryEnqueue(() =>
        {
            if (_isDisposed) return;
            if (Events.Any(e => e.Id == message.Value.Id))
            {
                _logger.LogWarning("Attempted to add duplicate event with ID {EventId}. Skipping.", message.Value.Id);
                return;
            }
            Events.Add(message.Value);
            _logger.LogDebug("Added event {EventType} ({EventId}) to display collection. New count: {Count}",
                message.Value.GetType().Name,
                message.Value.Id,
                Events.Count);
            while (Events.Count > MAX_MESSAGES)
            {
                BaseEvent removed = Events[0];
                _logger.LogTrace("Max messages ({MaxCount}) reached. Removing oldest event {EventType} ({EventId}).", MAX_MESSAGES, removed.GetType().Name, removed.Id);
                Events.RemoveAt(0);
            }
        });
    }
    public void Receive(ConnectionsUpdatedMessage message)
    {
        if (_isDisposed) return;
        _logger.LogInformation("Received ConnectionsUpdatedMessage. Refreshing send targets.");
        UpdateSendTargets();
    }
    private bool CanSendMessage() => !string.IsNullOrWhiteSpace(MessageToSend) && SelectedSendTarget != null && SendTargets.Count > 0;
    [RelayCommand(CanExecute = nameof(CanSendMessage))]
    private async Task SendMessageAsync()
    {
        [MemberNotNullWhen(true, nameof(MessageToSend), nameof(SelectedSendTarget))]
        bool CanSendGuard() => CanSendMessage();
        if (!CanSendGuard())
        {
            _logger.LogWarning("SendMessageAsync called but CanSendMessage returned false or critical properties are null.");
            return;
        }
        string message = MessageToSend;
        SendTarget selectedTargetInfo = SelectedSendTarget;
        MessageToSend = string.Empty;
        _logger.LogInformation("Send requested. Target: {TargetDisplayName}, Message: '{MessageContent}'", selectedTargetInfo.DisplayName, message);
        List<SendTarget> targetsToSendTo = [];
        bool isSendAll = selectedTargetInfo.Platform == "All";
        if (isSendAll)
        {
            targetsToSendTo.AddRange(SendTargets.Where(t => t.IsSpecificAccount && IsAccountConnected(t.AccountId, t.Platform)));
            _logger.LogDebug("Sending to 'All Connected'. Found {Count} specific connected targets.", targetsToSendTo.Count);
        }
        else if (selectedTargetInfo.IsSpecificAccount && IsAccountConnected(selectedTargetInfo.AccountId, selectedTargetInfo.Platform))
        {
            targetsToSendTo.Add(selectedTargetInfo);
            _logger.LogDebug("Sending to specific target: {TargetDisplayName}", selectedTargetInfo.DisplayName);
        }
        if (targetsToSendTo.Count == 0)
        {
            _logger.LogWarning("No valid/connected targets found for sending the message.");
            MessageToSend = message;
            return;
        }
        List<Task> sendTasks = [];
        foreach (SendTarget individualTarget in targetsToSendTo)
        {
            string? targetId = null;
            if (individualTarget.Platform == "Twitch")
            {
                targetId = individualTarget.AccountChannelName;
            }
            else if (individualTarget.Platform == "YouTube" && individualTarget.AccountId != null)
            {
                targetId = await GetYouTubeLiveChatIdAsync(individualTarget.AccountId, "SendMessage");
                if (targetId == null)
                {
                    _logger.LogError("Skipping send for YouTube account {AccId}: Could not determine LiveChatId.", individualTarget.AccountId);
                    continue;
                }
            }
            if (string.IsNullOrEmpty(targetId) || individualTarget.AccountId == null)
            {
                _logger.LogWarning("Skipping send for {TargetDisplayName}: Could not determine target ID or Account ID is missing.", individualTarget.DisplayName);
                continue;
            }
            _logger.LogDebug("Queueing send task for {Platform} account {AccountId} to target '{TargetId}'.", individualTarget.Platform, individualTarget.AccountId, targetId);
            sendTasks.Add(_unifiedEventService.SendChatMessageAsync(individualTarget.Platform, individualTarget.AccountId, targetId, message));
        }
        try
        {
            await Task.WhenAll(sendTasks);
            _logger.LogInformation("{Count} send operations completed.", sendTasks.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error occurred during batch message sending process.");
        }
    }
    private bool IsAccountConnected(string? accountId, string platform)
    {
        if (string.IsNullOrEmpty(accountId)) return false;
        bool isConnected = platform.ToLowerInvariant() switch
        {
            "twitch" => _twitchClient.GetStatus(accountId) == ConnectionStatus.Connected,
            "youtube" => _youTubeClient.GetStatus(accountId) is ConnectionStatus.Connected or ConnectionStatus.Limited,
            _ => false
        };
        _logger.LogTrace("Connectivity check for {Platform} account {AccountId}: {IsConnected}", platform, accountId, isConnected);
        return isConnected;
    }
    private async Task<string?> GetYouTubeLiveChatIdAsync(string moderatorAccountId, string actionName)
    {
        string? liveChatId = _youTubeClient.GetAssociatedLiveChatId(moderatorAccountId);
        if (!string.IsNullOrEmpty(liveChatId))
        {
            _logger.LogDebug("{Action}: Found cached AssociatedLiveChatId: {LiveChatId}", actionName, liveChatId);
            return liveChatId;
        }
        _logger.LogWarning("{Action}: AssociatedLiveChatId not found for account {AccountId}. Attempting on-demand lookup...", actionName, moderatorAccountId);
        string? videoId = _youTubeClient.GetActiveVideoId(moderatorAccountId);
        if (string.IsNullOrEmpty(videoId))
        {
            YouTubeAccount? account = _settingsService.CurrentSettings?.Connections?.YouTubeAccounts?.FirstOrDefault(a => a.ChannelId == moderatorAccountId);
            if (account != null && !string.IsNullOrEmpty(account.OverrideVideoId))
            {
                videoId = account.OverrideVideoId;
                _logger.LogDebug("{Action}: Using account OverrideVideoId '{VideoId}' for lookup.", actionName, videoId);
            }
            else if (!string.IsNullOrEmpty(_settingsService.CurrentSettings?.Connections?.DebugYouTubeLiveChatId))
            {
                videoId = _settingsService.CurrentSettings.Connections.DebugYouTubeLiveChatId;
                _logger.LogDebug("{Action}: Using global DebugYouTubeLiveChatId '{VideoId}' for lookup.", actionName, videoId);
            }
        }
        if (string.IsNullOrEmpty(videoId))
        {
            _logger.LogError("{Action} failed: Cannot lookup LiveChatId because no active VideoID is being monitored or configured for account {AccountId}.", actionName, moderatorAccountId);
            SendSystemMessage($"Cannot perform '{actionName}': YouTube stream is not currently being monitored.", SystemMessageLevel.Error);
            return null;
        }
        liveChatId = await _youTubeClient.LookupAndStoreLiveChatIdAsync(moderatorAccountId, videoId);
        if (string.IsNullOrEmpty(liveChatId))
        {
            _logger.LogError("{Action} failed: Could not retrieve LiveChatId for monitored VideoID {VideoId} using account {AccountId}.", actionName, videoId, moderatorAccountId);
            SendSystemMessage($"Cannot perform '{actionName}': Failed to get LiveChatId for video '{videoId}'.", SystemMessageLevel.Error);
            return null;
        }
        _logger.LogInformation("{Action}: Successfully looked up and stored LiveChatId: {LiveChatId}", actionName, liveChatId);
        return liveChatId;
    }
    private bool CanExecuteYouTubeAction(ChatMessageEvent? message)
    {
        if (message == null || message.Platform != "YouTube" || string.IsNullOrEmpty(message.OriginatingAccountId))
        {
            return false;
        }
        ConnectionStatus status = _youTubeClient.GetStatus(message.OriginatingAccountId);
        return status is ConnectionStatus.Connected or ConnectionStatus.Limited;
    }
    [RelayCommand(CanExecute = nameof(CanExecuteYouTubeAction))]
    private async Task TimeoutUserAsync(ChatMessageEvent? message)
    {
        const string actionName = "TimeoutUser";
        if (message?.UserId == null || message.OriginatingAccountId == null)
        {
            _logger.LogWarning("{Action} cancelled: Message, UserID, or OriginatingAccountID is null.", actionName);
            return;
        }
        string moderatorAccountId = message.OriginatingAccountId;
        string userIdToTimeout = message.UserId;
        uint durationSeconds = 600;
        _logger.LogInformation("{Action}: Attempting for user {Username} ({UserId}) for {Duration}s via account {AccountId}", actionName, message.Username, userIdToTimeout, durationSeconds, moderatorAccountId);
        string? liveChatId = await GetYouTubeLiveChatIdAsync(moderatorAccountId, actionName);
        if (liveChatId == null) return;
        try
        {
            await _youTubeClient.TimeoutUserAsync(moderatorAccountId, liveChatId, userIdToTimeout, durationSeconds);
            _logger.LogInformation("{Action} request sent successfully for user {UserId}.", actionName, userIdToTimeout);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "{Action} API call failed for user {UserId}", actionName, userIdToTimeout);
            SendSystemMessage($"Error timing out {message.Username}: {ex.Message}", SystemMessageLevel.Error);
        }
    }
    [RelayCommand(CanExecute = nameof(CanExecuteYouTubeAction))]
    private async Task BanUserAsync(ChatMessageEvent? message)
    {
        const string actionName = "BanUser";
        if (message?.UserId == null || message.OriginatingAccountId == null)
        {
            _logger.LogWarning("{Action} cancelled: Message, UserID, or OriginatingAccountID is null.", actionName);
            return;
        }
        string moderatorAccountId = message.OriginatingAccountId;
        string userIdToBan = message.UserId;
        _logger.LogInformation("{Action}: Attempting for user {Username} ({UserId}) via account {AccountId}", actionName, message.Username, userIdToBan, moderatorAccountId);
        string? liveChatId = await GetYouTubeLiveChatIdAsync(moderatorAccountId, actionName);
        if (liveChatId == null) return;
        try
        {
            await _youTubeClient.BanUserAsync(moderatorAccountId, liveChatId, userIdToBan);
            _logger.LogInformation("{Action} request sent successfully for user {UserId}.", actionName, userIdToBan);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "{Action} API call failed for user {UserId}", actionName, userIdToBan);
            SendSystemMessage($"Error banning {message.Username}: {ex.Message}", SystemMessageLevel.Error);
        }
    }
    [RelayCommand(CanExecute = nameof(CanExecuteYouTubeAction))]
    private async Task DeleteMessageAsync(ChatMessageEvent? message)
    {
        const string actionName = "DeleteMessage";
        if (message?.Id == null || message.OriginatingAccountId == null)
        {
            _logger.LogWarning("{Action} cancelled: Message, Message.Id, or OriginatingAccountID is null.", actionName);
            return;
        }
        string moderatorAccountId = message.OriginatingAccountId;
        string messageId = message.Id;
        _logger.LogInformation("{Action}: Attempting for message {MessageId} via account {AccountId}", actionName, messageId, moderatorAccountId);
        try
        {
            await _youTubeClient.DeleteMessageAsync(moderatorAccountId, messageId);
            _logger.LogInformation("{Action} request sent successfully for message {MessageId}.", actionName, messageId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "{Action} API call failed for message {MessageId}", actionName, messageId);
            SendSystemMessage($"Error deleting message from {message.Username}: {ex.Message}", SystemMessageLevel.Error);
        }
    }
    [RelayCommand(CanExecute = nameof(CanCreateYouTubePoll))]
    private async Task ShowCreatePollDialogAsync()
    {
        const string actionName = "CreatePoll";
        if (SelectedSendTarget == null)
        {
            _logger.LogError("{Action} cannot proceed: No send target selected.", actionName);
            return;
        }
        string? moderatorAccountId = GetModeratorAccountId(actionName);
        if (string.IsNullOrEmpty(moderatorAccountId)) return;
        string? liveChatId = await GetYouTubeLiveChatIdAsync(moderatorAccountId, actionName);
        if (string.IsNullOrEmpty(liveChatId)) return;
        var dialogViewModel = new CreatePollDialogViewModel();
        var dialog = new CreatePollDialog
        {
            DataContext = dialogViewModel,
            XamlRoot = App.MainWindow?.Content?.XamlRoot
        };
        if (dialog.XamlRoot == null)
        {
            _logger.LogError("{Action} cancelled: Cannot show dialog because XamlRoot is null.", actionName);
            SendSystemMessage("Error showing poll dialog.", SystemMessageLevel.Error);
            return;
        }
        ContentDialogResult result = await dialog.ShowAsync();
        if (result == ContentDialogResult.Primary)
        {
            if (dialogViewModel.TryGetValidatedData(out string? question, out List<string>? options))
            {
                _logger.LogInformation("{Action}: Dialog confirmed and data is valid. Question: '{Question}', Options: {OptionCount}", actionName, question, options.Count);
                try
                {
                    string? pollMessageId = await _youTubeClient.CreatePollAsync(moderatorAccountId, liveChatId, question, options);
                    if (!string.IsNullOrEmpty(pollMessageId))
                    {
                        _logger.LogInformation("{Action} succeeded. Poll Message ID: {PollMessageId}", actionName, pollMessageId);
                        ActivePollMessageId = pollMessageId;
                        SendSystemMessage($"YouTube poll created successfully: '{question}'", SystemMessageLevel.Info);
                    }
                    else
                    {
                        _logger.LogError("{Action} failed: CreatePollAsync returned null/empty ID.", actionName);
                        SendSystemMessage($"Failed to create YouTube poll: '{question}'. API call failed.", SystemMessageLevel.Error);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "{Action} failed during API call.", actionName);
                    SendSystemMessage($"Error creating YouTube poll: {ex.Message}", SystemMessageLevel.Error);
                }
            }
            else
            {
                _logger.LogError("{Action}: Dialog returned Primary but validation failed unexpectedly.", actionName);
            }
        }
        else
        {
            _logger.LogInformation("{Action}: Dialog cancelled by user.", actionName);
        }
    }
    [RelayCommand(CanExecute = nameof(CanEndYouTubePoll))]
    private async Task EndPollAsync()
    {
        const string actionName = "EndPoll";
        if (string.IsNullOrWhiteSpace(ActivePollMessageId))
        {
            _logger.LogError("{Action} cannot proceed: ActivePollMessageId is null or empty.", actionName);
            return;
        }
        if (SelectedSendTarget == null)
        {
            _logger.LogError("{Action} cannot proceed: No send target selected.", actionName);
            return;
        }
        string? moderatorAccountId = GetModeratorAccountId(actionName);
        if (string.IsNullOrEmpty(moderatorAccountId)) return;
        _logger.LogInformation("{Action}: Attempting for Poll Message ID: {PollId} using account {AccountId}", actionName, ActivePollMessageId, moderatorAccountId);
        try
        {
            bool success = await _youTubeClient.EndPollAsync(moderatorAccountId, ActivePollMessageId);
            if (success)
            {
                _logger.LogInformation("{Action} succeeded for Poll Message ID: {PollId}", actionName, ActivePollMessageId);
                SendSystemMessage("YouTube poll ended successfully.", SystemMessageLevel.Info);
                ActivePollMessageId = null;
            }
            else
            {
                _logger.LogError("{Action} failed: EndPollAsync returned false for Poll Message ID: {PollId}", actionName, ActivePollMessageId);
                SendSystemMessage("Failed to end the YouTube poll. API call failed.", SystemMessageLevel.Error);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "{Action} failed during API call for Poll Message ID: {PollId}", actionName, ActivePollMessageId);
            SendSystemMessage($"Error ending YouTube poll: {ex.Message}", SystemMessageLevel.Error);
        }
    }
    private string? GetModeratorAccountId(string actionName)
    {
        if (SelectedSendTarget == null)
        {
            _logger.LogError("{Action} cannot proceed: No send target selected.", actionName);
            return null;
        }
        string? moderatorAccountId = null;
        if (SelectedSendTarget.Platform == "YouTube" && SelectedSendTarget.AccountId != null)
        {
            moderatorAccountId = SelectedSendTarget.AccountId;
        }
        else if (SelectedSendTarget.Platform == "All")
        {
            moderatorAccountId = _settingsService.CurrentSettings?.Connections?.YouTubeAccounts?
                .FirstOrDefault(acc => !string.IsNullOrEmpty(acc.ChannelId) && IsAccountConnected(acc.ChannelId, "YouTube"))?
                .ChannelId;
        }
        if (string.IsNullOrEmpty(moderatorAccountId))
        {
            _logger.LogError("{Action} cannot proceed: Could not determine a valid YouTube account ID from selection '{SelectedTarget}'.", actionName, SelectedSendTarget.DisplayName);
            SendSystemMessage($"Cannot {actionName}: No connected YouTube account selected or available.", SystemMessageLevel.Error);
            return null;
        }
        return moderatorAccountId;
    }
    private void SendSystemMessage(string message, SystemMessageLevel level)
    {
        SystemMessageEvent systemEvent = new()
        {
            Level = level,
            Message = message
        };
        _messenger.Send(new NewEventMessage(systemEvent));
    }
    public void Dispose()
    {
        if (_isDisposed) return;
        _isDisposed = true;
        _logger.LogInformation("Disposing...");
        _messenger.UnregisterAll(this);
        _dispatcherQueue.TryEnqueue(() =>
        {
            SendTargets?.Clear();
            Events?.Clear();
        });
        _logger.LogInformation("Disposed and Unregistered.");
        GC.SuppressFinalize(this);
    }
}
public class SendTarget
{
    public string DisplayName { get; set; } = string.Empty;
    public string Platform { get; set; } = string.Empty;
    public string? AccountId { get; set; }
    public string? AccountChannelName { get; set; }
    public bool IsSpecificAccount => Platform != "All" && !string.IsNullOrEmpty(AccountId);
}
</file>

<file path=".github/workflows/master.yml">
name: Build and Deploy
permissions:
  contents: write
on:
  push:
    branches:
      - master
jobs:
  deploy-to-github-release:
    runs-on: windows-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
      - name: Get Version from Project File
        id: get-version
        shell: bash
        run: echo "version=$(grep -oE '<Version>[^<]+' StreamWeaver.csproj | sed 's/<Version>//')" >> $GITHUB_OUTPUT
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'
          cache-dependency-path: Web/Overlay/package-lock.json
      - name: Cache Node Modules
        uses: actions/cache@v4
        with:
          path: Web/Overlay/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('Web/Overlay/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-
      - name: Install .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x
      - name: Publish Applications
        run: dotnet publish .\StreamWeaver.csproj -c Release -f net9.0-windows10.0.19041.0 -r win-x64 --self-contained -o "bin\win-x64\publish\" -p:PublishSingleFile=false -p:PublishReadyToRun=false -p:PublishTrimmed=false -p:UseLocalYTLiveChat=false -p:UseLocalTTSTextNormalization=false
      - name: Create Release
        run: |
          dotnet tool install -g vpk
          vpk download github --repoUrl https://github.com/${{ github.repository }} --token ${{ secrets.GITHUB_TOKEN }}
          vpk pack -u StreamWeaver -v ${{ steps.get-version.outputs.version }} -p .\bin\win-x64\publish\ -e StreamWeaver.exe
          vpk upload github --repoUrl https://github.com/${{ github.repository }} --publish --releaseName "StreamWeaver ${{ steps.get-version.outputs.version }}" --tag v${{ steps.get-version.outputs.version }} --token ${{ secrets.GITHUB_TOKEN }}
</file>

<file path="App.xaml.cs">
using System;
using CommunityToolkit.Mvvm.Messaging;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Logging;
using Microsoft.UI.Dispatching;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using StreamWeaver.Core.Plugins;
using StreamWeaver.Core.Services;
using StreamWeaver.Core.Services.Authentication;
using StreamWeaver.Core.Services.Logging;
using StreamWeaver.Core.Services.Platforms;
using StreamWeaver.Core.Services.Settings;
using StreamWeaver.Core.Services.Tts;
using StreamWeaver.Core.Services.Web;
using StreamWeaver.Modules.Goals;
using StreamWeaver.Modules.Subathon;
using StreamWeaver.UI.ViewModels;
using TTSTextNormalization.DependencyInjection;
using TTSTextNormalization.Rules;
using Velopack;
using Velopack.Exceptions;
using Velopack.Sources;
using YTLiveChat.Contracts;
namespace StreamWeaver;
public partial class App : Application
{
    public static Window? MainWindow { get; private set; }
    public IServiceProvider Services { get; }
    private static IServiceProvider? s_serviceProvider;
    private static ILogger<App>? s_logger;
    private static PluginService? s_pluginServiceInstance;
    private static IConfigurationRoot? s_configurationRoot;
    private static List<Type> s_discoveredPluginTypes = [];
    private static UpdateManager? s_updateManager;
    private static UpdateInfo? s_pendingUpdateInfo;
    private static bool s_updateDownloadInitiated = false;
    private static bool s_updateAppliedOrDeferred = false;
    private static readonly Lock s_updateLock = new();
    public App()
    {
#if !DEBUG
        VelopackApp
            .Build()
            .OnFirstRun(
                (
                    v
                ) => {
                }
            )
            .Run();
#endif
        Services = ConfigureServices();
        s_serviceProvider = Services;
        s_logger = Services.GetRequiredService<ILogger<App>>();
        s_pluginServiceInstance = Services.GetRequiredService<PluginService>();
        InitializeComponent();
#if !DEBUG
        _ = CheckForUpdatesInBackgroundAsync(TimeSpan.FromSeconds(5));
#endif
        _ = Services.GetService<ITtsService>();
        s_logger?.LogInformation("Eagerly resolved ITtsService to initiate background initialization.");
    }
    public static T GetService<T>()
        where T : class =>
        s_serviceProvider == null
            ? throw new InvalidOperationException("Service provider is not initialized.")
            : s_serviceProvider.GetRequiredService<T>();
    private static ServiceProvider ConfigureServices()
    {
        ServiceCollection services = [];
        services.AddSingleton(
            DispatcherQueue.GetForCurrentThread()
                ?? throw new InvalidOperationException("Cannot get DispatcherQueue on non-UI thread during service configuration.")
        );
        string appDataFolder = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        string appFolder = Path.Combine(appDataFolder, "StreamWeaver");
        Directory.CreateDirectory(appFolder);
        string userSettingsPath = Path.Combine(appFolder, "user_settings.json");
        IConfigurationBuilder configBuilder = new ConfigurationBuilder()
            .SetBasePath(AppContext.BaseDirectory)
            .AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
            .AddJsonFile(userSettingsPath, optional: true, reloadOnChange: true)
            .AddEnvironmentVariables();
        s_configurationRoot = configBuilder.Build();
        services.AddSingleton<IConfiguration>(s_configurationRoot);
        services.AddSingleton(s_configurationRoot);
        services.AddLogging(builder =>
        {
            builder.AddConsole();
            builder.AddObservableLogger();
#if DEBUG
            builder.SetMinimumLevel(LogLevel.Debug);
#else
            builder.SetMinimumLevel(LogLevel.Information);
#endif
            builder.AddFilter("Microsoft.AspNetCore", LogLevel.Warning);
            builder.AddFilter("Microsoft.Hosting.Lifetime", LogLevel.Information);
            builder.AddFilter("Grpc.Net.Client", LogLevel.Warning);
            builder.AddFilter("Microsoft.EntityFrameworkCore", LogLevel.Warning);
            builder.AddFilter("System.Net.Http.HttpClient.YouTubeClient.ClientHandler", LogLevel.Warning);
            builder.AddFilter("System.Net.Http.HttpClient.YouTubeClient.LogicalHandler", LogLevel.Warning);
            builder.AddFilter("System.Net.Http.HttpClient.YTHttpClient.ClientHandler", LogLevel.Warning);
            builder.AddFilter("System.Net.Http.HttpClient.YTHttpClient.LogicalHandler", LogLevel.Warning);
        });
        services.AddSingleton<LogViewerService>();
        services.AddSingleton<PluginService>();
        string pluginsPath = Path.Combine(AppContext.BaseDirectory, "Plugins");
        s_discoveredPluginTypes = PluginService.DiscoverAndRegisterPlugins(pluginsPath, services, s_configurationRoot);
        services.Configure<AbbreviationRuleOptions>(options =>
        {
        });
        services.Configure<UrlRuleOptions>(options =>
        {
            options.PlaceholderText = " link ";
        });
        services.Configure<EmojiRuleOptions>(options =>
        {
            options.Suffix = " emoji";
        });
        services.AddTextNormalization(builder =>
        {
            builder.AddBasicSanitizationRule();
            builder.AddUrlNormalizationRule();
            builder.AddEmojiRule();
            builder.AddCurrencyRule();
            builder.AddAbbreviationNormalizationRule();
            builder.AddNumberNormalizationRule();
            builder.AddExcessivePunctuationRule();
            builder.AddLetterRepetitionRule();
            builder.AddWhitespaceNormalizationRule();
        });
        services.AddSingleton<IMessenger>(WeakReferenceMessenger.Default);
        services.AddSingleton<ISettingsService, SettingsService>();
        services.AddSingleton<ITokenStorageService, TokenStorageService>();
        services.AddSingleton<IEmoteBadgeService, EmoteBadgeService>();
        services.AddSingleton<TwitchAuthService>();
        services.AddSingleton<YouTubeAuthService>();
        services.AddSingleton<TwitchApiService>();
        services.AddSingleton<ITwitchClient, TwitchChatService>();
        services.AddSingleton<IYouTubeClient, YouTubeService>();
        services.AddSingleton<IStreamlabsClient, StreamlabsService>();
        services.Configure<YTLiveChatOptions>(options =>
        {
            options.RequestFrequency = 1000;
            options.DebugLogReceivedJsonItems = true;
        });
        services.AddYTLiveChat();
        services.AddSingleton<TtsFormattingService>();
        services.AddSingleton<WindowsTtsService>();
        services.AddSingleton<KokoroTtsService>();
        services.AddSingleton<IEngineSpecificTtsService, WindowsTtsService>(sp => sp.GetRequiredService<WindowsTtsService>());
        services.AddSingleton<IEngineSpecificTtsService, KokoroTtsService>(sp => sp.GetRequiredService<KokoroTtsService>());
        services.AddSingleton<ITtsService, CompositeTtsService>();
        services.AddSingleton<UnifiedEventService>();
        services.AddSingleton<WebSocketManager>();
        services.AddSingleton<WebServerService>();
        services.AddSingleton<MainChatViewModel>();
        services.AddTransient<MainWindowViewModel>();
        services.AddTransient<SettingsViewModel>();
        services.AddSingleton<LogsViewModel>();
        services.AddSingleton<SubathonService>();
        services.AddSingleton<GoalService>();
        return services.BuildServiceProvider(new ServiceProviderOptions { ValidateOnBuild = true, ValidateScopes = true });
    }
    protected override async void OnLaunched(LaunchActivatedEventArgs args)
    {
        s_logger?.LogInformation("OnLaunched Started.");
        ILogger<MainWindow> mainWindowLogger = Services.GetRequiredService<ILogger<MainWindow>>();
        MainWindowViewModel mainWindowViewModel = Services.GetRequiredService<MainWindowViewModel>();
        MainWindow = new MainWindow(mainWindowLogger, mainWindowViewModel);
        if (MainWindow.Content == null)
        {
            s_logger?.LogDebug("MainWindow content is null, setting up basic Frame.");
            Frame rootFrame = new();
            MainWindow.Content = rootFrame;
        }
        MainWindow.Activate();
        s_logger?.LogInformation("MainWindow Activated.");
        try
        {
            s_logger?.LogInformation("Initializing core services...");
            ISettingsService settingsService = Services.GetRequiredService<ISettingsService>();
            s_logger?.LogDebug("Loading settings...");
            await settingsService.LoadSettingsAsync();
            s_logger?.LogDebug("Settings loaded.");
            IEmoteBadgeService emoteBadgeService = Services.GetRequiredService<IEmoteBadgeService>();
            s_logger?.LogDebug("Loading global emote/badge data...");
            await emoteBadgeService.LoadGlobalTwitchDataAsync();
            s_logger?.LogDebug("Global emote/badge data load attempted.");
            WebServerService webServer = Services.GetRequiredService<WebServerService>();
            s_logger?.LogDebug("Starting web server...");
            _ = Task.Run(webServer.StartAsync);
            UnifiedEventService unifiedEventService = Services.GetRequiredService<UnifiedEventService>();
            s_logger?.LogDebug("Initializing UnifiedEventService...");
            await unifiedEventService.InitializeAsync();
            s_logger?.LogDebug("UnifiedEventService initialized.");
            s_logger?.LogDebug("Initializing PluginService...");
            if (s_pluginServiceInstance != null && s_configurationRoot != null && s_discoveredPluginTypes != null)
            {
                s_logger?.LogDebug(
                    "Initializing loaded plugins via singleton PluginService (with {TypeCount} discovered types)...",
                    s_discoveredPluginTypes.Count
                );
                await s_pluginServiceInstance.InitializeLoadedPluginsAsync(s_discoveredPluginTypes, s_configurationRoot);
                s_logger?.LogInformation(
                    "PluginService InitializeLoadedPluginsAsync complete. {LoadedCount} plugins loaded.",
                    s_pluginServiceInstance.LoadedPlugins.Count
                );
            }
            else
            {
                s_logger?.LogError("Cannot initialize plugins: PluginService instance, ConfigurationRoot, or DiscoveredPluginTypes list is null.");
            }
        }
        catch (Exception ex)
        {
            s_logger?.LogCritical(ex, "FATAL: Failed to initialize services or plugins on launch.");
            if (MainWindow?.Content?.XamlRoot != null)
            {
                ContentDialog dialog = new()
                {
                    Title = "Initialization Error",
                    Content = $"Failed to start essential services or load plugins: {ex.Message}\n\nSee logs for more details.",
                    CloseButtonText = "OK",
                    XamlRoot = MainWindow.Content.XamlRoot,
                };
                await dialog.ShowAsync();
            }
            else
            {
                s_logger?.LogError("Could not show initialization error dialog: MainWindow or XamlRoot is null.");
            }
        }
        s_logger?.LogInformation("OnLaunched Finished.");
    }
    private static async Task CheckForUpdatesInBackgroundAsync(TimeSpan? delay = null)
    {
        if (s_logger == null)
            return;
        if (delay.HasValue)
        {
            s_logger.LogInformation("Delaying update check for {DelaySeconds} seconds.", delay.Value.TotalSeconds);
            await Task.Delay(delay.Value);
        }
        lock (s_updateLock)
        {
            if (s_updateDownloadInitiated || s_updateAppliedOrDeferred)
            {
                s_logger.LogInformation("Update check skipped: Download already in progress or update decision made.");
                return;
            }
        }
        s_logger.LogInformation("Starting background update check...");
        try
        {
            var source = new GithubSource("https://github.com/Agash/StreamWeaver", null, false);
            s_updateManager = new UpdateManager(source);
            s_logger.LogDebug("Checking for updates...");
            UpdateInfo? updateInfo = await s_updateManager.CheckForUpdatesAsync();
            if (updateInfo == null)
            {
                s_logger.LogInformation("No update available.");
                return;
            }
            s_logger.LogInformation(
                "Update found: v{Version}. Current version: v{CurrentVersion}",
                updateInfo.TargetFullRelease.Version,
                s_updateManager.CurrentVersion
            );
            lock (s_updateLock)
            {
                if (s_updateDownloadInitiated || s_updateAppliedOrDeferred)
                    return;
                s_pendingUpdateInfo = updateInfo;
                s_updateDownloadInitiated = true;
            }
            s_logger.LogInformation("Initiating background download for update v{Version}.", updateInfo.TargetFullRelease.Version);
            _ = Task.Run(() => DownloadUpdateAsync(updateInfo));
        }
#if DEBUG
        catch (NotInstalledException ex)
        {
            s_logger.LogDebug(ex, "Update check failed because unpackaged execution (DEBUG mode)");
            lock (s_updateLock)
            {
                s_updateDownloadInitiated = false;
                s_pendingUpdateInfo = null;
            }
        }
#endif
        catch (Exception ex)
        {
            s_logger.LogError(ex, "Update check failed.");
            lock (s_updateLock)
            {
                s_updateDownloadInitiated = false;
                s_pendingUpdateInfo = null;
            }
        }
    }
    private static async Task DownloadUpdateAsync(UpdateInfo updateInfo)
    {
        if (s_updateManager == null)
            return;
        try
        {
            s_logger?.LogInformation("Background download started for v{Version}.", updateInfo.TargetFullRelease.Version);
            await s_updateManager.DownloadUpdatesAsync(updateInfo);
            s_logger?.LogInformation("Update v{Version} downloaded successfully.", updateInfo.TargetFullRelease.Version);
            DispatcherQueue dispatcherQueue = GetService<DispatcherQueue>();
            if (dispatcherQueue == null)
            {
                s_logger?.LogError("Cannot show update prompt: DispatcherQueue is null after download.");
                lock (s_updateLock)
                {
                    s_updateDownloadInitiated = false;
                    s_pendingUpdateInfo = null;
                }
                return;
            }
            dispatcherQueue.TryEnqueue(() =>
            {
                lock (s_updateLock)
                {
                    if (!s_updateAppliedOrDeferred)
                    {
                        _ = ShowUpdatePromptAsync(updateInfo);
                    }
                    else
                    {
                        s_logger?.LogInformation("Update prompt skipped: Update was applied or deferred during download.");
                    }
                }
            });
        }
        catch (Exception ex)
        {
            s_logger?.LogError(ex, "Update download failed for v{Version}.", updateInfo.TargetFullRelease.Version);
            lock (s_updateLock)
            {
                s_updateDownloadInitiated = false;
                s_pendingUpdateInfo = null;
            }
            DispatcherQueue dispatcherQueue = GetService<DispatcherQueue>();
            if (dispatcherQueue != null && MainWindow?.Content?.XamlRoot != null)
            {
                dispatcherQueue.TryEnqueue(async () =>
                {
                    ContentDialog errorDialog = new()
                    {
                        Title = "Update Download Failed",
                        Content =
                            $"Could not download the latest update. Please check your internet connection or logs for details.\nError: {ex.Message}",
                        CloseButtonText = "OK",
                        XamlRoot = MainWindow.Content.XamlRoot,
                    };
                    await errorDialog.ShowAsync();
                });
            }
        }
    }
    private static async Task ShowUpdatePromptAsync(UpdateInfo updateInfo)
    {
        if (s_updateManager == null || MainWindow?.Content?.XamlRoot == null)
        {
            s_logger?.LogError("Cannot show update prompt: UpdateManager or MainWindow/XamlRoot is null.");
            lock (s_updateLock)
            {
                s_updateDownloadInitiated = false;
                s_pendingUpdateInfo = null;
            }
            return;
        }
        lock (s_updateLock)
        {
            if (s_updateAppliedOrDeferred)
            {
                s_logger?.LogInformation("Update prompt skipped: Update decision already made.");
                return;
            }
        }
        s_logger?.LogInformation("Showing update prompt to user.");
        ContentDialog updateDialog = new()
        {
            Title = "Update Available",
            Content = $"A new version (v{updateInfo.TargetFullRelease.Version}) is ready. Install it now?",
            PrimaryButtonText = "Install Now & Restart",
            SecondaryButtonText = "Install on Exit",
            DefaultButton = ContentDialogButton.Primary,
            XamlRoot = MainWindow.Content.XamlRoot,
        };
        ContentDialogResult result = await updateDialog.ShowAsync();
        lock (s_updateLock)
        {
            s_updateAppliedOrDeferred = true;
            switch (result)
            {
                case ContentDialogResult.Primary:
                    s_logger?.LogInformation("User chose to install update now.");
                    try
                    {
                        s_updateManager.ApplyUpdatesAndRestart(updateInfo);
                    }
                    catch (Exception ex)
                    {
                        s_logger?.LogError(ex, "Failed to apply updates and restart.");
                        s_updateAppliedOrDeferred = false;
                        ShowErrorDialog("Update Installation Failed", $"Could not install the update. Error: {ex.Message}");
                    }
                    break;
                case ContentDialogResult.Secondary:
                    s_logger?.LogInformation("User chose to install update on exit.");
                    try
                    {
                        s_updateManager.WaitExitThenApplyUpdates(updateInfo);
                        s_logger?.LogInformation("Update scheduled to be applied on application exit.");
                    }
                    catch (Exception ex)
                    {
                        s_logger?.LogError(ex, "Failed to schedule update for application exit.");
                        s_updateAppliedOrDeferred = false;
                        ShowErrorDialog("Update Scheduling Failed", $"Could not schedule the update. Error: {ex.Message}");
                    }
                    break;
                case ContentDialogResult.None:
                default:
                    s_logger?.LogInformation("User chose to install update later or closed the dialog.");
                    break;
            }
        }
    }
    private static async void ShowErrorDialog(string title, string content)
    {
        if (MainWindow?.Content?.XamlRoot == null)
        {
            s_logger?.LogError("Cannot show error dialog '{Title}': MainWindow/XamlRoot is null.", title);
            return;
        }
        ContentDialog errorDialog = new()
        {
            Title = title,
            Content = content,
            CloseButtonText = "OK",
            XamlRoot = MainWindow.Content.XamlRoot,
        };
        await errorDialog.ShowAsync();
    }
}
public static class ObservableLoggerExtensions
{
    public static ILoggingBuilder AddObservableLogger(this ILoggingBuilder builder)
    {
        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<ILoggerProvider, ObservableLoggerProvider>());
        return builder;
    }
}
</file>

<file path="StreamWeaver.csproj">
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
		<OutputType>WinExe</OutputType>
    <TargetFramework>net9.0-windows10.0.19041</TargetFramework>
    <TargetPlatformMinVersion>10.0.17763.0</TargetPlatformMinVersion>
		<RootNamespace>StreamWeaver</RootNamespace>
		<ApplicationManifest>app.manifest</ApplicationManifest>
		<Platforms>x86;x64;ARM64</Platforms>
		<RuntimeIdentifiers>win-x86;win-x64;win-arm64</RuntimeIdentifiers>
		<UseWinUI>true</UseWinUI>
		<EnableMsixTooling>true</EnableMsixTooling>
		<WindowsPackageType>None</WindowsPackageType>
		<SelfContained>true</SelfContained>
		<IncludeWindowsRuntimeSupport>true</IncludeWindowsRuntimeSupport>
		<Nullable>enable</Nullable>
		<LangVersion>preview</LangVersion>
		<UseAppHost>true</UseAppHost>

    <!-- Versioning - Used by Velopack -->
    <Version>0.1.2</Version>
    <!-- Application Title - Used by Velopack -->
    <ApplicationTitle>StreamWeaver</ApplicationTitle>
	</PropertyGroup>
  <ItemGroup>
    <Content Remove="Assets\twitch.svg" />
    <Content Remove="Assets\youtube.svg" />
  </ItemGroup>
  
    <ItemGroup>
      <None Remove="Assets\Badges\youtube_moderator.svg" />
      <None Remove="Assets\Badges\youtube_owner.svg" />
      <None Remove="Assets\Badges\youtube_verified.svg" />
      <None Remove="UI\Dialogs\CreatePollDialog.xaml" />
      <None Remove="UI\Views\ConnectAccountDialog.xaml" />
      <None Remove="UI\Views\LogsView.xaml" />
      <None Remove="UI\Views\MainChatView.xaml" />
      <None Remove="UI\Views\SettingsPages\AccountsSettingsPage.xaml" />
      <None Remove="UI\Views\SettingsPages\CredentialsSettingsPage.xaml" />
      <None Remove="UI\Views\SettingsPages\ModulesSettingsPage.xaml" />
      <None Remove="UI\Views\SettingsPages\OverlaysSettingsPage.xaml" />
      <None Remove="UI\Views\SettingsPages\TtsSettingsPage.xaml" />
      <None Remove="UI\Views\SettingsView.xaml" />
    </ItemGroup>

	<ItemGroup>
		<Content Include="Assets\SplashScreen.scale-200.png" />
		<Content Include="Assets\LockScreenLogo.scale-200.png" />
		<Content Include="Assets\Square150x150Logo.scale-200.png" />
		<Content Include="Assets\Square44x44Logo.scale-200.png" />
		<Content Include="Assets\Square44x44Logo.targetsize-24_altform-unplated.png" />
		<Content Include="Assets\StoreLogo.png" />
		<Content Include="Assets\Wide310x150Logo.scale-200.png" />
		<Content Include="Web\Overlay\src\assets\icons\youtube_moderator.svg" />
		<Content Include="Web\Overlay\src\assets\icons\youtube_owner.svg" />
		<Content Include="Web\Overlay\src\assets\icons\youtube_verified.svg" />
	</ItemGroup>

	<ItemGroup>
		<Manifest Include="$(ApplicationManifest)" />
	</ItemGroup>

	<!--
    Defining the "Msix" ProjectCapability here allows the Single-project MSIX Packaging
    Tools extension to be activated for this project even if the Windows App SDK Nuget
    package has not yet been restored.
  -->
	<ItemGroup Condition="'$(DisableMsixProjectCapabilityAddedByProject)'!='true' and '$(EnableMsixTooling)'=='true'">
		<ProjectCapability Include="Msix" />
	</ItemGroup>
	<ItemGroup>
		<FrameworkReference Include="Microsoft.AspNetCore.App" />   
		<PackageReference Include="CommunityToolkit.Mvvm" Version="8.4.0" />
		<PackageReference Include="CommunityToolkit.WinUI.Animations" Version="8.2.250402" />
		<PackageReference Include="CommunityToolkit.WinUI.Controls.SettingsControls" Version="8.2.250402" />
		<PackageReference Include="CommunityToolkit.WinUI.Converters" Version="8.2.250402" />
		<PackageReference Include="CommunityToolkit.WinUI.Extensions" Version="8.2.250402" />
		<PackageReference Include="CommunityToolkit.WinUI.Helpers" Version="8.2.250402" />
		<PackageReference Include="Google.Apis.Auth" Version="1.69.0" />
		<PackageReference Include="Google.Apis.YouTube.v3" Version="1.69.0.3742" />
		<PackageReference Include="KokoroSharp" Version="0.5.6" />
		<PackageReference Include="Microsoft.Extensions.Configuration" Version="9.0.4" />
		<PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="9.0.4" />
		<PackageReference Include="Microsoft.Extensions.Configuration.CommandLine" Version="9.0.4" />
		<PackageReference Include="Microsoft.Extensions.Configuration.EnvironmentVariables" Version="9.0.4" />
		<PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="9.0.4" />
		<PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="9.0.4" />
		<PackageReference Include="Microsoft.Extensions.Hosting" Version="9.0.4" />
		<PackageReference Include="Microsoft.Extensions.Logging" Version="9.0.4" />
		<PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="9.0.4" />
		<PackageReference Include="Microsoft.Windows.SDK.BuildTools" Version="10.0.26100.1742" />
		<PackageReference Include="Microsoft.WindowsAppSDK" Version="1.7.250401001" />
		<PackageReference Include="ObsWebSocket.Core" Version="0.1.4" />
		<PackageReference Include="SocketIOClient" Version="3.1.2" />
		<PackageReference Include="System.Speech" Version="9.0.4" />
		<PackageReference Include="TwitchLib.Api" Version="3.9.0" />
		<PackageReference Include="TwitchLib.Client" Version="3.3.1" />
    <PackageReference Include="Velopack" Version="0.0.1213-g57cf68d" />
	</ItemGroup>
	<ItemGroup>
	  <Folder Include="UI\Templates\" />
	</ItemGroup>

  <!-- Define local YTLivechat switch (optional: set default to true for local dev) -->
  <PropertyGroup>
    <UseLocalYTLiveChat Condition="'$(UseLocalYTLiveChat)' == ''">true</UseLocalYTLiveChat>
  </PropertyGroup>

  <!-- Conditional inclusion of ProjectReference or PackageReference -->
  <ItemGroup Condition="'$(UseLocalYTLiveChat)' == 'true'">
    <ProjectReference Include="..\YTLiveChat\YTLiveChat\YTLiveChat.csproj" />
  </ItemGroup>

  <ItemGroup Condition="'$(UseLocalYTLiveChat)' != 'true'">
    <PackageReference Include="Agash.YTLiveChat" Version="*" />
  </ItemGroup>

  <!-- Define local TTSTextNormalization switch (optional: set default to true for local dev) -->
  <PropertyGroup>
    <UseLocalYTLiveChat Condition="'$(UseLocalTTSTextNormalization)' == ''">true</UseLocalYTLiveChat>
  </PropertyGroup>

  <!-- Conditional inclusion of ProjectReference or PackageReference -->
  <ItemGroup Condition="'$(UseLocalTTSTextNormalization)' == 'true'">
    <ProjectReference Include="..\TTSTextNormalization\TTSTextNormalization\TTSTextNormalization.csproj" />
  </ItemGroup>

  <ItemGroup Condition="'$(UseLocalTTSTextNormalization)' != 'true'">
    <PackageReference Include="Agash.TTSTextNormalization" Version="*" />
  </ItemGroup>

	<ItemGroup>
	  <Page Update="UI\Views\SettingsPages\CredentialsSettingsPage.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </Page>
	  <Page Update="UI\Views\SettingsPages\AccountsSettingsPage.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </Page>
	  <Page Update="UI\Views\SettingsPages\OverlaysSettingsPage.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </Page>
	  <Page Update="UI\Views\SettingsPages\TtsSettingsPage.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </Page>
	  <Page Update="UI\Views\SettingsPages\ModulesSettingsPage.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </Page>
	  <Page Update="UI\Views\SettingsPages\PluginsSettingsPage.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </Page>
	  <Page Update="UI\Views\LogsView.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </Page>
	  <Page Update="UI\Dialogs\CreatePollDialog.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </Page>
	  <Page Update="UI\Views\MainChatView.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </Page>
	  <Page Update="UI\Views\ConnectAccountDialog.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </Page>
	  <Page Update="UI\Views\SettingsView.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </Page>
	</ItemGroup>

  <!-- Build React App before .NET build -->
  <Target Name="BuildReactApp" BeforeTargets="Build" Condition="'$(Configuration)' != 'Debug'">
    <Message Importance="high" Text="Building React app in Web/Overlay..." />
    <Exec WorkingDirectory="Web\Overlay" Command="npm ci" />
    <Exec WorkingDirectory="Web\Overlay" Command="npm run build" />
  </Target>

  <!-- Ensure dist is copied to output -->
  <ItemGroup>
    <None Update="Web\Overlay\dist\**\*">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>

  <!-- Publish Properties -->
  <PropertyGroup>
    <PublishReadyToRun Condition="'$(Configuration)' == 'Debug'">False</PublishReadyToRun>
    <PublishReadyToRun Condition="'$(Configuration)' != 'Debug'">True</PublishReadyToRun>
    <PublishTrimmed Condition="'$(Configuration)' == 'Debug'">False</PublishTrimmed>
    <PublishTrimmed Condition="'$(Configuration)' != 'Debug'">True</PublishTrimmed>
    <ImplicitUsings>enable</ImplicitUsings>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <PlatformTarget>AnyCPU</PlatformTarget>
  </PropertyGroup>
</Project>
</file>

</files>
